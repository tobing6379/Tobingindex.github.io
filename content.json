{"meta":{"title":"tobing","subtitle":"时不待我，舍我其谁","description":"tobing的博客","author":"tobing","url":"https://tobing.top","root":"/"},"pages":[{"title":"关于","date":"2019-10-02T02:37:33.000Z","updated":"2021-01-15T04:25:36.627Z","comments":true,"path":"about/index.html","permalink":"https://tobing.top/about/index.html","excerpt":"","text":"关于作者Tobing，为什么是 Tobing 呢？因为 Tobing 暗含 to bing，bing是微软的搜索引擎，高三在注册域名的时候感觉 bing 这个单词比较酷，于是就沿用了。 2018级西南石油大学本科，专业本是材控，大一下转专业到物联网工程，一直对Java比较感兴趣。 关于博客互联网是有记忆的，如果有一天我不在了，我希望留下一些活过的痕迹，其次，可以对学习或生活遇到的问题进行整理，方便翻阅。 关于头像植物大战僵尸的小坚果，憨憨的。 联系方式邮箱：&#x36;&#53;&#50;&#x39;&#49;&#x36;&#x35;&#x37;&#56;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d; Github：https://github.com/Tobingindex Gitee：https://gitee.com/tobing 时间戳 时间 事件 2019-10-02 搭建Hexo博客 2021-01-14 将主题改为volantis 2021-01-15 博客部分整理 补充对文中预览修改了，图片问题基本也解决了。 支持主题：Hexo+volantis 写作：Typora(Markdown)+PinGo 图床：阿里云/Gitee"},{"title":"所有分类","date":"2021-01-14T06:06:50.505Z","updated":"2021-01-14T06:06:50.505Z","comments":true,"path":"categories/index.html","permalink":"https://tobing.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-14T06:07:13.148Z","updated":"2021-01-14T06:07:13.148Z","comments":true,"path":"tags/index.html","permalink":"https://tobing.top/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-01-14T06:08:42.408Z","updated":"2021-01-14T06:08:42.408Z","comments":true,"path":"friends/index.html","permalink":"https://tobing.top/friends/index.html","excerpt":"","text":"于无声处听惊雷：Java博主 Zenyet：Java博主"}],"posts":[{"title":"代理模式","slug":"代理模式","date":"2021-03-11T08:46:40.000Z","updated":"2021-03-11T09:59:34.667Z","comments":true,"path":"2021/03/11/代理模式/","link":"","permalink":"https://tobing.top/2021/03/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"代理模式对于我们来说并不难理解，日常生活中我们经常能看到代理模式的影子。我们平时使用「智行」、「同程」等买票的时候，就是一个典型代理模式的应用。 1我们(使用者) ----- 智行&#x2F;同程(代理者) ----&gt; 12306(被代理者) 我们不直接通过12306买票，因为这样抢票并不方便，我们通过「智行」/「同程」等第三方专业机构来帮我们买票，这些机构建来代替我们去12306买票，同时这些机构代代理买票的过程中会增强一系列功能，如：增值服务、用户消费记录等。 Java中也是实现了代理模式，本文我们来讨论一下「代理模式」。","text":"代理模式对于我们来说并不难理解，日常生活中我们经常能看到代理模式的影子。我们平时使用「智行」、「同程」等买票的时候，就是一个典型代理模式的应用。 1我们(使用者) ----- 智行&#x2F;同程(代理者) ----&gt; 12306(被代理者) 我们不直接通过12306买票，因为这样抢票并不方便，我们通过「智行」/「同程」等第三方专业机构来帮我们买票，这些机构建来代替我们去12306买票，同时这些机构代代理买票的过程中会增强一系列功能，如：增值服务、用户消费记录等。 Java中也是实现了代理模式，本文我们来讨论一下「代理模式」。 代理模式1、概述使用代理对象来代替真实对象的访问，可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。 2、静态代理静态代理中，对目标的每个方法增强都是通过手动完成。实际应用场景很少，日常开发几乎用不到。 【静态代理的实现步骤：】 定义一个接口及其实现类； 创建一个代理类实现这个类； 将目标对象放到代理类中，任何代理类的对应方法调用目标类的对应方法，主要可以通过代理类屏蔽对目标对象的访问。 场景：买火车票我们不通过12306买票，而是使用「智行」、「同程」等代理购买，这些软件可以提供更加智能的路线选择，同时也提供了一些增值的服务(增强) 卖票接口 123public interface SellTicket &#123; String sell(Integer money);&#125; 12306网站 1234567public class SellTicketImpl implements SellTicket &#123; @Override public String sell(Integer money) &#123; System.out.println(&quot;花费&quot; + money + &quot;元购票.&quot;); return &quot;购票成功&quot;; &#125;&#125; 智行 1234567891011121314public class ZhixingProxy implements SellTicket &#123; private SellTicket sellTicket; public ZhixingProxy(SellTicket sellTicket) &#123; this.sellTicket = sellTicket; &#125; @Override public String sell(Integer money) &#123; money -= 10; // 收取手续费 System.out.println(&quot;[INFO]:智行购票中...&quot;); String ret = sellTicket.sell(money);// 购票 System.out.println(&quot;[INFO]:智行购票成功...&quot;); return &quot;智行:&quot; + ret; &#125;&#125; 使用者 12345678public class ProxyDemo &#123; public static void main(String[] args) &#123; SellTicketImpl sellTicket = new SellTicketImpl(); ZhixingProxy zhixingProxy = new ZhixingProxy(sellTicket); String ret = zhixingProxy.sell(100); System.out.println(ret); &#125;&#125; 输出 1234[INFO]:智行购票中...花费90元购票.[INFO]:智行购票成功...智行:购票成功 3、动态代理与静态代理相比，动态代理更加灵活，不需要针对每一个目标对象单独创建一个代理类，并且不需要必须实现接口，可以直接代理实现类。 JVM动态生成代理类的字节码。Spring AOP、RPC框架的实现都依赖了动态代理。 动态代理实际开发中使用较少，但是框架中被频繁使用。 Java 动态代理实现主要有两种：JDK 动态代理、CGLIB 动态代理。 3.1 JDK 动态代理3.1.1 APIJDK 动态代理中 InvocationHandler 接口和 Proxy 类是核心。 Proxy 类中的 newProxyInstance() 方法用来生成一个代理对象。 123456public static Object newProxyInstance(ClassLoader loader, // 类加载器，用来加载代理对象 Class&lt;?&gt;[] interfaces, // 被代理类实现的一些接口 InvocationHandler h) // 实现了 InvocationHandler 的对象 throws IllegalArgumentException &#123; ......&#125; JDK 动态代理中通过 InvocationHandler 来自定义代理逻辑。 当动态代理调用工业方法是，这个方法的调用会被转发到实现了 InvocationHandler 接口类的 invoke 方法来调用。 123456public interface InvocationHandler &#123; public Object invoke(Object proxy, // 动态生成的代理类 Method method, // 与代理类对象调用的方法相对应 Object[] args) // 当前method方法的参数 throws Throwable;&#125; 通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现了 InvocationHandler 接口类的 invoke 方法 。 因此可以在 invoke 方法中自定义处理逻辑。 3.1.2 使用步骤1、定义一个接口以及实现类，该实现类是被代理类 2、自定 InvocationHandler 接口并重写 invoke方法，在 invoke 内部调用被代理对象的方法，并自定义一些逻辑。 3、通过 Proxy.newProxyInstance 创建一个代理对象。 3.1.3 场景实现 卖票接口：参考上面 12306：参考上面 JDK 动态代理 1234567891011121314151617public class JDKProxy &#123; public static void main(String[] args) &#123; SellTicketImpl sellTicket = new SellTicketImpl(); Class&lt;SellTicketImpl&gt; sellTicketClass = SellTicketImpl.class; SellTicket sellTicketProxy = (SellTicket)Proxy.newProxyInstance(sellTicketClass.getClassLoader(), sellTicketClass.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;[JDKProxy INFO]:执行前&quot;); String ret = (String) method.invoke(sellTicket, args); System.out.println(&quot;[JDKProxy INFO]:执行后&quot;); return &quot;[JDKProxy ]:&quot; + ret; &#125; &#125;); String ret = sellTicketProxy.sell(100); System.out.println(ret); &#125;&#125; 上面代码中我们通过匿名对象的方式将InvocationHandler实现传递个newProxyInstance参数中。 输出 1234[JDKProxy INFO]:执行前花费100元购票.[JDKProxy INFO]:执行后[JDKProxy ]:购票成功 3.2 CGLib 动态代理JDK 动态代理中存在一个问题，只能代理实现了接口的类。 为了解决这个问题，可以使用 CGLIB 动态代理开避免这个问题。 CBLIB，Code Generation Lib ，是一个基于ASM的动态字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。 CGLIB 通过继承方式实现代理，很知名的开源框架使用了 CGLIB ，如 Spring AOP。 3.2.1 APICGLIB 动态代理中， MethodInterceptor 接口和 Enhancer 类是核心。 使用时需要自定义 MethodInterceptor 接口 并重写 intercept 方法，intercept 用于增强。 1234567public interface MethodInterceptor extends Callback&#123; public Object intercept(Object obj, // 被代理的对象，需要被增强的对象 java.lang.reflect.Method method,// 被增强的方法 Object[] args, // 方法传入的参数 MethodProxy proxy // 用于调用原始方法的参数 ) throws Throwable;&#125; 可以通过 Enhancer 类动态获取被代理类，当代理类调用方法时，实际调用的是 MethodInterceptor 的 intercept 方法。 3.2.2 使用步骤1、定义被代理类 2、自定义 MethodInterceptor 重写 intercept 方法，intercept 与 JDK动态代理的 invoke 方法类似。 3、通过 Enhancer 类的 create 方法创建对象。 3.2.3 代码示例 添加依赖：CGLIB 不是JDK原生内容，是有个开源项目 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 接口：参考静态代理代码 12306：参考静态代码 CGLIBProxy 1234567891011121314151617public class CGLibProxy &#123; public static void main(String[] args) &#123; SellTicketImpl sellTicket = new SellTicketImpl(); Class&lt;SellTicketImpl&gt; sellTicketClass = SellTicketImpl.class; SellTicket sellTicketProxy = (SellTicket) Enhancer.create(sellTicketClass, sellTicketClass.getInterfaces(), new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;[CGLib INFO]:动态前&quot;); String ret = (String) methodProxy.invoke(sellTicket, objects); System.out.println(&quot;[CGLib INFO]:执行后&quot;); return &quot;[CGLib INFO]:&quot; + ret; &#125; &#125;); String ret = sellTicketProxy.sell(100); System.out.println(ret); &#125;&#125; 上面通过匿名对象来传递MethodInterceptor实现。 输出 1234[CGLib INFO]:动态前花费100元购票.[CGLib INFO]:执行后[CGLib INFO]:购票成功 3.3 JDK 与 CGLIB 对比 JDK动态代理 CGLib动态代理 实现原理 反射机制生成 ASM字节码框架 使用场景 实现了接口的类 对于不实现接口的可以使用CGLib 效率 一般较高 相对较低 核心API Proxy/InvocationHandler Enhancer/MethodInterceptor 注意：由于CGlib是通过生成被代理类的子类的方式来增强，因此不用用于final修饰的类中。 4、补充-代理模式对比4.1 JDK代理和CGLIB代理使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在 JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者 方法进行代理，因为CGLib原理是动态生成被代理类的子类。 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代 理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率 低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代 理，如果没有接口使用CGLIB代理。 4.2 静态代理与动态代理动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中 的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们 可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实 现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题 5、参考 JavaGuide 黑马程序员Java设计模式详解","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"动态代理","slug":"动态代理","permalink":"https://tobing.top/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"https://tobing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"再谈反射","slug":"再谈反射","date":"2021-03-10T14:21:31.000Z","updated":"2021-03-11T08:12:14.339Z","comments":true,"path":"2021/03/10/再谈反射/","link":"","permalink":"https://tobing.top/2021/03/10/%E5%86%8D%E8%B0%88%E5%8F%8D%E5%B0%84/","excerpt":"JVM在加载完类之后，会在方法区产生一个对应的Class类型的对象，这个对象包含了完整类的结构信息。这个对象就像一面镜子，可以反映类的内部结构，我们形象地称这种机制为「反射」。反射的使用场景有很多，比如 Spring IOC 便利用了反射机制，接下我们来聊一下反射。","text":"JVM在加载完类之后，会在方法区产生一个对应的Class类型的对象，这个对象包含了完整类的结构信息。这个对象就像一面镜子，可以反映类的内部结构，我们形象地称这种机制为「反射」。反射的使用场景有很多，比如 Spring IOC 便利用了反射机制，接下我们来聊一下反射。 Reflection反射(Reflection)，指在程序运行期间可以动态获取一个类的所有信息，并且能够直接操作任意对象的内部属性以及方法。 反射是「动态语言」的关键，，可以使得编程更加灵活。 1、概述JVM的「类加载子系统」可以从文件系统或者网络中加载.class文件。加载之后的.class文件会在类加载子系统执行：加载、链接、初始化。 在加载阶段，JVM通过类的全限定类名获取定义此类的二进制字节流，将字节流代表的静态存储结构转换为方法区的运行时数据结构，并在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。 通过内存中的这个java.lang.Class，可以映射类的所有信息，因此我们形象地称这种机制为：「反射」。 2、Class2.1 Class获取的方式从上面可以知道，与类关联的Class是在加载过程生成的，可以反映类的结构信息。那么我们该然后获取到这个Class呢？主要有以下几种方式。 通过类的静态属性class，这种方式比较安全，性能较高 通过实例的getClass方法，getClass是Object的弍native方法 通过全限定类名，JDBC的驱动加载使用过这种方式 获取Class的几种方式 12345678910public class ReflectionDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 方式1：通过类的class属性获取 Class&lt;ReflectionDemo&gt; clazz1 = ReflectionDemo.class; // 方式2：通过类的实例，调用getClass方法 Class&lt;? extends ReflectionDemo&gt; clazz2 = new ReflectionDemo().getClass(); // 方式3：通过类的全限定类名 Class&lt;? extends Class&gt; clazz3 = Class.forName(&quot;top.tobing.review.ReflectionDemo&quot;).getClass(); &#125;&#125; 2.2 Class的特征Class 中可以获取某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。值得注意的是，Class具有以下特征。 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class对象 Class中常用API 方法名称 说明 static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型 或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回表示此Class所表示的实体的超类的Class Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 返回Field对象的一个数组 Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType 利用反射获取一个类的所有方法 12345678910111213141516171819202122232425public class ReflectionDemo02 &#123; public static void main(String[] args) &#123; Class&lt;String&gt; clazz = String.class; StringBuilder res = new StringBuilder(); for (Method method : clazz.getMethods()) &#123; res.append(method.getReturnType().getSimpleName()); res.append(&quot; &quot;); res.append(method.getName()); res.append(&quot;(&quot;); Parameter[] parameters = method.getParameters(); if (parameters != null &amp;&amp; parameters.length != 0) &#123; for (int i = 0; i &lt; parameters.length; i++) &#123; res.append(parameters[i].getType().getSimpleName()); res.append(&quot; &quot;); res.append(parameters[i].getName()); if (i != parameters.length - 1) &#123; res.append(&quot;, &quot;); &#125; &#125; &#125; res.append(&quot;)\\n&quot;); &#125; System.out.println(res.toString()); &#125;&#125; 3、反射的应用我们常用的Spring框架底层大量使用了反射技术。 3.1 Spring IOCIOC，Inversion Of Control，控制反转，即将对象生命周期和对象间关系等控制权从程序员手上交到Spring IOC容器中。IOC并不是一种具体的技术，而是一种设计思想。 为什么使用Spring IOC 传统的Java SE 编程中，类的数量不多，类之间的关系不复杂，可以通过new在对象内部创建需要依赖的对象，这是一种主动的方式来创建对象； 然而在Java EE编程中，类的数量开始变多，对象之间相互依赖开始变的复杂，Controller层的一个实例可能依赖了若干个Service层的实例，Service层实例可能又依赖了若干个Dao层实例，不同Service、Controller中可能依赖同一个对象； 这时，如果再通过手动的方式为每个类创建依赖的对象，则对象之间存在较高的耦合度，维护起来并不方便。于是Spring 通过IOC的方式，将对象生命周期以及依赖关系管理的控制权从编码人员手上移到了Spring手上。Spring可以提前创建好需要使用的对象，并将这些对象放到IOC容器中进行管理，当需要某个对象时，只需要通过@Autowried等方式来将对象注入。这样编码人员便不用关心类的创建以及依赖管理等细节，可以将精力放到实际的逻辑中，从而提高开发效率。 如何实现 IOC 那么Spring是如何通过一个@Autowried注解就可以实现依赖对象的注入呢？答案尽在反射技术。 Web容器在启动时会启动Spring容器，Spring容器在启动时会通过xml、或者注解扫描的方式来创建出各种Bean，这种在运行期间创建对象的方式正是反射。 详细将会在「再谈Spring」中见。 4、反射的优缺点4.1 优点 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 4.2 缺点尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 5、总结在JVM会在类加载阶段生成与类唯一的匹配的Class对象放到内存中，通过这个Class对象可以反映类的内部结构，如方法、变量、构造器等信息，通过Class对象的还可以动态地创建该类的实例，我们形象地将这种机制称为「反射」。如果想要通过「反射」来动态创建类的实例，就要先获取该类的Class对象，主要有三种方式获取： 类名.class 实例.getClass() Class.forName(“全限定类名”) 反射的应用场景比较广泛，在一些框架中被广泛适应，如Spring中实现控制反转的时就是利用反射来创建对象，并将对象放到容器中管理。 6、参考 尚硅谷Java基础-宋红康 深入理解Java虚拟机 CyC2018/CS-Notes Trail: The Reflection API","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://tobing.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"线程池的简单使用","slug":"线程池的简单使用","date":"2021-03-09T13:28:27.000Z","updated":"2021-03-09T14:03:03.875Z","comments":true,"path":"2021/03/09/线程池的简单使用/","link":"","permalink":"https://tobing.top/2021/03/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"线程作为一种稀缺资源，在线程较多的情况下，频繁创建、销毁消除将会带来较大的系统开销。线程池基于池化思想，内部维护多个线程，可以对内部的线程进行统一的管理和监控，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。","text":"线程作为一种稀缺资源，在线程较多的情况下，频繁创建、销毁消除将会带来较大的系统开销。线程池基于池化思想，内部维护多个线程，可以对内部的线程进行统一的管理和监控，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。 线程池1、线程池的优点上面我们提到，线程池是一种稀缺资源，频繁创建销毁线程会造成较大的系统开销，因此引入了线程池技术。 线程池技术主要具有以下优点： 降低资源消耗。通过重复利用已经创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度。当任务下达时，任务不需要等待线程创建就能直接执行。 提高线程可管理性。线程是稀缺资源，如果无限创建不仅会消耗系统资源，还会降低系统稳定性。使用线程池可以统一分配、调优和监控。 2、线程池架构设计线程池这么好，那么需要我们自己实现吗？可以但没有必要，因为Java中以及封装好了线程池的实现。 Java中，线程池是通过Executor框架来实现的，该框架主要用到：Executor、ExecutorService、ThreadPoolExecutor、Executors这几个类。 Executor 接口：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。 ExecutorService 接口：扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；提供了管控线程池的方法，比如停止线程池的运行。 AbstractExecutorService 抽象类：将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。 ThreadPoolExecutor 类：实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。 3、 线程池的简单使用Java中的Executors线程池工具类为我们提供了3种创建线程的方法： 12345678//执行一个长期的任务,性能好很多ExecutorService threadPool1 = Executors.newFixedThreadPool(5);// 一个任务一个线程执行的任务场景ExecutorService threadPool2 = Executors.newSingleThreadExecutor();// 适用于：执行很多短期异步的小程序或者负载较轻的服务器ExecutorService threadPool3 = Executors.newCachedThreadPool(); 尽管Executors为我们提供了3种创建线程池的方式，但是这几种创建方式并不适合在生产环境中使用： 阿里巴巴开发手册 要分析其存在的隐患，要先去了解Java中线程池的核心类：ThreadPoolExecutor 4、 ThreadPoolExecutor上面提到道，Executors方式创建的线程池在实践中容易导致OOM，为了解释清楚，我们先分析一下ThreadPoolExecutor。 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 上面展示了ThreadPoolExecutor的构造方法，接下来我们了解这个7大参数 corePoolSize：线程池常驻核心线程数 maximumPoolSize：线程池能够容纳同时执行的最大线程数 keepAliveTime：多余的空闲线程存活时间、当空闲时间达到keepAliveTime，多余线程会被销毁直到剩下corePoolSize unit：keepAliveTime单位 workQueue：任务队列，提交但未执行的任务。 threadFactory：线程池中工作线程的线程工厂，一般采用默认即可 handler：拒绝策略。当线程队列满并且工作线程大于线程池最大线程数，handler将指定任何拒绝新来的线程。 在使用ThreadPoolExecutor前，我们先通过图解方式讲解线程池底层执行的原理： 创建线程池后，等待提交过来的线程任务 在调用execut()方法添加一个任务请求，线程池会做如下判断： 如果正在运行的线程数量小于corePoolSize，则马上创建线程运行这个任务。 如果正在运行的线程数量大于corePoolSize，则在workQueue中等待。 如果workQueue队列已满，且正在运行的线程数量还小于maximumPoolSize，则创建非核心线程立即执行这个任务。 如果workQueue队列已满，且正在运行的线程数量大于或等于maximumPoolSize，则会使用拒绝策略执行拒绝。 当一个线程完成任务，会从workQueue中取出一个人任务执行。 当一个线程空闲时间超过keepAliveTime，线程池会判断： 如果当前运行的线程数大于corePoolSize，那么线程会被停用 5、拒绝策略上面提到当等待队列已满且线程池最大线程数也满的时候，无法继续为新任务提供服务，这时候，需要拒绝策略机制合理处理这个问题。 JDK中为我们提供了4种拒绝策略： AbortPolicy：默认策略，直接抛出异常阻止系统正常运行。 CallerRunPolicy：“调用者运行”机制，不会抛弃任务，也不会抛出异常，而是给调用线程池的线程执行。 DiscardOldestPolicy：抛弃队列中等待最久的。 DiscardPolicy：直接丢弃任务，不做任务响应。（如果允许任务丢失，将会是最好的拒绝策略）。 6、Executors风险分析上面我们已经简单介绍了ThreadPoolExecuto构造函数的各个参数，下面我们观察Executors中几种常见线程池的方式，进而分析其风险。 123456789101112131415161718192021// FixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;// SingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;// CacheThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 上面代码展示了Executors中创建创建线程池的逻辑，可以看到底层都是通过 ThreadPoolExecutor 来创建，这就是为什么要在分析前先了解一下它。 从上面提到的ThreadPoolExecutor 我看可以知道 对于FixedThreadPool 与 SingleThreadExecutor 都是使用 LinkedBlockingQueue 作为阻塞队列，这是一个无界第队列，当阻塞的任务过多的时候，将会导致内存占用太大，从而导致OOM。 对于CacheThreadPool ，最大线程数没有进行限制，当线程提交过多，将会导致线程池创建的线程太多，从而导致OOM。 7、自定义线程池从上面分析，我们知道Executors的方式创建线程池确实存在安全隐患，因此我们应该使用 ThreadPoolExecutor 来创建线程池，那么应该如何配置其参数呢？ 这需要我们区分不同类型的业务场景：CPU密集型和IO密集型。 CPU密集型CPU密集型指的是，任务需要大量的运算而没有阻塞（如IO阻塞），CPU一直在全力运算。 CPU密集型任务只有在正在的多核CPU上才能得到加锁。 可以通过Runtime.getRuntime().availableProcessors()拿到CPU核心数。 CPU密集型任务配置尽可能少的线程数量：线程数=CPU核数+1 IO密集型由于IO密集型，线程常常是在等待IO操作而阻塞，因此应该配置尽量多的线程。 线程数量=CPU核心数*2 8、参考 Java线程池实现原理及其在美团业务中的实践 Java并发编程的艺术","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"线程池","slug":"线程池","permalink":"https://tobing.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"双亲委派机制","slug":"双亲委派机制","date":"2021-03-06T01:55:58.000Z","updated":"2021-03-06T02:51:12.451Z","comments":true,"path":"2021/03/06/双亲委派机制/","link":"","permalink":"https://tobing.top/2021/03/06/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","excerpt":"JVM可以使用类加载器通过全限定类名的方式来加载一个类。类加载器在加载类的时候会使用一种称为「双亲委派」的机制来实现类的加载，本文将简要介绍双亲委派机制。","text":"JVM可以使用类加载器通过全限定类名的方式来加载一个类。类加载器在加载类的时候会使用一种称为「双亲委派」的机制来实现类的加载，本文将简要介绍双亲委派机制。 双亲委派机制类加载器是JVM执行类加载机制的前提，类加载器实现了「双亲委派」机制，介绍「双亲委派」机制前先简要介绍一下类加载器。 一、类加载器1.1 类加载器作用1Xxxx.class -----二进制流-----&gt; Class对象 ClassLoader是Java的核心组件，所有的Class都是ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制流数据读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响类加载，而无法通过ClassLoader区改变类的链接和初始化行为。至于是否可以运行，有Execution Engine决定。 类加载器最早出现在Java1.0中，那时候只是单纯为了满足Java Applet应用而被研发出来，但如今却在OSGi、字节码加解密中大放异彩。这主要归功于Java虚拟机的设计者当初在设计类加载的时候，并没有考虑将它绑定到JVM内部，这样做的好处是能够灵活和动态的执行类加载操作。 1.2 类加载方式的分类JVM可以通过显式加载与隐式加载将class文件加载到内存中 显式加载，通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。 隐式加载，通过Java虚拟机自动加载到内存中，如加载某个类时，该类中引用了另外一个类，此时则通过隐式加载。 1.3 类加载的基本机制类加载的时候有三个特征： 双亲委派模型。不是所有的类加载都遵循这个模型。有时候，启动类加载的类型可能要加载用户代码，如JDK内部的ServiceProvider、ServiceLoader机制，用户可用在标准的API框架上，提供自己的实现，如Java中的JNDI、JDBC、文件系统、Cipher等，都是利用该机制。这时不是采用双亲委派机制，而是上下文加载器。 可见性，子类加载器可用访问父加载器加载的类型，但反过来不行 。不然因为缺少不要的割裂就没办法利用类加载器去实现容器的逻辑。 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互不可见。 1.4 类加载器类型JVM把类加载器分为两类：引导类加载器（Bootstrap ClassLoader）和自定义加载器（User-Defined ClassLoader）。 不同的类加载器主机不是继承关系，而是包含关系，下层类加载器包含上层类加载器的引用。 启动类加载器 /引导类加载器 Bootstrap ClassLoader，使用C/C++实现，嵌套在JVM内部。 加载Java核心库：JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path，用于提供JVM自身需要的类。 并不继承与java.lang.ClassLoader，没有父加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java/javax/sun等开头的类。 引导类加载器可以加载扩展类加载器和应用程序类加载器，并为他们指定父类加载器。 扩展类加载器 Extension ClassLoader，Java编写，sun.misc.Launcher$ExtClassLoader实现。 Extension ClassLoader继承于ClassLoader，它的父类加载器为启动类加载器。 从java.ext.dirs系统属性指定的目录加载类库，或从jre/lib/ext子目录下加载类库。 如果用户将jar放到以上目录，将会自动被加载。 用户自定义类加载器 日常开发中都是使用上述三种类加载器交叉使用，但必要时我们也可以自定义类加载器。 Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是jar，也可以是网络的远程资源。 通过类加载器可以实现精美绝伦的插件机制。如著名的OSGI组件框架、Eclipse插件机制等。 类加载器为应用程序提供了一种动态添加新功能的机制，这种机制无需重新打包发布应用程序就能实现。 同时，自定义类加载器可以实现应用隔离，如 Tomcat、Spring等中间件和组件框架都在内部实现了自定义加载器，并且通过自定义加载器隔离不同的组件模块。 自定义类加载器通常继承与ClassLoader。 二、双亲委派机制上面在介绍类加载器时提到，类加载器实现类加载时，具有「双亲委派」的特征，下面正式聊聊双亲委派模型。 JDK1.2开始，类的加载过程采用双亲委派机制，这机制能够更好的保证Java平台安全。 2.1 定义一个类加载器在接收到类加载的请求的时候，首先不会自己尝试加载，而是先把这请求交给父类加载器去加载，依次递归。如果父类加载器可以完成类的加载任务，则成功返回；否则自己其加载。 双亲委派机制本质上是规定了类的加载顺序：引导类加载器 –&gt; 扩展类加载器 –&gt; 系统类加载器 –&gt; 自定义类加载器 2.2 代码实现双亲委派机制具体实现是在java.lang.ClassLoader.loadClass(String, boolean)中体现。逻辑如下： （1）当前类加载器缓存中查找该类，有则直接返回； （2）判断当前父类加载器是否为空，不为空，则调用parent.loadClass()进行加载；【双亲委派机制】 （3）如果父类加载器为空，则调用findBootstrapClassOrNull()接口，让引导类加载器加载；【双亲委派机制】 （4）如果以上三步都不成功，自己加载，调用findClass(name)。该接口最终调用ClassLoader的defineClass系列的native接口加载目标Java类。 Java 8 java.lang.ClassLoader.loadClass(String, boolean) 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) // loadClass throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 并发控制 // First, check if the class has already been loaded 检查类是否已经被定义 Class&lt;?&gt; c = findLoadedClass(name); // 判断该类是否已经加载 if (c == null) &#123; // 尚未加载 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 判断是否具有父加载器 c = parent.loadClass(name, false); // 先调用父加载器加载【双亲委派机制】 &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 如果父加载器没找到，从当前类加载器中查找 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 2.3 实践Java虚拟机规范没有明确要求类加载器的加载机制一定要采用双亲委派机制，只是建议使用。 在Tomcat中，类加载器采用的加载机制和双亲委派机制有一定区别，当缺省的类加载器收到一个加载任务的时候，首先会自行加载，当加载失败，才会将类加载委派给父类加载器，同时也是Servlet规范推荐的做法。 2.4 破坏双亲委派机制双亲委派机制不是一个具有强制性的模型，而是Java设计者推荐使用的类加载方式。 在JDK9之前，出现过三次破坏双亲委派机制的情况。 （1）JDK1.2前 ClassLoader诞生于JDK1.0，但是双亲委派机制是JDK1.2才引入。因此JDK1.2 之前的自定义实现的用户自定义类加载器是不具有双亲委派机制的。同时，为了对已有代码的兼容，JDK1.2在对具体类加载器实现时，将类字节码文件的加载以及字节码文件转换为Class文件分离，分别是loadClass与defineClass方法。推荐使用重写defineClass来避免破坏双亲委派机制。 （2）线程上下文 双亲委派模式自身存在缺陷，即上级加载器无法使用下级加载器的类。而实际引用中存在上级定义规范，下级实现的情况，如JDBC。JDBC是Java定义的规范接口，需要实际的数据库厂商根据自身特点来实现，而JDBC接口是Java核心类库定义的，应该属于引导类加载器管理；而数据库厂商实现的自然是应用程序类加载器，此时如果依旧采用纯双亲委派机制就无法实现JDBC的需求。 为了解决这个困境，Java设计团队引入了线程上下文类加载器。线程上下文类加载器运行父类加载器去请求子类加载器完成类的加载的行为。这便破坏了双亲委派机制。 图：线程上下文加载器 （3）热代码替换 这一次破坏源于用户对程序动态性的追求，Hot Swap，Hot Deployment等。 IBM主导的JSR-291实现的模块热部署采用了自定义类加载器，该自定义加载器不再使用双亲委派模型推荐的树形结构，而是采用的复杂的网状结构。 注意 “被破坏”不意味着就是贬义，只要理由充分，突破旧的原则无疑就是一种创新。 三、总结JVM通过ClassLoader实现类的加载。ClassLoader在加载时会遵循双亲委派机制，即在实现类加载时递归请求委派父类加载器区加载，直到顶层父类无法加载，才会返回让当前类机制器实现加载。这种方式既可以避免类的重复加载，确保类的全局唯一，又可以保证程序安全，防止核心API被褚篡改。 同时双亲委派模型不是一个强制性模型，JDK9 前，历史上出现了3次破坏双亲委派模型的情况： JDK1.2前：双亲委派机制是JDK1.2才引入，之前自定义的不具有双亲委派机制。 线程上下文：双亲委派机制本身具有缺陷，即上级加载器无法使用下级加载器的类，而实际中又存在这种场景，如：JDBC。 热代码替换【了解】。 四、参考 JVM-宋红康 深入理解Java虚拟机","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://tobing.top/tags/JVM/"}]},{"title":"排序算法-快速排序","slug":"排序算法-快速排序","date":"2021-02-27T01:56:31.000Z","updated":"2021-02-27T02:22:33.154Z","comments":true,"path":"2021/02/27/排序算法-快速排序/","link":"","permalink":"https://tobing.top/2021/02/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"快速排序是一种高级排序算法，虽然他的最优时间复杂度是O(nlogn)，但是其前面的常数比其他高级排序算法要小，因此比其他高级算法要快很多。","text":"快速排序是一种高级排序算法，虽然他的最优时间复杂度是O(nlogn)，但是其前面的常数比其他高级排序算法要小，因此比其他高级算法要快很多。 快速排序快速排序，Quicksort，又称分区交换排序（partition-exchange sort），简称快排，最早由东尼·霍尔提出。 快速排序通常明显比其他算法块，因为它的内部循环可以在大部分的架构上很有效率地达成。 快速排序算法执行流程： 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。 选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。 示意图 使用快速排序法对一列数字进行排序的过程 简单快排基本交换 简单快排最后交换 复杂度 复杂度 值 平均时间复杂度 O(nlogn) 最坏时间复杂度 O(n^2) 最优时间复杂度 O(nlogn) 空间复杂度 根据实现的方式不同而不同 稳定性 不稳定 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class QuickSort &#123; public static void sort(Comparable[] arr) &#123; sort(arr, 0, arr.length - 1); &#125; /** * 递归对 arr[left...right] 排序 * * @param arr 数组 * @param left 左边界 * @param right 右边界 */ private static void sort(Comparable[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int p = partition(arr, left, right); // 【&lt; segment，segment，&gt; segment】 sort(arr, left, p - 1); // 处理【&lt; segment】部分 sort(arr, p + 1, right); // 处理【&gt; segment】部分 &#125; /** * 对 arr[left...right] 进行 partition * * @param arr 数组 * @param left 左边界 * @param right 右边界 */ private static int partition(Comparable[] arr, int left, int right) &#123; // 选基准：此处每次选择最左边的元素 Comparable base = arr[left]; // arr[left+1...segment] &lt; base ；arr[segment+1...i) &gt; base int segment = left; // j 是小于基值和大于基值的分界点 for (int i = left + 1; i &lt;= right; i++) &#123; // arr ==&gt; 【segment，&lt; segment，&gt; segment】 // 对于比基准值小的值，放在segment所在的位置，segment索引递增 if (arr[i].compareTo(base) &lt; 0) &#123; segment++; Comparable temp = arr[i]; arr[i] = arr[segment]; arr[segment] = temp; &#125; &#125; // 结束之后，将 base 放到 segment 位置 // 【segment，&lt; segment，&gt; segment】 ==&gt; 【&lt; segment，segment，&gt; segment】 Comparable temp = arr[segment]; arr[segment] = arr[left]; arr[left] = temp; // 返回基准值所在的索引 return segment; &#125;&#125; 总结快排是东尼·霍尔提出的一种高级排序算法，主要流程有：选基准、分割、递归排序子序列三个过程。快速排序的平均和最优时间复杂度是O(nlogn)，最坏时间复杂度可达O(n^2)，是一种不稳定的排序算法。Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序。 参考 快速排序-维基百科 慕课网-玩转算法面试","categories":[],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://tobing.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tobing.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"排序算法-归并排序","slug":"排序算法-归并排序","date":"2021-02-27T01:33:25.000Z","updated":"2021-02-27T02:18:29.962Z","comments":true,"path":"2021/02/27/排序算法-归并排序/","link":"","permalink":"https://tobing.top/2021/02/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"归并排序是一种高级排序算法，本文介绍了归并排序的 Java 实现。","text":"归并排序是一种高级排序算法，本文介绍了归并排序的 Java 实现。 归并排序归并算法，Merge Sort，是建立在归并操作上的一种有效的排序算，时间复杂度为 O(nlogn)。 1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 归并算法执行流程： 分割：递归地把当前序列平均分割成两半。 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。 示意图 使用合并排序为一列数字进行排序的过程 使用合并排序为一列数字进行排序的过程 复杂度 复杂度 值 平均时间复杂度 O(nlogn) 最坏时间复杂度 O(nlogn) 最优时间复杂度 O(nlogn) 空间复杂度 O(n) 稳定性 稳定 Java 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MergeSort &#123; /** * 对 arr进行排序 * * @param arr arr */ public static void sort(Comparable[] arr) &#123; sort(arr, 0, arr.length - 1); &#125; /** * 为 arr[left...right] 的元素排序 * * @param arr arr * @param left 左边界 * @param right 右边界 */ private static void sort(Comparable[] arr, int left, int right) &#123; // 如果只剩下一个元素，直接返回 if (left &gt;= right) &#123; return; &#125; // 计算中点 int mid = (left + right) &gt;&gt;&gt; 1; // 相当于(left+right)/2 位运算要比除法效率高 sort(arr, left, mid); sort(arr, mid + 1, right); merge(arr, left, mid, right); &#125; /** * 将 arr[left...mid] 与 arr[mid+1...right] 两个子数组归并操作 * * @param arr arr * @param left 左边界 * @param mid 中心 * @param right 右边界 */ private static void merge(Comparable[] arr, int left, int mid, int right) &#123; // 对子数组进行拷贝，便于比较归并 Comparable[] temp = Arrays.copyOfRange(arr, left, right + 1); int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; // 左边子数组归并完毕 if (i &gt; mid) &#123; arr[k] = temp[j - left]; j++; &#125; // 右边子数组归并完毕 else if (j &gt; right) &#123; arr[k] = temp[i - left]; i++; &#125; // 左边子数组所指元素 &gt; 右边子数组所指元素 else if (temp[i - left].compareTo(temp[j - left]) &gt; 0) &#123; arr[k] = temp[j - left]; j++; &#125; // 否则 else &#123; arr[k] = temp[i - left]; i++; &#125; &#125; &#125;&#125; 总结归并排序是由冯·诺依曼提出的一种高级排序算法，主要流程有：分割、集成两个过程。归并排序的平均、最坏、最好时间复杂度都是O(nlogn)，是一种稳定的排序算法。Java 主要排序方法为 java.util.Arrays.sort()，对于引用数据类型使用归并排序。 参考 归并排序-维基百科 慕课网-玩转算法面试","categories":[],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://tobing.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","permalink":"https://tobing.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"Github骚操作","slug":"Github骚操作","date":"2020-11-16T04:17:18.000Z","updated":"2021-01-15T03:31:33.607Z","comments":true,"path":"2020/11/16/Github骚操作/","link":"","permalink":"https://tobing.top/2020/11/16/Github%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"GitHub作为一个基于git的代码托管平台，具有全球海量的用户，其中也包含了很多价值极高的开源项目，接下来接受一下GitHub骚操作。","text":"GitHub作为一个基于git的代码托管平台，具有全球海量的用户，其中也包含了很多价值极高的开源项目，接下来接受一下GitHub骚操作。 Github骚操作1. 搜索范围搜索1234keyword in:name # 根据项目名搜索keyword in:description # 根据描述搜索keyword in:readme # 根据readme搜索keyword in:name,description # 混合搜索 根据stars、froks搜索1234keyword stars:&gt;5000 # 搜索stars数&gt;5000keyword forks:&gt;1000 # 搜索forks数&gt;1000keyword stars:500..1000 # 搜索stars数在[500,1000]之间keyword forks:&gt;1000 stars:&gt;5000 # 组合 2. 学习教程1awesome java # 精品推荐 项目内搜索代码1项目网页上直接输入：T 读代码1234567url后紧跟#L12 ## 指定行号为12url后紧跟#L12-L20 ## 指定行号范围12-20# 查看GroovyScriptController.java第13行代码https://github.com/...../springboot/web/GroovyScriptController.java#L13 # 查看GroovyScriptController.java第13行-20行https://github.com/...../springboot/web/GroovyScriptController.java#L13-L20 关注大佬12location:beijing # 寻找北京的用户language:java # 寻找使用java的用户","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://tobing.top/tags/GitHub/"}]},{"title":"MySQL进阶-2-索引优化分析","slug":"MySQL进阶-2-索引优化分析","date":"2020-08-22T04:22:56.000Z","updated":"2021-01-15T04:12:11.148Z","comments":true,"path":"2020/08/22/MySQL进阶-2-索引优化分析/","link":"","permalink":"https://tobing.top/2020/08/22/MySQL%E8%BF%9B%E9%98%B6-2-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/","excerpt":"MySQL进阶第二弹。","text":"MySQL进阶第二弹。 MySQL进阶-2-索引优化分析1. 导致SQL慢的原因 查询语句写的烂 （单值、复合）索引实现 关联查询太多join 服务器调优以及各参数的设置 2. 常见通用的join查询2.1 SQL执行顺序 SQL通用编写语法 123456789101112131415161718192021select distinct &lt;select_list&gt;from &lt;left_table&gt; &lt;join type&gt;join &lt;right_table&gt; on &lt;join_condition&gt;where &lt;where_condition&gt;group by &lt;group_by_list&gt;having &lt;having_condition&gt;order by &lt;order_by_condition&gt;limint &lt;limint_number&gt; 机器读取顺序 123456789from &lt;left_table&gt;on &lt;join_condition&gt;where &lt;where_condition&gt;group by &lt;group_by_list&gt;having &lt;having_condition&gt;selectdistinct &lt;select_list&gt;order by &lt;order_by_condition&gt;limint &lt;limint_number&gt; 2.2 7种Join2.2.1 示意图 2.2.2 示例 建表 1234567891011121314151617181920212223242526272829303132333435363738394041-- 创建数据库CREATE DATABASE mysq;USE mysq;-- 创建部门表CREATE TABLE `t_dept`( `id`INT(11) NOT NULL AUTO_INCREMENT, `deptName`VARCHAR(30)DEFAULT NULL, `address`VARCHAR(40)DEFAULT NULL, PRIMARY KEY(`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; -- 创建员工表CREATE TABLE `t_emp`( `id`INT(11)NOT NULL AUTO_INCREMENT, `name`VARCHAR(20)DEFAULT NULL, `age`INT(3)DEFAULT NULL, `deptId`INT(11)DEFAULT NULL, empno INT NOT NULL, PRIMARY KEY(`id`), KEY`idx_dept_id`(`deptId`) #CONSTRAINT`fk_dept_id`FOREIGNKEY(`deptId`)REFERENCES`t_dept`(`id`) )ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; -- 插入数据INSERT INTO t_dept(deptName,address)VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);INSERT INTO t_dept(deptName,address)VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;); INSERT INTO t_dept(deptName,address)VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;); INSERT INTO t_dept(deptName,address)VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;); INSERT INTO t_dept(deptName,address)VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;); INSERT INTO t_dept(deptName,address)VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;风清扬&#x27;,90,1,100001);INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;岳不群&#x27;,50,1,100002); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;令狐冲&#x27;,24,1,100003); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;洪七公&#x27;,70,2,100004); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;乔峰&#x27;,35,2,100005); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;灭绝师太&#x27;,70,3,100006); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;周芷若&#x27;,20,3,100007); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;张三丰&#x27;,100,4,100008); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;张无忌&#x27;,25,5,100009); INSERT INTO t_emp(NAME,age,deptId,empno)VALUES(&#x27;韦小宝&#x27;,18,NULL,100010); 测试案例 123456789101112131415161718192021222324-- 【交集】所有有门派人员的信息（要求显示门派名称）SELECT e.`name`,d.`deptName` FROM t_emp e INNER JOIN t_dept d ON e.`deptId` = d.`id`;-- 【全A】列出所有人员及其门派信息SELECT e.`name`, d.`deptName` FROM t_emp e LEFT JOIN t_dept d ON e.`deptId` = d.`id`;-- 【全B】列出所有门派SELECT * FROM t_dept;-- 【A特】所有无门派人士SELECT * FROM t_emp WHERE deptId IS NULL;-- 【B特】所有无人门派SELECT e.`name`,d.`deptName` FROM t_emp e RIGHT JOIN t_dept d ON e.`deptId` = d.`id` WHERE e.`name` IS NULL;-- 【全部】所有人员和门派的对应关系SELECT e.`name`,d.`deptName` FROM t_emp e LEFT JOIN t_dept d ON e.`deptId` = d.`id`UNIONSELECT e.`name`,d.`deptName` FROM t_emp e RIGHT JOIN t_dept d ON e.`deptId` = d.`id`-- 【A特和B特】所有没有入门派的人员和没人入的门派SELECT e.`name`,d.`deptName` FROM t_emp e LEFT JOIN t_dept d ON e.`deptId` = d.`id` WHERE d.`deptName` IS NULLUNIONSELECT e.`name`,d.`deptName` FROM t_emp e RIGHT JOIN t_dept d ON e.`deptId` = d.`id` WHERE e.`name` IS NULL 3. 索引简介3.1 是什么​ 索引（index）是帮助MySQL实现高效获取数据的数据结构。 ​ 我们可以简单理解为：排好序的快速查找数据结构。数据库系统维护着满足特定查找算法的数据结构，这些数据结构一某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这便是索引。 ​ 上图中，为了加快Col2的查找，可以维护右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样既可以运用二叉查找树在一定复杂度内获取相应数据，从而快速索引出符合条件的记录。 ​ 一般来说，索引本身很大，不可能全部存储到内存中，因此索引往往以文件的形式保存在硬盘中。平时我们提到的索引，如果没有特别说明都是指的是B树（多路搜索树，并不一定是二叉树）结构组织的索引。其中聚集索引、次要索引、覆盖索引、符合索引、前缀索引、唯一索引都是使用B+树索引，统称索引。处理B+树索引还有哈希索引等。 3.2 索引优势​ 类似大学图书馆建立书目索引，索引可以提高数据检索效率，降低数据库IO成本。通过建立索引还会对数据进行排序，降低数据排序成本，减少CPU的消耗。 3.3 索引劣势​ 索引实际上是一张表，保存了主键和索引字段，并指向实体表的记录，所以需要占用一定空间。 ​ 索引虽然提高了查询速度，但是会降低更新表的速度，如果对表进行insert、update和delete，MySQL不仅要存数据，还要保存胰腺癌丝印文件每次更新添加了索引列的字段，都会调整因为更新而带来的键值变化后的索引信息。 ​ 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就要花时间在研究优秀的索引，或者优化查询语句。 3.4 索引分类​ 索引又分为：单值索引、唯一索引、复合索引等。 单值索引：一个索引只包含单个列、一个表可以有多个单列索引。 唯一索引：索引的值必须唯一，但允许有空值。 符合索引：一个索引包含多个列。 3.5 索引使用 创建索引 12345-- 方式1create [unique] index indexName on mytable(collumname(length))-- 方式2alter mytable add [unique] index [indexname] on (columname(lenght)) 删除 1drop index [indexName] on mytable 查看索引 1show index from table_name 添加 1234567891011-- 添加逐渐、意味着索引值必须唯一，且不能为nullalter table tb_name add primary key (column_list)-- 创建索引值必须唯一（Null可以出现多次）alter table tb_name add unique index_name (column_list)-- 添加普通索引，索引值可能出现多次alter table tb_name add index indx_name(column_list)-- 指定索引为FullText、用于全文索引alter table tb_name add fulltext index_name(column_list) 3.6 索引结构 BTree索引 ​ BTree索引（Balanced Tree），是一种很普遍的数据库索引结构，是oracle默认的索引结构类型。其特点是定位高效、利用率高、自我平衡，特别适用于高基数字段，定位单条或小范围数据非常高效。理论上，适用BTree在亿条数据与100条数据中定位记录花销相同。BTree索引的数据结构如下图： ​ BTree索引的主要特点： 树形结构：有根节点（root）、分支（branches）、叶（leaves）三级节点组成，其中分支节点可以有多层。 多分支结构：与binary tree 不同，BTree索引中一个root、branch可以有多个子节点（超过2个）。 双向链表：整个叶子节点部分是一个双向链表 Hash索引【了解】 Full-Text索引【了解】 R-Tree索引【了解】 3.7 创建索引的场景 主键自动创建索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外加关系建立索引 查询中排序的字段时候创建索引，排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 3.8 不创建索引的场景 表记录太少（没必要） 经常增删改的表 数据重复且分布平均的表字段 where条件用不到的字段 4. 索引性能分析4.1 MySQL Query Optimizer MySQL中专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他任务最优的计划 客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer是，MySQL Query Optimizer会将整条Query进行优化，处理掉一些常量表达式的预算，直接换成常量值，并对Query中的查询条件进行简化和转换如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息，看现实Hint信息是否可以完全确定Query的执行计划。如果没Hint或Hint还不足以完全确定该Query的执行计划，则会读取涉及对象的统计信息，根据Query进行写相应计算分析，然后在得出最后的执行计划。 4.2 MySQl常见瓶颈 CPU：CPU饱和一般发生在数据装入内存或从磁盘上读取数据 IO：磁盘I/O瓶颈发生在装入数据远大于内存容量 服务器硬件：top、free、iostat和vmstat等查看系统性能状态 4.3 Explain 定义 ​ 可以使用Explain来模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句，进而分析查询语句或者结构性能瓶颈。 用处 ​ 查看表的读取顺序、数据读取操作的操作类型、那些索引可用、那些索引被实际使用，表之间的引用，每张表有多少行被优化器执行。 用法 1explain sql语句 返回信息 123456+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 6 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 4.4 Explain 字段详情 id ​ id是SELECT查询的序列号，包含一组数字，表示查询中执行SELECT子句或者操作表的顺序。通常包含3中情况： 【1】id相同，执行顺序由上而下 【2】id不同，如果是子查询，id序号会递增，id值越大，优先级越高，越先执行。 【3】id相同和不同并存 select_type ​ select_type，查询类型，主要用于区别普通查询、联合查询、子查询等复杂查询，一共有6种，包含了： SIMPLE：简单SELECT查询，查询中不包含子查询或者union PRIMARY：查询中若包含了任何复杂的子部分，最外层查询则会被标记为Primary SUBQUERY：在SELECT或者WHERE列表中包含了子查询 DERIVED：在FROM列表中包含的子查询会被标注为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表 UNION：若第二个SELECT出现union之后，则会被标记为union；若union包含在from的子查询中，外层SELECT将被标记为DERIVED。 UNION RESULT：从union表活动结果的SELECT table ​ 显示一行的数据是关于哪张表的 type ​ type显示的是访问类型，是较为重要的一项指标，，结果值从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 我们一般只需要记得：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说保证达到range、最好到ref。 类型 说明 system 表中只有一行，是const类型特例，平时不会出现，可以忽略不计。 const 表示通过索引一次就能找到，用于比较primary key或unique索引。因为只匹配一行，所以很快。 eq_ref 唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引。 ref 非唯一索引，返回匹配某个单独值的所有行。本质上也是索引访问，他返回所有匹配单个值的行，然而可以会有多个符合条件的行。 range 检索给定范围，使用一个索引选择行。一般where中出现between、&gt;、&lt;、in等。 index Full Index Scan，与ALL区别是index类型只遍历索引数。索引文件比数据文件小，读取比ALL快。 all Full Table Scan，将遍历全表以找到匹配的行。 possible_keys ​ 显示可能应用到这张表的索引，一个或者多个；查询涉及的字段若存在索引，则该索引将会被列出，但不一定被查询实际使用。 key ​ 实际使用的索引。如果为null，则没有使用索引。查询中若使用了覆盖索引，则索引和查询的SELECT字段你重叠。 key_len ​ 表示索引中使用的字节数，可以通过计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好；key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 ref ​ 显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值。 rows ​ 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 Extra ​ 包含不适合在其他列中显示但十分重要的额外信息. 4.5 Explain测试 阐述下图的执行顺序 执行顺序 ​ 【1】第四行（selec name，id from t2），select_type为union、说明第三个select是union里面的第二个select。 ​ 【2】第二行（selec id，name from t1 wehre ohter_column = ‘ ’），查询包含在from，因此是衍生表DERIVED。 ​ 【3】第三行（select id from t3)，违章查询，说为整个查询的第二个select。 ​ 【4】第一行（select d1.name ….），表示union里面的第一个select，select_type为primary 表示该查询为外层查询，table列被标记为derived3说明查询结果来着一个衍生表，3表示衍生来自第三个查询。 ​ 【5】第五行（…union…）代表从union的临时表中读取行的阶段，table列的union1,4代表用第一个好第四个select结果进行union。 5. 索引优化5.0 数据准备 建表语句 123456789101112131415161718192021CREATE DATABASE sqlplus;USE sqlplus;-- 创建部门表CREATE TABLE`dept`( `id`INT(11)NOT NULL AUTO_INCREMENT, `deptName`VARCHAR(30)DEFAULT NULL, `address`VARCHAR(40)DEFAULT NULL, ceo INT NULL, PRIMARY KEY(`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 创建员工表CREATE TABLE`emp`( `id`INT(11)NOT NULL AUTO_INCREMENT, `empno`INT NOT NULL, `name`VARCHAR(20)DEFAULT NULL, `age`INT(3)DEFAULT NULL, `deptId`INT(11)DEFAULT NULL, PRIMARY KEY(`id`) #CONSTRAINT`fk_dept_id`FOREIGNKEY(`deptId`)REFERENCES`t_dept`(`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 设置参数 123-- 设置参数SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;SET GLOBAL log_bin_trust_function_creators = 1; 编写函数用于生产随机字符串 12345678910111213-- 产生随机字符串DELIMITER $$CREATE FUNCTION rand_string(n INT)RETURNS VARCHAR(255)BEGINDECLARE chars_str VARCHAR(100)DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;DECLARE return_str VARCHAR(255)DEFAULT&#x27; &#x27;;DECLARE i INT DEFAULT 0;WHILE i &lt; n DOSET return_str=CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));SET i=i+1;END WHILE;RETURN return_str;END $$ 随机生产部门编号 12345678-- 随机产生部门编号DELIMITER $$CREATE FUNCTION rand_num(from_num INT,to_num INT)RETURNS INT(11)BEGIN DECLARE i INT DEFAULT 0; SET i=FLOOR(from_num+RAND()*(to_num-from_num+1)) ;RETURN i;END $$ 编写存储过程用于给emp表插入数据 12345678910111213141516DELIMITER $$CREATE PROCEDURE insert_emp( START INT, max_num INT)BEGINDECLARE i INT DEFAULT 0;-- setautocommit=0 把 autocommit 设置成 0SET autocommit = 0;REPEATSET i=i+1;INSERT INTO emp (empno, NAME ,age ,deptid ) VALUES ((START+i) ,rand_string(6) , rand_num(30,50),rand_num(1,10000));UNTIL i=max_numEND REPEAT;COMMIT;END $$-- 删除 -- DELIMITER; -- dropPROCEDUREinsert_emp; 编写存储过程用于给dept表插入数据 1234567891011121314-- 执行存储过程，往 dept 表添加随机数据DELIMITER $$CREATE PROCEDURE`insert_dept`( max_num INT)BEGIN DECLARE i INT DEFAULT 0;SET autocommit=0;REPEAT SET i=i+1;INSERT INTO dept(deptname,address,ceo)VALUES(rand_string(8),rand_string(10),rand_num(1,500000));UNTIL i=max_numEND REPEAT;COMMIT;END $$-- 删除-- DELIMITER;-- dropPROCEDUREinsert_dept; 调用存储过程，插入数据 1234567-- 执行存储过程，往 dept 表添加 1 万条数据DELIMITER ;CALL insert_dept(10000);-- 执行存储过程，往 emp 表添加 50 万条数据 DELIMITER; CALL insert_emp(100000,500000); 5.1 常见单表索引失效 全值匹配我最爱 语句 123456789-- 创建复合索引CREATE INDEX idx_emp_agedeptIdname ON emp(age, deptId, NAME);-- 全值索引我最爱EXPLAIN SELECT * FROM emp WHERE emp.age = 30;EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4;EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;-- 顺序调换也不要紧，执行前优化器会自动优化EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND emp.name = &#x27;abcd&#x27; AND deptId = 4; 结果 12345678910111213141516171819202122232425262728293031mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age &#x3D; 30 AND deptId &#x3D; 4 AND emp.name &#x3D; &#39;abcd&#39;;+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age &#x3D; 30;+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname | idx_emp_agedeptIdname | 5 | const | 47832 | 100.00 | NULL |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age &#x3D; 30 AND deptId &#x3D; 4;+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname | idx_emp_agedeptIdname | 10 | const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age &#x3D; 30 AND deptId &#x3D; 4 AND emp.name &#x3D; &#39;abcd&#39;;+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+1 row in set, 1 warning (0.00 sec) 全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到！ SQL 中查询字段的顺序，跟使用索引中字段的顺序，没有关系。优化器会在不影响 SQL 执行结果的前提下，给 你自动地优化。 最佳左前缀法则 语句 1234-- 最佳左前缀法则EXPLAIN SELECT * FROM emp WHERE deptId = 4;EXPLAIN SELECT * FROM emp WHERE emp.name = &#x27;abcd&#x27; AND deptId = 4;EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND emp.name = &#x27;abcd&#x27;; 结果 1234567891011121314151617181920212223mysql&gt; EXPLAIN SELECT * FROM emp WHERE deptId = 4;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 499070 | 10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name = &#x27;abcd&#x27; AND deptId = 4;+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_name | idx_emp_name | 63 | const | 1 | 10.00 | Using where |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_name | 63 | const | 1 | 9.58 | Using where |+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 查询字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效 使用复合索引，需要遵循最佳左前缀法则，即如果索引了多列，要遵守最左前缀法则。指的是查询从索 引的最左前列开始并且不跳过索引中的列。 不在索引列做任何操作 语句 12345678-- 不要再索引列上做任何计算-- 不要使用函数EXPLAIN SELECT * FROM emp WHERE emp.age = 30;EXPLAIN SELECT * FROM emp WHERE LEFT(age,3)= 30;-- 不要使用转换CREATE INDEX idx_emp_name ON emp(NAME);EXPLAIN SELECT * FROM emp WHERE emp.name = &#x27;30000&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.name = 30000; 结果 123456789101112131415161718192021222324252627282930mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30;+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname | idx_emp_agedeptIdname | 5 | const | 47832 | 100.00 | NULL |+----+-------------+-------+------------+------+-----------------------+-----------------------+---------+-------+-------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE LEFT(age,3)= 30;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 499070 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name = &#x27;30000&#x27;;+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_name | idx_emp_name | 63 | const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name = 30000;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_emp_name | NULL | NULL | NULL | 499070 | 10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 3 warnings (0.00 sec) 不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换） ，会导致索引失效而转向全表扫描。 字符串不加单引号，则会在 name 列上做一次转换！ 存储引擎不能使用索引中范围条件右边的列 语句 123-- 索引列上不能有范围查询EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId &gt; 4 AND emp.name = &#x27;abcd&#x27;; 结果 123456789101112131415mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId &gt; 4 AND emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_name | 63 | const | 1 | 9.57 | Using where |+----+-------------+-------+------------+------+------------------------------------+--------------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 范围之后的索引全部失效 将可能做范围查询的字段的索引顺序放在最后 尽量使用覆盖索引，减少select * 语句 123-- 尽量使用索引覆盖EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;EXPLAIN SELECT age,deptId,NAME FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;; 结果 123456789101112131415mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT age,deptId,NAME FROM emp WHERE emp.age = 30 AND deptId = 4 AND emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname | 73 | const,const,const | 1 | 100.00 | Using index |+----+-------------+-------+------------+------+------------------------------------+-----------------------+---------+-------------------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) mysql在使用不等于是无法使用索引 语句 123-- 不要使用不等于EXPLAIN SELECT * FROM emp WHERE emp.name != &#x27;30000&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.name &lt;&gt; &#x27;30000&#x27;; 结果 123456789101112131415mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name != &#x27;30000&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_emp_name | NULL | NULL | NULL | 499070 | 50.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name &lt;&gt; &#x27;30000&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_emp_name | NULL | NULL | NULL | 499070 | 50.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec) mysql 在使用不等于(!= 或者&lt;&gt;)时，有时会无法使用索引会导致全表扫描。 is null、is not null也无法使用索引 语句 123-- 不要使用is not null、is nullEXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; 结果 123456789101112131415mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+| 1 | SIMPLE | emp | NULL | ref | idx_emp_name | idx_emp_name | 63 | const | 1 | 100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_emp_name | NULL | NULL | NULL | 499070 | 50.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec) like以通配符开头也不能使用索引 语句 1234-- like匹配EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;%30000&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;%30000%&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;30000%&#x27;; 结果 1234567891011121314151617181920212223mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;%30000&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 499070 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;%30000%&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 499070 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#x27;30000%&#x27;;+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | emp | NULL | range | idx_emp_name | idx_emp_name | 63 | NULL | 1 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec) 前缀不能出现模糊匹配！ 少用or，用它链接是会索引失效 语句 123-- 减少使用orEXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 OR emp.name = &#x27;abcd&#x27;;EXPLAIN SELECT * FROM emp WHERE emp.age = 30 OR deptId = 4; 结果 123456789101112131415mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 AND deptId = 4 OR emp.name = &#x27;abcd&#x27;;+----+-------------+-------+------------+-------------+------------------------------------+------------------------------------+---------+------+------+----------+-------------------------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------------+------------------------------------+------------------------------------+---------+------+------+----------+-------------------------------------------------------------------+| 1 | SIMPLE | emp | NULL | index_merge | idx_emp_agedeptIdname,idx_emp_name | idx_emp_agedeptIdname,idx_emp_name | 10,63 | NULL | 2 | 100.00 | Using sort_union(idx_emp_agedeptIdname,idx_emp_name); Using where |+----+-------------+-------+------------+-------------+------------------------------------+------------------------------------+---------+------+------+----------+-------------------------------------------------------------------+1 row in set, 1 warning (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM emp WHERE emp.age = 30 OR deptId = 4;+----+-------------+-------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_emp_agedeptIdname | NULL | NULL | NULL | 499070 | 14.50 | Using where |+----+-------------+-------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+1 row in set, 1 warning (0.00 sec) 使用 unionall 或者 union 来替代： 口诀 123456全职匹配我最爱，最左前缀要遵守；带头大哥不能死，中间兄弟不能断；索引列上少计算，范围之后全失效；LIKE百分写最右，覆盖索引不写*； 不等空值还有OR，索引影响要注意； VAR引号不可丢，SQL优化有诀窍。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"MySQL进阶-1-架构介绍","slug":"MySQL进阶-1-架构介绍","date":"2020-08-09T15:44:18.000Z","updated":"2021-01-15T04:12:39.084Z","comments":true,"path":"2020/08/09/MySQL进阶-1-架构介绍/","link":"","permalink":"https://tobing.top/2020/08/09/MySQL%E8%BF%9B%E9%98%B6-1-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/","excerpt":"MySQL进阶学习笔记。","text":"MySQL进阶学习笔记。 MySQL进阶-1-架构介绍1. MySQL简介1.1 概述 MySQL是一个关系型数据库管理系统（RDBMS），由瑞典MySQL AB 公司开放，目前属于ORACLE公司。 MySQL是一种关系数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样增加了速度并提高了灵活性。 MySQL是开源的，所以不需要支付额外的费用。 MySQL支持大型的数据库，可以出来拥有成千上万条记录的大型数据库。32位系统表文件最大支持4GB、64位系统最大表文件支持8TB。 MySQL使用标准的SQL数据语言形式。 MySQL可以运行于多个系统，并支持多语言。包括：C、C++、Java、Python、Perl、PHP、Ruby等等。 MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的系统。 1.2 MySQL进阶 内核 SQL优化 服务器的优化 查询语句优化 主从复制 软硬件升级 容灾备份 SQL编程 2. Linux下MySQL使用2.1 MySQL5.5安装 下载地址：https://dev.mysql.com/downloads/mysql/ 检查是否安装过MySQL 安装MySQL客户端、服务器端 1234# 安装服务器端rpm -ivh --nodeps MySQL-server-5.5.54-1.linux2.6.x86_64.rpm# 安装客户端rpm -ivh --nodeps MySQL-client-5.5.54-1.linux2.6.x86_64.rpm 启动MySQL服务 1service mysql start 设置root密码 1sqladmin -u root password 123456 设置MySQL自启动 1234# 设置自启动chkconfig mysql on# 检验是否设置成功ntsysv 修改配置文件位置 1cp /usr/share/mysql/my-huge.cnf /etc/my.cnf 将share下单my-huge.cnf配置文件复制到etc目录下，并且注意文件名。 不同版本的配置文件名可能不一样，如5.6的为my-defalut.cnf 设置字符集编码 1234567891011121314151617181920# 查看字符集 [默认客户端和服务端动用了Latin1，使用中文会乱码]show variales like &#x27;%char%&#x27;# 修改配置文件vim /etc/my.cnf# 添加下面内容[client]default-character-set=utf8 # 设置编码[mysqld]lower_case_table_names=1 # 设置大小写区分情况character_set_server=utf8character_set_client=utf8collation-server=utf8_general_cimax_connections=1000 # 设置最大连接数[mysql]default-character-set=utf8 MySQL一些目录 linux下查看 1ps -ef | grep mysql 路径 解析 备注 /var/lib/mysql mysql数据库文件的存放路径 /var/lib/mysql/xxx.pid /usr/share/mysql 配置文件目录 mysql.server命令及配置 /usr/bin 相关命令目录 mysqladmin mysqldump等命令 /etc/init.d/mysql 启停脚本目录 2.2 MySQL配置文件 文件 类型 备注 log-bin 二进制配置文件 主从复制用到 log-error 错误日志文件 默认关闭 log 查询日志 默认关闭 frm 数据文件：表结构 myd 数据文件：表数据 myi 数据文件：表索引 my.ini或my.cnf 配置文件 log-errror：默认关闭，记录严重的警告信息和错误信息，每次启动关闭的详细信息。 log：默认关闭，记录查询的sql语句，开启会降低mysql整体性能。 数据文件在windows和Linux平台下不同 windows：..\\MySQL\\MySQL Server 5.7\\data linux：/var/lib/mysql 3. MySQl逻辑架构介绍3.1 总体概述​ 和其他数据库相比，MySQL有点与众不同，他的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上。插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的引擎。 ​ 下图展示了MySQL的框架图，包含了：连接层、服务层、引擎层、存储层。 连接层 ​ 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务器端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、以及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供了线程。同样在该层上可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层 ​ 第二层架构主要完成大多数的核心服务功能，如SQL接口、并完成缓存的查询，SQL的分析和优化部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析擦好像并创建相应的内部解析树，并对其完成相应的优化，如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境能很好提升系统性能。 引擎层 ​ 存储引擎层，存储引擎真正负责MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同存储引擎的功能不同，这样有利于我们根据实际生产环境进行选择。 存储层 ​ 数据存储层，主要将数据存储在运行与裸设备的文件系统上，并完成与存储引擎的交互。 Connector ​ 指的是不同语言中与SQL的交互 Managemen Service &amp; Utilities ​ 系统管理和控制工具 Connection Pool ​ 连接池，管理缓冲用户连接，线程处理等需要缓存的需求。 ​ 负责监听对MySQL Server的各种请求，接受连接请求，转发所有连接请求到线程管理模块。每一个连接上Server的客户端请求都会被分配一个线程来为其单独服务。而连接线程的主要工作就是负责MySQL Server与客户端的通信。 SQL Interface ​ SQL接口，接受用户的SQL命令，并且返回用户需要的查询结果。比如select 就是调用SQL Interface。 Parser：解析器 ​ SQL命令传递到解析器会被解析器验证和解析。解析器有Lex和YACC实现，是一个很长的脚本。 ​ 在Mysql中我们习惯将所有Client端发送给Server端的命令都成为query，在Mysql Server里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。 ​ 主要功能：​ a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。​ b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的 Optimizer：查询优化器 ​ SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果他使用的是“选取-投影-联接”策略进行查询。​ 用一个例子就可以理解： select uid,name from user where gender = 1;​ 这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤​ 这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤​ 将这两个查询条件联接起来生成最终查询结果 Cache和Buffer ​ 他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。​ 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 存储引擎接口 ​ 存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。​ 从上图还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。​ 注意：存储引擎是基于表的，而不是数据库。 3.2 MySQL存储引擎 查看存储引擎 1234567891011-- 查看提供的引擎show engines;-- 查看当前默认引擎show variables like &quot;%storage_engine%&quot;;+------------------------+--------+| Variable_name | Value |+------------------------+--------+| default_storage_engine | InnoDB || storage_engine | InnoDB |+------------------------+--------+ MyISAM和InnoDB ​ 虽然Mysql提供了很多存储引擎，但我们常用的主要是：MyISAM和InnoDB，下面是两个存储引擎的对比。 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不利于高并发 行锁，操作时只锁一行，不影响其他行，适合高并发。 缓存 只缓存索引，不缓存真实数据 不仅缓存索引，还缓存数据，堆内存要求较高 表空间 小 大 关注点 性能 事务 默认安装 Y Y 大厂使用的存储引擎 Percona、阿里巴巴大部分Mysql数据库其实使用的percona的原型加以修改。 4. 总结​ 这部分主要介绍了MySQL概述，MySQL的高级技术有哪些，MySQL5.5在Linux环境下的安装配置，MySQL5.5的配置文件结构，还结束了MySQL的逻辑架构。 ​ MySQL逻辑架构可分为4层：连接层、服务层、引擎层、存储层。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"微信小程序认证","slug":"微信小程序认证","date":"2020-08-08T15:29:43.000Z","updated":"2021-01-15T03:37:28.290Z","comments":true,"path":"2020/08/08/微信小程序认证/","link":"","permalink":"https://tobing.top/2020/08/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A4%E8%AF%81/","excerpt":"​ 使用Java后台作为微信小程序开发的时候，我们通常需要前后端分离开发。这时候，我们通常编写开发的RESTful风格的后端接口，从而使得微信小程序可以进行远程调用、获取数据。这时候就涉及到一个问题，我们的接口任何人都可以调用，怎么知道调用该接口的是谁呢？这时候我们便需要使用到了认证机制。接下来我们来简要介绍常用的认证机制","text":"​ 使用Java后台作为微信小程序开发的时候，我们通常需要前后端分离开发。这时候，我们通常编写开发的RESTful风格的后端接口，从而使得微信小程序可以进行远程调用、获取数据。这时候就涉及到一个问题，我们的接口任何人都可以调用，怎么知道调用该接口的是谁呢？这时候我们便需要使用到了认证机制。接下来我们来简要介绍常用的认证机制 微信小程序认证1. 问题引入​ 使用Java后台作为微信小程序开发的时候，我们通常需要前后端分离开发。这时候，我们通常编写开发的RESTful风格的后端接口，从而使得微信小程序可以进行远程调用、获取数据。这时候就涉及到一个问题，我们的接口任何人都可以调用，怎么知道调用该接口的是谁呢？这时候我们便需要使用到了认证机制。接下来我们来简要介绍常用的认证机制。 2. 常见认证机制简介2.1 HTTP Basic Auth​ HTTP Basic Auth，每次请求API时都提供用户uername和password，简而言之，Basic Auth是配合restFul PAPI使用最简单的认证方式，只提供用户名密码即可，但这种情况容易将用户名密码暴露给第三方客户端，在生产环境中越来越少。因此，开发对外开发的RESTful API时，尽量避免HTTP Basic Auth。 2.2 Cookie Auth​ Cookie认证机制就是为了一次请求认证在服务端建立一个Session对象，同时在客户端的浏览器创建一个Cookie对象；通过客户端带上Cookie对象，通过客户端带上Cookie对象来与服务器端的Session对象匹配状态管理。默认情况下，当我们关闭浏览器的时候，Cookie对象会被删除，但可以通过修改Cookie的expire time指定Cookie的生存时间。 2.3 OAuth​ OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一个web服务上存储的私密资源，而无需用户名和密码提供第三方应用。 ​ OAuth运行用户提供一个令牌，而不是用户名密码来访问他们的数据。每个令牌授权一个特定的第三方系统在特定的时段（例如，接下来2小时）内访问特定资源（例如仅仅是某一个相册的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。 123456789101112131415161718+--------+ +---------------+| |--(A)- Authorization Request -&gt;| Resource || | | Owner || |&lt;-(B)-- Authorization Grant ---| || | +---------------+| || | +---------------+| |--(C)-- Authorization Grant --&gt;| Authorization || Client | | Server || |&lt;-(D)----- Access Token -------| || | +---------------+| || | +---------------+| |--(E)----- Access Token ------&gt;| Resource || | | Server || |&lt;-(F)--- Protected Resource ---| |+--------+ +---------------+ Figure 1: Abstract Protocol Flow 这种基于OAuth的认证机制适用于个人消费者类的互联网产品，然后社交类APP等应用，但不适合拥有自认证权限管理的企业应用。 2.4 Token Auth2.4.1大概流程 客户端使用用户名等请求登录 服务器端收到请求，验证用户名 验证成功后，服务器端签发token，再把token返回给客户端 客户端收到Token以后可以把它存储起来，比如放在Cookie里面 客户端每次收到服务端请求资源的时候需要带着客户端签发的token 服务器端收到请求，然后去验证客户端请求携带的token，验证成功，则取数据并返回。 2.4.2 与cookie对比 Token Cookie 支持跨域 不支持跨域 无状态 有状态 更加适合CDN 去耦合 不行考虑CSRF 性能高 CSRF:跨站请求仿造，基于Cookie的弱点 无状态登录：服务器端不保存登录信息；有状态（比如cookie）服务器端要存储信息。 3. JWT​ JSON WEB Token ，是一种非常轻巧的规范。运行我们在用户与服务器间传输安全可靠的信息。 JWT组成​ 头部：用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。 ​ 载荷：载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包 含三个部分 ​ 签证：这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的签证。 4. 微信小程序实战​ 基于以上的介绍，结合微信小程序的特色，我们选择了token来进行认证。下图展示了微信小程序的认证流程。 ​ 结合微信小程序的认证过程，我们大致的执行流程如下： 微信小程序启动，调用wx.login获取code，wx.request携带code访问个人服务器 个人服务器发送HTTP请求调用微信接口，拿到openid等信息。 个人服务器拿到签发的openid，生产token，返回给小程序。 小程序存储token，每次访问接口时携带上。 服务器端接受到小程序的调用，校验小程序的token，校验成功则返回数据。 小程序端代码123456789101112131415// 登录wx.login(&#123; success: res =&gt; &#123; wx.request(&#123; url: &#x27;http://localhost:9002/user/login&#x27;, method: &quot;POST&quot;, data: &#123; code: res.code &#125;, success: d =&gt; &#123; // 拿到token并存储 &#125; &#125;) &#125;&#125;) 服务器端获取openid12345678910111213141516private WXResponse getWxuserOpenId(String code) &#123; // 拼接请求参数 String url = &quot;https://api.weixin.qq.com/sns/jscode2session?appid=&quot; + wxMsg.getAppId() + &quot;&amp;secret=&quot; + wxMsg.getAppSecret() + &quot;&amp;js_code=&quot; + code + &quot;&amp;grant_type=authorization_code&quot;; // 使用restTemplate发送httpGet请求 String response = restTemplate.getForObject(url, String.class); WXResponse wxResponse = null; try &#123; wxResponse = JSON.parseObject(response, WXResponse.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wxResponse;&#125; 服务器端签发token1234567891011121314151617181920212223@PostMapping(&quot;/login&quot;)public Result login(@RequestBody Map msg) &#123; // 获取携带的code String code = (String) msg.get(&quot;code&quot;); if (code == null) &#123; return new Result(false, StatusCode.ERROR, &quot;参数异常&quot;); &#125; // 根据code获取openid、sessionKey WXResponse wxResponse = getWxuserOpenId(code); if (wxResponse == null) &#123; return new Result(false, StatusCode.ERROR, &quot;openid获取失败&quot;); &#125; String sessionKey = wxResponse.getSession_key(); String openid = wxResponse.getOpenid(); if (openid == null) &#123; return new Result(false, StatusCode.ERROR, &quot;openid获取失败&quot;); &#125; // 生产token，并返回 String token = jwtUtil.createJWT(loginUser.getId(), loginUser.getNickname(), &quot;user&quot;); Map map = new HashMap(); map.put(&quot;token&quot;, token); return new Result(true, StatusCode.OK, &quot;登录成功&quot;, map);&#125; 5. 补充理解OAuth 2.0：http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html RESTful API 设计指南：www.ruanyifeng.com/blog/2014/05/restful_api.html JSON Web Token 入门教程：www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html","categories":[{"name":"技术应用","slug":"技术应用","permalink":"https://tobing.top/categories/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://tobing.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"认证机制","slug":"认证机制","permalink":"https://tobing.top/tags/%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"},{"name":"jwt","slug":"jwt","permalink":"https://tobing.top/tags/jwt/"}]},{"title":"Springboot实现图片上传并返回URL","slug":"Springboot实现图片上传并返回URL","date":"2020-08-02T14:25:02.000Z","updated":"2021-01-15T03:27:33.251Z","comments":true,"path":"2020/08/02/Springboot实现图片上传并返回URL/","link":"","permalink":"https://tobing.top/2020/08/02/Springboot%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%B9%B6%E8%BF%94%E5%9B%9EURL/","excerpt":"​ 在很多时候我们都需要使用图片上传的功能，比如：自定义头像、物品的图片描述、文章的插图等，那么我们该如何使用Springboot来方便快捷实现图片上传呢？我们闲话少说，直接上代码。","text":"​ 在很多时候我们都需要使用图片上传的功能，比如：自定义头像、物品的图片描述、文章的插图等，那么我们该如何使用Springboot来方便快捷实现图片上传呢？我们闲话少说，直接上代码。 Springboot实现图片上传并返回URL1. 问题引入​ 在很多时候我们都需要使用图片上传的功能，比如：自定义头像、物品的图片描述、文章的插图等，那么我们该如何使用Springboot来方便快捷实现图片上传呢？我们闲话少说，直接上代码。 2. 后端代码1. 创建Maven工程pom文件依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 编写代码 启动类 123456@SpringBootApplicationpublic class UploadApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UploadApplication.class); &#125;&#125; 启动类没啥好说的。 service 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Servicepublic class UploadService &#123; private static final List&lt;String&gt; CONTENT_TYPES = Arrays.asList(&quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;); /** * 图片上传： * 1. 判断文件类型合法性 * 2. 判断文件内容合法性 * 3. 保存文件 * 4. 返回url * * @param file * @return */ public String upload(MultipartFile file) &#123; String originalFilename = file.getOriginalFilename(); // 获取文件content type，判断是否为图片 String contentType = file.getContentType(); if (!CONTENT_TYPES.contains(contentType)) &#123; // 文件类型不合法 System.out.println(&quot;ERROR，文件类型不合法！&quot;); return null; &#125; try &#123; // 读取文件 BufferedImage bufferedImage = ImageIO.read(file.getInputStream()); // 判断文件内容合法性 if (bufferedImage == null) &#123; System.out.println(&quot;ERROR，文件内容不合法！&quot;); return null; &#125; // 将文件保存到服务器中 file.transferTo(new File(&quot;D:\\\\test\\\\&quot; + originalFilename)); // 返回文件连接 return &quot;http://localhost/&quot; + originalFilename; &#125; catch (IOException e) &#123; System.out.println(&quot;ERROR，服务器内部错误！&quot;); e.printStackTrace(); &#125; return null; &#125;&#125; service层是文件上传逻辑处理的关键，主要流程是： 1. 判断文件名是否合法 2. 判断文件内容是否合法 3. 保存文件【处理文件名】 4. 拼接url并返回 controller 12345678910111213141516171819202122@RestController@RequestMapping(&quot;/upload&quot;)public class UploadController &#123; @Autowired private UploadService uploadService; /** * 图片上传 * * @param file * @return */ @PostMapping(&quot;image&quot;) public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; String url = this.uploadService.upload(file); if (url == null || url.length() == 0) &#123; return new Result(false, StatusCode.ERROR, &quot;图片上传异常&quot;); &#125; return new Result(false, StatusCode.OK, &quot;图片上传成功&quot;, url); &#125;&#125; 这里主要知道使用MultipartFile接收上传的文件。 这里的Result是自定义的规范，不是本问题的重点。 3. Nginx代理​ 有了上面的步骤，我们可以实现文件上传到服务器端的磁盘，接下来我们使用Nginx将访问路径代理到我们存储图片的地方。 Nginx配置文件 12345678server &#123;listen 8888;server_name localhost;# 将其它图片代理指向本地图片所在目录location &#x2F; &#123;root D:&#x2F;test;&#125; 上面的配置文件表明了：nginx将所有访问的8888端口代理到了D盘的test目录下。 4. 测试我们使用Postman，以Post方式，在Body中以form-data中使用file类型进行选择图片提交。可以参考： https://blog.csdn.net/qq_30033537/article/details/105604665 5. 总结​ 实现图片上传并不麻烦，写这次博客主要是最近使用了图片上传的功能，有点陌生，写下来以后用到看起来也方便。哈哈哈哈哈哈哈！！！没错，被你们看穿了，我就是来水博客的，兑现之前立下的flag。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://tobing.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://tobing.top/tags/SpringBoot/"}]},{"title":"数据结构2-栈和队列","slug":"数据结构2-栈和队列","date":"2020-07-24T05:11:35.000Z","updated":"2021-01-15T03:26:59.269Z","comments":true,"path":"2020/07/24/数据结构2-栈和队列/","link":"","permalink":"https://tobing.top/2020/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"数据结构：栈和队列学习。","text":"数据结构：栈和队列学习。 数据结构2-栈和队列1. 栈 概述 ​ 栈也是一种线性结构，和数组相比，是数组操作的子集，规定了只能从一端添加元素，也只能从这一端取出元素，这一端称为栈顶。栈是一种后进先出（LIFO）的数据结构。 应用 undo操作-编辑器 系统调用栈-os 括号匹配-编译器 实现 1）定义栈的接口 123456789101112131415package top.tobing.ds.stack;public interface Stack&lt;E&gt; &#123; // 获取栈的大小 int getSize(); // 判断栈是否为空 boolean isEmpty(); // 讲一个元素压栈 void push(E e); // 将栈顶元素弹出 E pop(); // 查看栈顶元素 E peek();&#125; 2）利用之前编写的动态数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package top.tobing.ds.stack;/** * @author Tobing */public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayStack() &#123; this.array = new Array&lt;&gt;(); &#125; public ArrayStack(int capacity) &#123; this.array = new Array&lt;&gt;(capacity); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; // 返回栈的容量 public int getCapacity() &#123; return array.getCapacity(); &#125; @Override public void push(E e) &#123; array.addLast(e); &#125; @Override public E pop() &#123; return array.removeLast(); &#125; @Override public E peek() &#123; return array.getLast(); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Stack: &quot;); sb.append(&quot;[&quot;); for (int i = 0; i &lt; array.getSize(); i++) &#123; sb.append(array.get(i)); if (i != array.getSize() - 1) &#123; sb.append(&quot;, &quot;); &#125; &#125; sb.append(&quot;] top&quot;); return sb.toString(); &#125;&#125; Array的代码查看数据结构1-数组 复杂度分析 函数名 复杂度 其他说明 push O(1)均摊 压栈的时候可能触发resize pop O(1)均摊 弹栈的时候可能触发resize peek O(1) Java中的栈 ​ Stack 类表示后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。 首次创建堆栈时，它不包含项。 Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set，应该优先使用此 set，而非此类。例如： 1Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); 2. 队列 概述 ​ 队列也是一种线性结构，和数组相比，是数组操作的子集，规定了只能从一端（队尾）添加元素，也只能从另外一端（队首）取出元素，这一端称为栈顶。栈是一种先进先出（FIFO）的数据结构。 实现 1）定义队列接口 123456789101112131415package top.tobing.ds.queue;public interface Queue&lt;E&gt; &#123; // 获取队列大小 int getSize(); // 判断是否为空队列 boolean isEmpty(); // 入队 void enqueue(E e); // 出队 E dequeue(); // 查看队首元素 E getFront();&#125; 2）队列实现1-数组队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package top.tobing.ds.queue;/** * @author Tobing */public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayQueue(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue() &#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; public int getCapacity() &#123; return array.getCapacity(); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Queue: front [&quot;); for (int i = 0; i &lt; array.getSize(); i++) &#123; sb.append(array.get(i)); if (i != array.getSize() - 1) &#123; sb.append(&quot;, &quot;); &#125; &#125; sb.append(&quot;] tail&quot;); return sb.toString(); &#125;&#125; 2）队列实现2-循环队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package top.tobing.ds.queue;import top.tobing.ds.queue.Queue;import java.util.Arrays;/** * @author Tobing */public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] data; private int front, tail; private int size; public LoopQueue(int capacity) &#123; front = 0; tail = 0; size = 0; data = (E[]) new Object[capacity + 1]; &#125; public LoopQueue() &#123; this(10); &#125; @Override public int getSize() &#123; return this.size; &#125; @Override public boolean isEmpty() &#123; return front == tail; &#125; @Override public void enqueue(E e) &#123; if ((tail + 1) % data.length == front) &#123; resize(getCapacity() * 2); &#125; data[tail] = e; size++; tail = (tail + 1) % data.length; &#125; @Override public E dequeue() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(&quot;Queue is empty.&quot;); &#125; E res = data[front]; data[front] = null; front++; size--; // 懒汉式：防止复杂度闪烁 if (size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) &#123; resize(getCapacity() / 2); &#125; return res; &#125; // 扩容 private void resize(int capacity) &#123; E[] newData = (E[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size; &#125; @Override public E getFront() &#123; return data[front]; &#125; public int getCapacity() &#123; return data.length - 1; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Queue: front [&quot;); for (int i = front; i != tail; i = (i + 1) % data.length) &#123; sb.append(data[i]); if ((i + 1) % data.length != tail) &#123; sb.append(&quot;, &quot;); &#125; &#125; sb.append(&quot;] tail&quot;); return sb.toString(); &#125;&#125; 复杂度分析 1）数组复杂度 函数 复杂度 其他说明 enqueue O(1)均摊 可能触发resize dequeue O(n） 可能触发resize getFront O(1) getCapacity O(1) ​ 从上面的复杂度分析可知，数组方式实现的队列在每次出队之后，要将剩下的所有元素挪动一遍，导致复杂度O(n)，因此我们考虑在不挪动的情况下实现队列。于是便有了循环队列。 2）循环队列复杂度 函数 复杂度 其他说明 enqueue O(1)均摊 可能触发resize dequeue O(1)均摊 可能触发resize resize O(n) getFront O(1) getCapacity O(1) getSize O(1) 代码注意点 ​ 数组方式实现的队列基本都是在Array上进行封装，Array之前已经分析过，因此我们不在进行赘述，我们主要讨论循环队列的实现。 循环队列使用front和tail记录了队列的队首和队尾。 循环队列如果全部利用所有元素，判断front==tail会有歧义，因此浪费一个元素消除歧义。 循环队列通过判断**(tail+1)%data.length==front**来巧妙地判断队列是否满。 循环队列入队、出队、扩容的时候都要维护front、tail、size。 循环队列遍历可以有多种方式，通过判断下标是否为tail或者循环次数是否为size可以判定循环是否可以结束。 入队时注意判断队列是否已满（resize），维护size和tail。 出队时注意判断队列是否已经为空，同时也要判断是否要进行resize，维护front和size。 resize的时候注意维护front、tail和size。 Java中的队列 ​ 队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。无论使用哪种排序方式，队列的头 都是调用 remove() 或 poll() 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的末尾。其他种类的队列可能使用不同的元素放置规则。每个 Queue 实现必须指定其顺序属性。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://tobing.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://tobing.top/tags/%E9%98%9F%E5%88%97/"}]},{"title":"MongoDB初识","slug":"MongoDB初识","date":"2020-07-18T07:01:51.000Z","updated":"2021-01-15T03:26:33.383Z","comments":true,"path":"2020/07/18/MongoDB初识/","link":"","permalink":"https://tobing.top/2020/07/18/MongoDB%E5%88%9D%E8%AF%86/","excerpt":"​ MongoDB是一个跨平台、面向文档的数据库，是当前NoSQL中最热门的一种。它介于关系型和非关系型数据库之间，是非关系型数据库中：功能最丰富、最像关系型数据库的产品。它支持的数据结构非常松散，是类似Json的Bson格式，因此可以存储较为复杂的数据。","text":"​ MongoDB是一个跨平台、面向文档的数据库，是当前NoSQL中最热门的一种。它介于关系型和非关系型数据库之间，是非关系型数据库中：功能最丰富、最像关系型数据库的产品。它支持的数据结构非常松散，是类似Json的Bson格式，因此可以存储较为复杂的数据。 MongoDB初识1. 简介​ MongoDB是一个跨平台、面向文档的数据库，是当前NoSQL中最热门的一种。它介于关系型和非关系型数据库之间，是非关系型数据库中：功能最丰富、最像关系型数据库的产品。它支持的数据结构非常松散，是类似Json的Bson格式，因此可以存储较为复杂的数据。 ​ MongoDB官网： https://www.mongodb.com/ 1. 特点​ MongoDB最大特点是：支持的查询语言非常强大，语法类似面向对象的查询语句，几乎可以实现所有关系型数据库单表查询的绝大部分功能，而且还支持对数据库建立索引。MongoDB是面向集合的，模式自由的文档型数据库。 1）面向集合存储，易于存储对象型数据 2）模式自由 3）支持动态查询 4）支持完全索引，包含内部对象 5）支持复制和故障恢复 6）使用高效的二进制数据存储，包括大型对象（比如视频等） 7）支持Python、PHP、Java、Ruby、C、C#、JS等语言的驱动程序。 8）文件存储格式为BSON（JSON的扩展） 2. 体系结构​ MongoDB的逻辑结构是一种层次结构，由Document、Collection、Database三部分组成，逻辑结构是面向用户的。 1）Document：相当关系型数据库表的一行记录。 2）Collection：相当于关系型数据库的一张表，可以存储多个Document。 3）Database：相当于关系型数据库的一个数据库，可以存储多个Collection。 3. 数据类型 数据类型 特点 示例 null 空值、或不存在的值 {“x”:nul} 布尔型 true、false {“x”:true} 数值 默认使用64浮点型，NumberInt可以定义使用整型 {“x”:NumberInt(1)} 字符串 UTF-8 {“x”:”呵呵”} 日期 毫秒数，不存储时区 {“x”:new Date()} 正则表达式 查询时，可以作为条件 {“x”:/[abc]/} 数组 类别Java {“x”:[“a”,”b”]} 内嵌对象 文档内可以嵌套其他文档对象 {“x”:{“y”:3}} 对象id 12字节字符串，文档的唯一标识 {“x”:objectId()} 二进制数据 非UTF-8数据 代码 查询和文档中可以包含任何JS代码 {“x”:function(){…}} 2. MongoDB简单使用1. 安装【Windows】​ 1）下载安装文件 ​ 2）安装在指定目录 ​ 3）将该目录添加到环境变量中 https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/ 2. 启动1）新建cmd窗口 2）使用mongod设置数据库存放目录 1234# 创建目录md D:\\mongodata# 指定目录mongod --dbpath=D:\\mongodata 2）输入mongo，进入mongoDB中 3）输入exit，退出 3. Docker下安装MongoDB 拉取镜像 1234# 搜索镜像docker search mongo# 拉取镜像docker pull mongo 创建容器 12# 守护式方式创建容器docker run -di --name=my_mongodb -p 27017:27017 mongo 远程登录 ​ 我们之前安装的MongoDB既是服务器端，也是客户端，因此我们使用windows下的远程连接部署在docker上的。 1mongo [docker宿主机IP地址] 4. 常用命令​ 在使用客户端连上了docker的mongoDB之后，我们使用起来学习常用命令。 选择和创建数据库 1use [数据库名称] 与MySQL不同，MongoDB下，当指定的数据库名称不存在，则会自动创建一个数据库。 插入与查询文档 1234# 插入文档db.[集合名称].insert(数据);# 查询所有文档db.[集合名称].find(); 演示 12345678# 创建msgdb数据库use msgdb# 插入文档信息 包含:context,namedb.msg.insert(&#123;content:&quot;你好啊，MongoDB！&quot;,name:&quot;tobing&quot;)&#125;);# 查询所有，查看是否插入成功db.msg.find(); 查询结果 1&#123; &quot;_id&quot; : ObjectId(&quot;5f1289f78d22f2d94c6e42de&quot;), &quot;content&quot; : &quot;你好啊，MongoDB，这是一句话&quot;, &quot;username&quot; : &quot;tobing&quot; &#125; 观察查询结果我们发现，文档中多了一条**”_id”的字段，这相当于关系型数据库中的主键**。 当插入文档时没有注定，MongoDB会帮我们自动创建，类型为ObjectID类型。 我们插入时也可以指定，可以是ObjectID类型或者MongoDB支持的任意类型。 1234567891011# 添加第二条记录db.spit.insert(&#123;&quot;_id&quot;:&quot;1&quot;,content:&quot;你好啊，赤橙梦魇过&quot;,&quot;username&quot;:&quot;zenyet&quot;&#125;)# 再次查询所有db.spit.find()# 查询一个：查询_id为1的数据db.spit.findOne(&#123;&quot;_id&quot;:&quot;1&quot;&#125;)# 查询前n条记录db.spit.find().limit(3) 123456#查询所有&#123; &quot;_id&quot; : ObjectId(&quot;5f1289f78d22f2d94c6e42de&quot;), &quot;content&quot; : &quot;你好啊，MongoDB，这是一句话&quot;, &quot;username&quot; : &quot;tobing&quot; &#125;&#123; &quot;_id&quot; : &quot;1&quot;, &quot;content&quot; : &quot;你好啊，赤橙梦魇过&quot;, &quot;username&quot; : &quot;zenyet&quot; &#125;# 查询一个&#123; &quot;_id&quot; : &quot;1&quot;, &quot;content&quot; : &quot;你好啊，赤橙梦魇过&quot;, &quot;username&quot; : &quot;zenyet&quot; &#125; 修改和删除文档 修改 1db.集合名称.update(条件，修改的数据) 删除 1db.集合名称.remove(条件) 示例 1234# 更新_id为1的contentdb.spit.update(&#123;&quot;_id&quot;:&quot;1&quot;&#125;,&#123;$set:&#123;content:&quot;Hello, This is new !&quot;&#125;&#125;)# 删除_id为1的文档db.spit.remove(&#123;&quot;_id&quot;:&quot;1&quot;&#125;) 注意：当不加上$set的时候，会将符合条件的记录的其他字段全部清空。 统计条数 1234# 统计所有dp.spit.count()# 统计符合条件dp.spit.count(条件) 模糊查询 MongoDB的模糊查询通过正则表达式方式实现的。格式为：/模糊查询字符串/ 1234# 查询所有content字段包含tobing的文档db.spit.find(&#123;content:/流量/&#125;)# 查询所有content字段以流量开头的文档db.spit.find(&#123;content:/^流量/&#125;) 比较运算符 &lt;、&gt;、&lt;=、&gt;=操作 12345db.集合名称.find(&#123;&quot;Field&quot;:&#123;$gt:value&#125;&#125;) // 大于：field &gt; valuedb.集合名称.find(&#123;&quot;Field&quot;:&#123;$lt:value&#125;&#125;) // 小于：field &lt; valuedb.集合名称.find(&#123;&quot;Field&quot;:&#123;$gte:value&#125;&#125;) // 大于等于：field &gt;= valuedb.集合名称.find(&#123;&quot;Field&quot;:&#123;$lte:value&#125;&#125;) // 小于等于：field &lt;= valuedb.集合名称.find(&#123;&quot;Field&quot;:&#123;$ne:value&#125;&#125;) // 不等于：field != value 包含与不包含 1234# 查询id包含101,102的文档db.spit.find(&#123;id:&#123;$in:[&quot;101&quot;,&quot;102&quot;]&#125;&#125;)# 查询不包含的db.spit.find(&#123;id:&#123;$nin:[&quot;101&quot;,&quot;102&quot;]&#125;&#125;) 条件连接 需要查询同时满足两个条件的时候，使用and 需要查询满足其中一个条件的时候，用or 123$and:[&#123;&#125;,&#123;&#125;,&#123;&#125;]$or:[&#123;&#125;,&#123;&#125;,...] 1234# 查询符合id=1且name=&quot;tobing&quot;的文档db.spit.find(&#123;$and:[&#123;&quot;id&quot;:1&#125;,&#123;&quot;name&quot;:&quot;tobing&quot;&#125;]&#125;)# 查询符合id=1或name=&quot;tobing&quot;的文档db.spit.find(&#123;$or:[&#123;&quot;id&quot;:1&#125;,&#123;&quot;name&quot;:&quot;tobing&quot;&#125;]&#125;) 列值增长 可以使用$inc运算符对原有的值进行增加或减少 1db.spit.udpate(&#123;_id:&quot;2&quot;&#125;,&#123;$inc:&#123;visits:NumberInt(1)&#125;&#125;) 3. Java操作MongoDB1. 创建maven、导入依赖坐标12345&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt; 2. 创建测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package top.tobing.test;import com.mongodb.BasicDBObject;import com.mongodb.MongoClient;import com.mongodb.client.FindIterable;import com.mongodb.client.MongoCollection;import com.mongodb.client.MongoDatabase;import org.bson.Document;import java.util.HashMap;import java.util.Map;/** * @author Tobing */public class MongoTest &#123; public static void main(String[] args) &#123; // 创建连接 MongoClient client = new MongoClient(&quot;192.168.8.128&quot;); // 打开数据库 MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 查询所有 // testFindAll(spitdb); // 条件查询 // testFindByEx(spitdb); // 插入数据 testInsertData(spitdb); testFindAll(spitdb); // 关闭连接 client.close(); &#125; private static void testInsertData(MongoDatabase spitdb) &#123; MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;username&quot;,&quot;张三丰&quot;); map.put(&quot;content&quot;,&quot;我是太极创始人，有我拽？&quot;); Document document = new Document(map); spit.insertOne(document); &#125; /** * 条件查询 * * @param spitdb */ private static void testFindByEx(MongoDatabase spitdb) &#123; MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 构造查询条件 BasicDBObject bson = new BasicDBObject(&quot;username&quot;, &quot;tobing&quot;); FindIterable&lt;Document&gt; documents = spit.find(bson); for (Document document : documents) &#123; System.out.println( document.get(&quot;username&quot;) + &quot;:&quot; + document.get(&quot;content&quot;)); &#125; &#125; /** * 查询所有 * * @param spitdb */ public static void testFindAll(MongoDatabase spitdb) &#123; MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); FindIterable&lt;Document&gt; documents = spit.find(); for (Document document : documents) &#123; System.out.println( document.get(&quot;username&quot;) + &quot;:&quot; + document.get(&quot;content&quot;)); &#125; &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://tobing.top/tags/MongoDB/"}]},{"title":"Docker初识","slug":"Docker初识","date":"2020-07-17T11:43:01.000Z","updated":"2021-01-15T03:33:12.778Z","comments":true,"path":"2020/07/17/Docker初识/","link":"","permalink":"https://tobing.top/2020/07/17/Docker%E5%88%9D%E8%AF%86/","excerpt":"Docker是一个开源项目，诞生与2013年，最初四dotCloud的一个内部业余项目，后来家人Linux，遵从了Apache2.0协议，GitHub上维护。","text":"Docker是一个开源项目，诞生与2013年，最初四dotCloud的一个内部业余项目，后来家人Linux，遵从了Apache2.0协议，GitHub上维护。 Docker1. Docker简介1. 什么是Docker​ Docker是一个开源项目，诞生与2013年，最初四dotCloud的一个内部业余项目，后来家人Linux，遵从了Apache2.0协议，GitHub上维护。基于go语言。 ​ Docker目标是：实现轻量级操作系统虚拟化解决方案。Docker基础是Linux容器技术（LXC）。 使用Docker语言 上手快 ​ 用户只需要几分钟，便可把自己程序Docker化。Docker依赖于写时复制（copy on write）模型，使得修改应用程序非常迅速。 ​ Docker启动快，拥有很高性能，可充分利用系统资源。 职责逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需关心如何管理容器。Docker设计的目的就是加强开发人员生产环境与部署环境的一致性，从而减少因生产、部署环境不一致而导致的问题。 快速高效的开发生命周期、 ​ Docker目标之一就是缩短开发、测试、部署的周期，让程序更具有可以移植性，易于构建。 鼓励面向服务的架构 ​ Docker鼓励面向服务的体系结构和微服务架构。 2. 容器与虚拟机的比较​ 容器在层面上实现虚拟化，直接复用本地的OS。 ​ 虚拟机则是在硬件层面上。 ​ 因此容器启动速度快，占用体积小。 3. 容器组件 Docker服务器与客户端 ​ Docker是C/S架构程序。Docker客户端只需向Docker服务器或守护进程发起请求，服务器或守护进程将完成所有工作并返回结果。 Docker镜像与容器 ​ 镜像：构建Docker基石。可以通过一个镜像构建多个不同的容器。 ​ 容器：容器基于镜像启动，一旦容器启动完成，可以登录容器安装自己需要的软件后服务。 注册中心 ​ Docker用注册中心保持用户镜像，分为共有和私有。DockerHub是Docker运营的公共的Registry。 ​ https://hub.docker.com 2. Docker安装与启动1. 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 下面以Centos7.x安装为例 yum包更新到最新 1sudo yum update 装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data 1vm2 设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker 1sudo yum install docker-ce ## docker-ce是社区版 查看docker安装版本 1docker -v 2. 设置USTC镜像​ ustc是老牌的linux镜像服务提供者，ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。https://lug.ustc.edu.cn/wiki/mirrors/help/docker 安装好docker之后，编辑配置文件 1vi /etc/doceker/daemon.json 在文件中添加以下内容 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 3.Docker 启动与停止systemctl：系统服务管理器命令 启动docker 1systemctl start docker 停止docker 1systemctl stop docker 重启docker 1systemctl restart docekr 查看docker状态 1systemctl status docker 开机启动 1systemctl enable docker 查看docker概要 1docker info 查看docker帮助文档 1docker --help 4. 常用命令1. 镜像相关 查看镜像 1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像创建日期 SIZE：大小 镜像都是存在Docker宿主机的**/var/lib/docker**目录下 搜索镜像 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：和GitHub的类似 OFFICIAL：是否官方 ATOMATED：自动构建，表该镜像由Docker Hub自动构建流程创建的 拉取镜像 从中央仓库拉取镜像 1docker pull 镜像名称 删除镜像 根据id删除 1docker rmi 镜像ID 删除所有 1docker rmi `docker images -q` 2. 容器相关 查看容器 1234567891011# 查看正在运行的容器docker ps# 查看所有容器docker ps -a# 查看最后一次运行的容器docker ps -l# 查看停止的容器docker ps -f status=exited 创建与启动容器 123456789# 创建容器命令docker run-i ：表示运行容器-t ：表容器启动会进入其命令行。--name ： 为容器指定名-v ：表示目录映射关系，前者宿主机目录、后者映射到宿主机的目录-d ：创建守护式容器在后台运行（不会自动登录）-p ：端口映射， 宿主机端口 容器端口 1）交互式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 2）守护式创建容器 1234docker run -di --name=容器名称 镜像名称:标签# 退出当前容器exit 登录守护式创建容器 1docker exec -it 容器名称、容器id /bin/bash 停止与启动容器 12345# 停止容器docker stop 容器名称# 启动容器docker start 容器名称 文件拷贝 12345# 文件：宿主机--&gt;容器docker cp 需要拷贝的文件或目录 容器名称:容器目录# 文件：容器--&gt;宿主机docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载 123# 将宿主机的myhtml目录与容器的xxx/myhtml命令解析映射# 修改任意一方，另外一方就会改变docker run -di -v /usr/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 查看容器IP地址 12345# 查看容器运行的各种数据docker inspect 容器名称# 直接输出容器的IP地址docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 删除容器 12# 删除指定容器docker rm 容器名称 5. 应用部署1. MySQL 拉取mysql镜像 1docker pull centos/mysql-57-centos7 创建容器 1docker run -di --name=ownmysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7 -p 端口映射 -e 添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 远程登录 连接宿主机的ip、端口为33306 2. tomcat部署 拉取镜像 1docker pull tomcat:7-jre7 创建容器 1docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 3. Nginx部署 拉取镜像 1docker pull nginx 创建nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4. Redis部署 拉取 1docker pull redis 部署 1docker run -di --name=myredis -p 6379:6379 redis 待更新","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://tobing.top/tags/docker/"},{"name":"容器技术","slug":"容器技术","permalink":"https://tobing.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"数据结构-数组","slug":"数据结构1-数组","date":"2020-07-09T16:28:13.000Z","updated":"2021-01-15T03:25:58.583Z","comments":true,"path":"2020/07/10/数据结构1-数组/","link":"","permalink":"https://tobing.top/2020/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E6%95%B0%E7%BB%84/","excerpt":"数据结构数组的的学习笔记。","text":"数据结构数组的的学习笔记。 数据结构-数组1. 数组概述 特点 顺序存放、可以随机访问。 缺点 数组功能比较弱，考虑封装。 2. 封装自己的数组 引入 为了增强数组的功能，我们对数组进行二次封装，虽然Java已经有ArrayList对数组进行了封装，但为了学习，我们对数组进行封装。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package top.tobing.ds.array;public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; // 默认构造 public Array() &#123; this(10); &#125; // 获取数组的容量 public int getCapacity() &#123; return data.length; &#125; // 获取数组的元素个数 public int getSize() &#123; return size; &#125; // 判断数组是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 在所有元素后添加一个元素 public void addLast(E e) &#123; add(size, e); &#125; // 在使用元素前添加一个元素 public void addFirst(E e) &#123; add(0, e); &#125; // 在索引index处添加一个元素 public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; data.length) &#123; throw new IllegalArgumentException(&quot;Add failed. Require index &gt;= 0 and index &lt;= size&quot;); &#125; if (index == data.length) &#123; resize(2 * data.length); &#125; for (int i = size; i &gt; index; i--) &#123; data[i] = data[i - 1]; &#125; data[index] = e; size++; &#125; // 获取index索引位置的值 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(&quot;Get failed. Index is illegal.&quot;); &#125; return data[index]; &#125; // 修改index索引出的值为e public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(&quot;Set failed, Index is illegal.&quot;); &#125; data[index] = e; &#125; // 查找数组中是否包含元素e public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，返回-1 public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; // 删除数组中索引为index位置的元素，返回被删除的元素 public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(&quot;Rmove failed. Index is illegal.&quot;); &#125; E temp = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i + 1]; &#125; size--; data[size] = null; // 懒汉式：避免复杂度震荡 if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return temp; &#125; // 删除元素第一个元素 public E removeFirst() &#123; E temp = remove(0); return temp; &#125; // 删除元素最后一个元素 public E removeLast() &#123; E temp = remove(size - 1); return temp; &#125; // 删除数组中元素e public void removeElement(E e) &#123; int index = find(e); if (index != -1) &#123; remove(index); &#125; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append(String.format(&quot;Array: size = %d, capacity = %d\\n&quot;, size, data.length)); builder.append(&#x27;[&#x27;); for (int i = 0; i &lt; data.length; i++) &#123; builder.append(data[i]); if (i != data.length - 1) &#123; builder.append(&quot;, &quot;); &#125; &#125; builder.append(&quot;]&quot;); return builder.toString(); &#125; // 将数组的容量变成newCapacity大小 private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData; &#125;&#125; 代码中的注意点 泛型数组在通过指定大小创建时要以(E[])Objec[capacity]方式。 添加add或者删除remove元素的时候要对传入的index进行合法性校验。 add和remove都是采用覆盖的方式，区别两种的实现：一个是从后往前移，另一个则相反。 add和remove的同时要维护size，即更新size。 remove操作时要对size所在的位置置为null，以至于gc回收。 find操作判断元素是否相等时要使用equals。 动态数组时，要注意remove的容量调整时机，使用懒汉式可以避免复杂度震荡。 复杂度分析 函数名 复杂度 其他 add(int,E) O(n) 移动挪位 addFirst O(n) addLast O(1)、O(n) 不用挪位、容量变化 remove(int,E) O(n) 移动覆盖 removeFirst O(n) removeLast O(1)、O(n) 不用覆盖、容量变化 removeElement(E) O(n) 遍历查找 contains O(n) find O(n) get O(1) resize复杂度分析：加上容量为n、n+1次addLast，触发resize，纵观2n+1基本操作平均，每次addLast，进行2次基本操作，O(1)。 这次叫做均摊复杂度分析。 addLast和removeLast同时存在是，如果采用饿汉式，即size=capacity/2立马缩减容量，容易引发复杂度震荡。因此考虑使用懒汉式。即推迟到size=capacity/4,才将capacity置为原理一半。 3. 拓展查看Java对ArrayList的实现，对比我们的实现。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组 - Java","slug":"数组-Java","permalink":"https://tobing.top/tags/%E6%95%B0%E7%BB%84-Java/"}]},{"title":"树莓派连接DHT11","slug":"树莓派连接DHT11","date":"2020-06-21T15:41:24.000Z","updated":"2021-01-15T03:52:10.506Z","comments":true,"path":"2020/06/21/树莓派连接DHT11/","link":"","permalink":"https://tobing.top/2020/06/21/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9E%E6%8E%A5DHT11/","excerpt":"本文介绍树莓派读取DHT11的温度。","text":"本文介绍树莓派读取DHT11的温度。 树莓派读取DHT11并输出1. 工具 树莓派B+ DHT11、杜邦线 2. 步骤 将DHT11连接到树莓派 将vcc接到5V或3.3V，GND接GND，DATA接到接到GPIO23【不同树莓派的针脚功能可能不一样，自己上网查询对应版本】 SSH连接树莓派，安装Adafruit库 获取Adafruit库 1sudo git clone https://github.com/adafruit/Adafruit_Python_DHT.git 安装Adafruit 123cd Adafruit_Python_DHTsudo python setup.py installsudo python3 setup.py install 编写代码读取温度 创建py文件 1sudo vim TempTest.py 编写代码 12345678910111213141516171819202122232425import Adafruit_DHTimport timesensor = Adafruit_DHT.DHT11# 定义GIPO针脚gpio = 23class TempDHT11(): def getTempAndHum(self): humidity, tempertrue = Adafruit_DHT.read_retry(sensor, gpio) if humidity is not None and tempertrue is not None: return humidity, tempertrue else: return Noneif __name__ == &#x27;__main__&#x27;: temp = TempDHT11() while True: humD, tempD = temp.getTempAndHum(); if tempD is not None: print(&quot;温度：%1f , 湿度：%1f&quot; % (tempD, humD)) 运行 12345678pi@raspberrypi:~/Adafruit_Python_DHT/examples $ python3 TempTest2.py温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000温度：31.000000 , 湿度：77.000000","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tobing.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"DHT11","slug":"DHT11","permalink":"https://tobing.top/tags/DHT11/"},{"name":"物联网","slug":"物联网","permalink":"https://tobing.top/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"实验","slug":"实验","permalink":"https://tobing.top/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"真相?","slug":"真相","date":"2020-03-25T11:50:56.000Z","updated":"2021-01-15T03:25:29.801Z","comments":true,"path":"2020/03/25/真相/","link":"","permalink":"https://tobing.top/2020/03/25/%E7%9C%9F%E7%9B%B8/","excerpt":"一则视频。","text":"一则视频。 真相是什么？ 真相是什么？我们应该相信谁？ 原地址：https://www.bilibili.com/video/BV1e741177xT/ 当然是相信自己人 凡事不要随波逐流，要有自己的观点看法，科学地看待问题。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://tobing.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://tobing.top/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"ElasticSearch-上","slug":"ElasticSearch-上","date":"2020-02-26T16:02:29.000Z","updated":"2021-01-15T03:33:49.701Z","comments":true,"path":"2020/02/27/ElasticSearch-上/","link":"","permalink":"https://tobing.top/2020/02/27/ElasticSearch-%E4%B8%8A/","excerpt":"Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本 身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得 简单。","text":"Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本 身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得 简单。 ElasticSearch-上Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本 身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得 简单。 1. 使用ES 官网 https://www.elastic.co/products/elasticsearch 解压ES压缩包 1234567bin # 可执行二进制文件config # 配置信息目录lib # jar包存放目录logs # 日志存放目录modules # 模块存放目录plugins # 插件安装目录..... 启动ES访问 Windows：elasticsearch.bat Linux：elasticsearch.sh 启动ES之后 9300端口：es的tcp通讯端口，集群间和TCPClient都执行该端口。 9200端口：http协议的RESTful接口。 打开ES之后，在浏览器中访问127.0.0.1:9200，出现下面结果即表示启动成功。 12345678910111213&#123; &quot;name&quot;: &quot;4R2QZyN&quot;, &quot;cluster_name&quot;: &quot;elasticsearch&quot;, &quot;cluster_uuid&quot;: &quot;YQsfD7T8TgmT4tQf2RkEhQ&quot;, &quot;version&quot;: &#123; &quot;number&quot;: &quot;5.6.8&quot;, &quot;build_hash&quot;: &quot;688ecce&quot;, &quot;build_date&quot;: &quot;2018-02-16T16:46:30.010Z&quot;, &quot;build_snapshot&quot;: false, &quot;lucene_version&quot;: &quot;6.6.1&quot; &#125;, &quot;tagline&quot;: &quot;You Know, for Search&quot;&#125; 2. 使用ES可视化插件 下载head插件 https://github.com/mobz/elasticsearch-head 解压缩软件 下载安装nodejs https://nodejs.org/zh-cn/ 使用npm安装工具 12345# 安装gruntnpm install -g grunt-cli# 在解压后的header根目录执行下面命令，启动headnpm installgrunt server 访问测试 浏览器中输入：http://localhost:9100测试 配置es的config文件下yml配置文件配置跨域 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 重启ES 3. ES中的术语 概述 ES是面向文档（Document）的，可以存储整个对象或者文档。然而他不仅存储，还可以索引每个文档的内容，使之可以被搜索。在ES中，你可以对文档进行索引、搜索、排序、过滤。 123# ES对比传统关系型数据库关系型数据库 --&gt;Databases ---&gt;Tables ---&gt;Rows ---&gt;Colums ES --&gt;Indices ---&gt;Types ---&gt;Documents ---&gt;Fields ES核心概念 索引Index： ​ 一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索 引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这 个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索 引。 类型Type： ​ 在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来 定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数 据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可 以为评论数据定义另一个类型。 字段Field： ​ 相当于是数据表的字段，对文档数据根据不同属性进行的分类标识 映射mapping： ​ mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等， 这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据 对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。 文档document： ​ 一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然， 也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存 在的互联网数据交互格式。​ 在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须 被索引/赋予一个索引的type。 接近实时NRT： ​ Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延 迟（通常是1秒以内） 集群cluster： ​ 一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由 一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集 群的名字，来加入这个集群 节点node： ​ 一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。 分片和复制 shards&amp;replicas： ​ 一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任 一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供 了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每 个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主 要有两方面的原因： 1）允许你水平分割/扩展你的内容容量。 2）允许你在分片（潜在地，位于多个节点上）之上 进行分布式的、并行的操作，进而提高性能/吞吐量。 ​ 在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因 消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分 片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。 4. ES的客户端操作操作的三种方式【在postman下测试】 es-head插件 es提供的RESTful接口直接访问 ES提供的API访问 下载、注册并使用Postman https://www.postman.com/downloads/ 创建索引index和映射mapping【同时】 请求url 1post http://127.0.0.1:9200/index1 -- 可近似认为是数据库名 body 12345678910111213141516171819202122232425&#123; &quot;mappings&quot;:&#123; -- mapping关键字 &quot;article&quot;:&#123; -- 可近似为数据库表名 &quot;properties&quot;:&#123; -- properties关键字 &quot;id&quot;:&#123; -- 可近似数据库类名 &quot;type&quot;:&quot;long&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;not_analyzed&quot; &#125;, &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;store&quot;: true, &quot;index&quot;: &quot;analyzed&quot;, &quot;analyzer&quot;: &quot;standard&quot; &#125;, &quot;content&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;store&quot;:true, &quot;index&quot;:&quot;analyzed&quot;, &quot;analyzer&quot;:&quot;standard&quot; &#125; &#125; &#125; &#125;&#125; 先创建index再创建mapping 先创建index，不带body 1put http://127.0.0.1:9200/index1 创建mapping 请求url 1put http://127.0.0.1:9200/index1/_mapping body 12345678910111213141516171819202122&#123; &quot;tb1&quot;:&#123; &quot;properties&quot;:&#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;long&quot;, &quot;store&quot;:&quot;true&quot; &#125;, &quot;title&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;store&quot;:true, &quot;index&quot;:true, &quot;analyzer&quot;:&quot;standard&quot; &#125;, &quot;content&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;store&quot;:true, &quot;index&quot;:true, &quot;analyzer:&quot;standard&quot; &#125; &#125; &#125;&#125; 删除index 请求url 1delete http://127.0.0.1:9200/index1 -- 删除索引index1 创建文档document 请求url 1post http://127.0.01:9200/index1/tb1/1 --近似给数据库表中插入数据 body 12345&#123; &quot;id&quot;:1, &quot;title&quot;:&quot;震惊，LOL&quot;, &quot;content&quot;:&quot;LoL竟然有更新，没错，就是标题党，你来打我啊&quot;&#125; 修改文档document 请求url 1post http://127.0.01:9200/index1/tb1/1 -- 修改id为1的记录 body 12345&#123; &quot;id&quot;:1, &quot;title&quot;:&quot;指定修改的标题&quot;, &quot;content&quot;:&quot;指定修改的内容&quot;&#125; 删除文档document 请求url 1delete http://127.0.01:9200/index1/tb1/1 -- 删除记录1 查询文档-根据id查询 请求url 1get http://127.0.01:9200/index1/tb1/1 查询文档-querystring查询 请求url 1post http://127.0.01:9200/index1/tb1/_search body 12345678&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;defalut_field&quot;:&quot;title&quot;, &quot;query&quot;:&quot;英&quot; &#125; &#125;&#125; 查询文档-term查询 请求url 1post http://127.0.01:9200/index1/tb1/_search body 1234567&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;title&quot;:&quot;震&quot; &#125; &#125;&#125; 总结 对ES操作可以近似为对数据库的操作。RESTful的风格请求可以近似SQL语句。 对索引的操作—–近似—-&gt;对数据库的操作 对映射的操作—–近似—-&gt;对数据库表的操作 对文档操作—–近似—-&gt;对数据库记录的操作 5. 使用中文分词器ES默认的分词器是不支持中文分词的，如果想给中文分词要是用IKAnalyzer分词器进行分词。 下载IKAnalyzer https://github.com/medcl/elasticsearch-analysis-ik/ 解压并安装 将解压之后的elasticsearch文件夹放在ES安装目录下的plugins，重启服务。 测试中文分词器 请求url 1GET localhost:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=广东省位于中国东南部 如果结果出现广东等词语则表明使用中文分词器成功。 6. ES集群ES集群是一个P2P类型的分布式系统，除了集群状态管理以外，其他所有请求都可以发送到集群内的任意一台节点上，这个节点可以找到需要转发给哪些节点，并且直接跟这些节点通信。 集群的相关概念 集群cluster：一个集群由一个或者多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群 节点node：一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点 分片和复制：Lucene中有介绍 搭建集群 【1】创建文件夹、复制三份es服务。 ​ 复制时要确保已经把索引库删除完毕。 【2】给每台服务配置 123456789101112# 集群名称，保证唯一cluster.name: my-elasticsearch# 节点名称，必须不一样node.name: node-1# 所在主机的IP地址network.host: 127.0.0.1# 服务端口号，同一机器下是，必须不一样http.port: 9200/9201/9202# 集群间通信端口，同一机器必须不一样transport.tcp.port: 9300/9301/9302# 设置集群发现机器ip集合discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1:9300&quot;,&quot;127.0.0.1:9301&quot;,&quot;127.0.0.1:9302&quot;] 【3】启动每台服务 【4】使用postman添加索引 url 1PUT localhost:9200/blog1 body 12345678910111213141516171819202122232425&#123; &quot;mappings&quot;: &#123; &quot;article&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;long&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;not_analyzed&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;analyzed&quot;, &quot;analyzer&quot;:&quot;standard&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true, &quot;index&quot;:&quot;analyzed&quot;, &quot;analyzer&quot;:&quot;standard&quot; &#125; &#125; &#125; &#125;&#125; 【5】使用header查看效果 7. Java操作ES 依赖 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建索引 12345678910111213141516/** * 创建索引 * @throws UnknownHostException */@Testpublic void testCreateIndex() throws UnknownHostException &#123; //创建Client对象 Settings settings = Settings.builder() .put(&quot;cluster.name&quot;,&quot;my-elasticsearch&quot;).build(); TransportClient client = new PreBuiltTransportClient(settings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;),9300)); //创建名称为index1的索引 client.admin().indices().prepareCreate(&quot;index2&quot;).get(); //释放资源 client.close();&#125; 创建映射 12345678910111213141516171819202122232425@Testpublic void testCreateMapping() throws IOException, ExecutionException, InterruptedException &#123; XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .startObject(&quot;article&quot;) .startObject(&quot;properties&quot;) .startObject(&quot;id&quot;) .field(&quot;type&quot;,&quot;long&quot;).field(&quot;store&quot;,&quot;yes&quot;) .endObject() .startObject(&quot;title&quot;) .field(&quot;type&quot;,&quot;string&quot;).field(&quot;store&quot;,&quot;yes&quot;).field(&quot;analyzer&quot;,&quot;ik_smart&quot;) .endObject() .startObject(&quot;content&quot;) .field(&quot;type&quot;,&quot;string&quot;).field(&quot;store&quot;,&quot;yes&quot;).field(&quot;analyzer&quot;,&quot;ik_smart&quot;) .endObject() .endObject() .endObject() .endObject(); // 创建mapping PutMappingRequest mapping = Requests.putMappingRequest(&quot;index2&quot;) .type(&quot;article&quot;).source(builder); client.admin().indices().putMapping(mapping).get(); client.close();&#125; 创建文档 通过XcontentBuilder创建 123456789101112@Testpublic void createDocument() throws IOException &#123; XContentBuilder xContentBuilder = XContentFactory.jsonBuilder() .startObject() .field(&quot;id&quot;,1) .field(&quot;title&quot;,&quot;震惊！一拳超人竟然....&quot;) .field(&quot;content&quot;,&quot;一拳超人竟然出了第二季度动漫，每次就是来蹭热点的，不服来打我啊！哈哈哈&quot;) .endObject(); client.prepareIndex(&quot;index2&quot;,&quot;article&quot;,&quot;1&quot;).setSource(xContentBuilder).get(); //释放资源 client.close();&#125; 通过Jackson转换实体类创建文档 1）创建实体类 123456public class Article &#123; private Long id; private String title; private String content; // getter and setter&#125; 2）添加Jackson坐标 12345678910111213141516&lt;!--Jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt; 3）代码实现 123456789101112@Testpublic void createDocumentByJackson() throws JsonProcessingException &#123; Article article = new Article(); article.setId(2L); article.setTitle(&quot;新添加内容标题&quot;); article.setContent(&quot;新添加的内容！新添加的内容&quot;); ObjectMapper objectMapper = new ObjectMapper(); client.prepareIndex(&quot;index2&quot;,&quot;article&quot;, article.getId().toString()).setSource(objectMapper.writeValueAsString(article).getBytes(), XContentType.JSON).get(); client.close();&#125; 查询文档 根据id查询 1234567891011121314@Testpublic void queryDocumentById() &#123; SearchResponse response = client.prepareSearch(&quot;index2&quot;) .setTypes(&quot;article&quot;, &quot;content&quot;) .setQuery(QueryBuilders.idsQuery().addIds(&quot;1&quot;)) .get(); SearchHits hits = response.getHits(); System.out.println(&quot;总记录数：&quot; + hits.getTotalHits()); for (SearchHit hit : hits.getHits()) &#123; System.out.println(hit.getSourceAsString()); &#125;&#125; 根据关键词查找 12345678910111213141516@Testpublic void queryDocByKeyWord()&#123; SearchResponse response = client.prepareSearch(&quot;index2&quot;) .setTypes(&quot;article&quot;) .setQuery(QueryBuilders.termQuery(&quot;title&quot;, &quot;震惊&quot;)) .get(); SearchHits hits = response.getHits(); System.out.println(&quot;总记录数：&quot; + hits.getTotalHits()); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); while (iterator.hasNext())&#123; SearchHit next = iterator.next(); System.out.println(next.getSourceAsString()); &#125; client.close();&#125; 根据字符串模糊查询 123456789101112131415@Testpublic void queryDocByString()&#123; SearchResponse response = client.prepareSearch(&quot;index2&quot;) .setTypes(&quot;article&quot;) .setQuery(QueryBuilders.queryStringQuery(&quot;震惊党&quot;)).get(); SearchHits hits = response.getHits(); System.out.println(&quot;总记录数：&quot; + hits.getTotalHits()); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); while (iterator.hasNext())&#123; SearchHit next = iterator.next(); System.out.println(next.getSourceAsString()); System.out.println(&quot;-----------优雅的分割线------------&quot;); &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://tobing.top/tags/ElasticSearch/"},{"name":"全文检索","slug":"全文检索","permalink":"https://tobing.top/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"}]},{"title":"Spring-Security简单使用","slug":"Spring-Security简单使用","date":"2020-02-16T15:20:01.000Z","updated":"2021-01-15T03:21:46.989Z","comments":true,"path":"2020/02/16/Spring-Security简单使用/","link":"","permalink":"https://tobing.top/2020/02/16/Spring-Security%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"Spring-Security是Spring家族的重要一员。","text":"Spring-Security是Spring家族的重要一员。 Spring-Security简单使用1.简介Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于spring的应用程序的实际标准。 Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它很容易扩展以满足定制需求 2. 快速入门 导入SpringSecurity依赖 1234567891011&lt;!--其他所需依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在web配置文件中添加过滤器 123456789101112131415161718 &lt;!--.........--&gt; &lt;!--添加spring-security配置文件的解析--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--.........--&gt; &lt;!--添加spring-security所需的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--.........--&gt;&lt;/web-app&gt; 配置spring-security 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:security=&quot;http://www.springframework.org/schema/security&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;!-- 配置不过滤的资源（静态资源及登录相关） --&gt; &lt;security:http security=&quot;none&quot; pattern=&quot;/login.html&quot; /&gt; &lt;security:http security=&quot;none&quot; pattern=&quot;/failer.html&quot; /&gt; &lt;security:http auto-config=&quot;true&quot; use-expressions=&quot;false&quot; &gt; &lt;!-- 对所有的路径进行权限控制，只允许ROLE_USER可以访问 --&gt; &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt; &lt;security:logout invalidate-session=&quot;true&quot; logout-url=&quot;/logout&quot; logout-success-url=&quot;/login.jsp&quot; /&gt; &lt;!-- 关闭CSRF,默认是开启的 --&gt; &lt;security:csrf disabled=&quot;true&quot; /&gt; &lt;/security:http&gt; &lt;!--静态配置认证的用户及密码--&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name=&quot;user&quot; password=&quot;&#123;noop&#125;user&quot; authorities=&quot;ROLE_USER&quot; /&gt; &lt;security:user name=&quot;admin&quot; password=&quot;&#123;noop&#125;admin&quot; authorities=&quot;ROLE_ADMIN&quot; /&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt;&lt;/beans&gt; 运行Maven工程 运行工程时，首先会弹出一个要求输入用户名和密码的页面，这是spring-security为我们提供的默认的登录页面，当我们没有指定登录页面时会使用该页面。 输入用户名：admin，密码：admin时，会提示403，表示权限不足，这是因为上面配置的access角色需要是ROLE_USER 输入用户名：user，密码：user时，可以正常登录。 输入错误的用户名或者密码时，会提示账号或者密码错误信息。 3. 实战【ssm权限管理系统】 导入依赖 web配置文件中配置过滤器、spring-security的配置文件解析 配置spring-security 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:security=&quot;http://www.springframework.org/schema/security&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;!--配置不拦截的资源--&gt; &lt;security:http pattern=&quot;/login.jsp&quot; security=&quot;none&quot;/&gt; &lt;security:http pattern=&quot;/failer.jsp&quot; security=&quot;none&quot;/&gt; &lt;security:http pattern=&quot;/css/**&quot; security=&quot;none&quot;/&gt; &lt;security:http pattern=&quot;/img/**&quot; security=&quot;none&quot;/&gt; &lt;security:http pattern=&quot;/plugins/**&quot; security=&quot;none&quot;/&gt; &lt;!--配置具体--&gt; &lt;!--配值是否使用默认登录页面、不使用sepl表达式--&gt; &lt;security:http auto-config=&quot;true&quot; use-expressions=&quot;false&quot;&gt; &lt;!--配置拦截地址、可访问的角色--&gt; &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER,ROLE_ADMIN&quot;/&gt; &lt;!--定义跳转页面--&gt; &lt;!-- login-page=&quot;/login.jsp&quot; 指定默认的登录页面 login-processing-url=&quot;/login&quot; 指定登录页面登录的处理方法 default-target-url=&quot;index.jsp&quot; authentication-failure-url=&quot;/failer.jsp&quot; 指定失败跳转页面 authentication-success-forward-url=&quot;/pages/main.jsp&quot; 指定成功跳转页面 --&gt; &lt;security:form-login login-page=&quot;/login.jsp&quot; login-processing-url=&quot;/login&quot; default-target-url=&quot;/index.jsp&quot; authentication-failure-url=&quot;/failer.jsp&quot; authentication-success-forward-url=&quot;/pages/main.jsp&quot; /&gt; &lt;!--关闭跨越请求--&gt; &lt;security:csrf disabled=&quot;true&quot;/&gt; &lt;!-- 指定退出 --&gt; &lt;security:logout invalidate-session=&quot;true&quot; logout-url=&quot;/logout&quot; logout-success-url=&quot;/login.jsp&quot;/&gt; &lt;/security:http&gt; &lt;!--数据库方式验证--&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref=&quot;userLoginServiceImpl&quot;&gt; &lt;!--配置加密方式--&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt;&lt;/beans&gt; 配置不过滤的元素 配置可以访问的角色 配置登录页面、处理登录请求的方法，处理登录成功、登录失败跳转的页面等 配置处理请求的服务 将登陆请求的url指向前面定义的 login-processing-url参数 123&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;!--省略....--&gt;&lt;/form&gt; 创建处理登录请求的接口 创建UserLoginService继承继承自UserDtailsService接口 12public interface UserLoginService extends UserDetailsService &#123;&#125; 创建UserLoginService的实体类并重写方法 1234567891011121314151617181920212223242526@Service(&quot;userLoginServiceImpl&quot;)@Transactionalpublic class UserLoginServiceImpl implements UserLoginService &#123; @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; System.out.println(username); UserInfo userInfo = userDao.findUserByUsername(username); System.out.println(userInfo); List&lt;Role&gt; roles = userInfo.getRoles(); System.out.println(userInfo); List&lt;SimpleGrantedAuthority&gt; authorities = getAuthority(roles); User user = new User(userInfo.getUsername(),&quot;&#123;noop&#125;&quot;+userInfo.getPassword(),true,true,true,true,authorities); return user; &#125; private List&lt;SimpleGrantedAuthority&gt; getAuthority(List&lt;Role&gt; roles)&#123; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot;+role.getRoleName())); &#125; return authorities; &#125;&#125; 实战总结 【依赖以及web配置文件的配置】较为固定没有什么难度，不过给过滤器定义名称时要注意。 【Spring-security配置文件配置】根据需求定义访问的角色、结束登录请求的地址，登录的挑战等。 【接口的继承以及实现】记住要实现的接口，以及实现类实现方法的含义。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://tobing.top/tags/Spring/"},{"name":"Spring-Security","slug":"Spring-Security","permalink":"https://tobing.top/tags/Spring-Security/"}]},{"title":"PageHelper","slug":"PageHelper","date":"2020-02-13T03:40:36.000Z","updated":"2021-01-15T03:20:33.179Z","comments":true,"path":"2020/02/13/PageHelper/","link":"","permalink":"https://tobing.top/2020/02/13/PageHelper/","excerpt":"分页插件，可以帮助我们简化分页的逻辑。","text":"分页插件，可以帮助我们简化分页的逻辑。 PageHelper1. 简介PageHelper是国内优秀的开源的mybatis分页插件，支持主流常用的数据库。 【官网】https://pagehelper.github.io/ 2. 使用方法【Maven】 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 配置拦截器插件 特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 mybatis中xml配置 123456789101112131415&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; spring配置文件中配置拦截器插件 1234567891011121314&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 常用的配置： helperDialect：指定数据库，例如MySQL、db2、oracle reasonable：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一 页， pageNum&gt;pages （超过总数时），会查询最后一页。 常用方法 RowBounds方式的调用 1List&lt;Country&gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。 关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的 场景一 和 场景二 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如： 12//这种情况下也会进行物理分页查询List&lt;Country&gt; selectAll(RowBounds rowBounds); 注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的 PageRowBounds，这个对象中增加了 total 属性，执行分页查询后，可以从该属性得到查询总数。 PageHelper.startPage静态方法调用【重点】 1234//获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); //紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1); 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 3. 实战【权限系统】 导入PageHelper依赖 123456&lt;!--分页查询插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; spring中配置文件配置 123456789101112131415161718&lt;!--配置生产SqlSession的工厂--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--分页插件--&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;helperDialect&quot;&gt;mysql&lt;/prop&gt; &lt;prop key=&quot;reasonable&quot;&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; service中使用PageHelper.startPage方法 1234public List&lt;Orders&gt; findAllByPages(int start,int size) throws Exception&#123; PageHelper.startPage(start,size); return ordersDao.findAll(); &#125; 设置开始变化以及每页显示的大小 start：开始位置 size： 每页显示的条数 controller中使用PageInfo封装返回结果 12345678@RequestMapping(&quot;/findAllByPage.do&quot;)public String findAllByPage(@RequestParam(required = true,value = &quot;start&quot;,defaultValue = &quot;1&quot;) int start, @RequestParam(required = true,value = &quot;size&quot;,defaultValue = &quot;4&quot;) int size, Model model) throws Exception &#123; List&lt;Orders&gt; all = ordersService.findAllByPages(start,size); PageInfo pageInfo = new PageInfo(all); model.addAttribute(&quot;pageInfo&quot;,pageInfo); return &quot;orders-list&quot;;&#125; 此处将PageHelper根据查询的List结合传入的开始位置以及每页大小封装的PageInfo对象中，返回的到jsp页面中。 4. PageInfo PageInfo对象封装了分页查询的诸多信息。包括查询到的对象集合，页面大小，总数等等。 PageInfo部分源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PageInfo&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中&quot;显示startRow到endRow 共size条数据&quot; //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //前一页 private int prePage; //下一页 private int nextPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; //导航条上的第一页 private int navigateFirstPage; //导航条上的最后一页 private int navigateLastPage;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"},{"name":"PageHelper","slug":"PageHelper","permalink":"https://tobing.top/tags/PageHelper/"}]},{"title":"2019","slug":"2019","date":"2020-02-02T17:36:03.000Z","updated":"2021-01-15T03:32:10.271Z","comments":true,"path":"2020/02/03/2019/","link":"","permalink":"https://tobing.top/2020/02/03/2019/","excerpt":"​ 正月初九是家乡的年例，但是因为肺炎的原因，本应该是一年中最热闹的一天，在今年却显得格外冷清，希望国家早日战胜这场无硝烟的战役。","text":"​ 正月初九是家乡的年例，但是因为肺炎的原因，本应该是一年中最热闹的一天，在今年却显得格外冷清，希望国家早日战胜这场无硝烟的战役。 2019迟到的2019总结​ 正月初九是家乡的年例，但是因为肺炎的原因，本应该是一年中最热闹的一天，在今年却显得格外冷清，希望国家早日战胜这场无硝烟的战役。 ​ 年总结很早就想写了，但是身患重度拖延症的我通过一次一次的借口，成功骗了自己一次又一次，由于今年年例格外冷清（写代码写腻了），趁此机会回顾一下这一年自己发生的事。 ​ 首先，在2019年中对我自己大学、乃至接下来的人生轨迹影响最大的莫过于转专业成功了。2019.1.25日，我通转专业查询，确认了自己转入了目标的专业，而我的故事也由材料院转到了计科院。作为一个重度的计算机爱好者，从初一有了人生中第一台amd的512MB内存的台式机，我便于计算机接下了梁子。而在初二时，更是无意中搞坏了当时的xp系统，懵懂的我通过wb了解到了可以通过启动盘修复。从此，我与计算机结下了更深的梁子【期间还手欠把CPU针脚弄坏】。也许正因为当时对计算机的喜爱，把学习的注意力转移了，我考大学时被调剂到了材料院。但也是因为对计算机的热爱，成为了我从成功转到计科院的动力。在大一上学期，和寝室的三个志同道合的老哥：基佬，腰缠万贯，大表哥，一起都顺利的转入了计科院。而有幸的是，现在我们仍然在一个寝室。 ​ 【大一下】在转入计科院之后，我遇到了很多的新同学，也学习到了很多的新知识。受益于大一上学期的学习习惯，我和寝室的另外两位老哥组成的三剑客从一开始便包揽了教室的第一排，这使得我很快便可以跟上计科院的课程。也得益于在初中高中的计算机知识，我在转专业之后的一个学期内，基本把课程的跟上，即使可能很多专业知识于他们还相差甚远。在大一下期间，对我影响最大的莫过于：了解到别人的强大、认识到了自己的弱点。这个学期，随着对计算机专业知识的学习，发现自己在初中高中学习到的根本就是皮毛，人家通过大一的一学期，早已经远超出了我初中高中几个寒暑假的学习。于是，在大一下结束，我便开始了自己的留校计划。 ​ 【暑假】大一下的程序设计综合实践做完后，我又搬起了自己曾无数次徘徊于基础中的基础–Java。得益于教程的优良以及寝室环境的优美，我利用暑假在校的一个月，成功超越了之前初高中无法逾越的壕沟。也这是这一个月，我也开始对自己的学习方式逐渐有了固定套路。在回家之后暑假，尽管经常要带带孩子、打打游戏，但还是保留了学习的习惯，而且效率也不算很低。总体来说，这是一个比较充实的暑假。 ​ 【大二上】得益于暑假的学习，大二上的专业课并没有太大困难，这使得我可以花更多的时间在非专业课上，加上自己比较努力，学习上没有遇到很多问题。硬要说学习上有什么问题，那便是物理实验：课时占用多、上课时间反人类、选课反人类、考核反人类。但是总的来说大二上的学习并没有对我造成很大的困扰。 ​ 然而，虽然学习上没有遇到很大问题，但在非学习上，我做出了很大的改变。首先就是我鼓起了勇气踏出了那一步，虽然以失败告终，而且也是意料之中，但这样我仍然花了大量时间才走出阴霾。再者，我加入了网信中心，在那里面，除了认识更多的朋友，最重要的便是可以锻炼我的语言表达能力。总之、大二下对我非学习的影响是很大的。 ​ 【最后】纵观这一年，也许是运气好，我在学习上没有很多的困扰，最起码没有挂科。在学习之外，我也收获到了很多，认识了自己的不足，也想着要改变。 ​ 【期望】在接下来不平凡的2020年，我希望自己继续保持积极乐观的心态，走出自己的舒适区。同时希望自己能够养成自己的一技之长。最后更是希望国家和平、安定。 tobing 2020.1.2","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://tobing.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://tobing.top/tags/%E6%80%BB%E7%BB%93/"},{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"}]},{"title":"Oracle-下","slug":"Oracle-下","date":"2020-01-21T16:35:16.000Z","updated":"2021-01-15T03:20:58.704Z","comments":true,"path":"2020/01/22/Oracle-下/","link":"","permalink":"https://tobing.top/2020/01/22/Oracle-%E4%B8%8B/","excerpt":"Oracle数据库第二弹。","text":"Oracle数据库第二弹。 Oracle-下1. 视图 视图就是提供一个查询的窗口，所有数据来自于原表 数据准备 12-- 查询语句创建表create table emp as select * from scott.emp; 视图操作 12345678-- 创建视图【必须要dba权限】create view v_emp as select ename,job from emp;-- 查询视图select * from v_emp;-- 修改视图【不推荐】udpate v_emp set job=&#x27;LER&#x27; where ename=&#x27;ALLEN&#x27;;-- 创建只读视图【一般设置为只读】create view v_emp1 as select ename,job from emp with read only; 视图的作用： 1. 视图可以屏蔽一些敏感字段。 2. 保证总部和分部数据及时统一。 2. 索引 索引就是在表的列上构建一个二叉树，从而达到大大提高查询效率的目的。 但是索引会影响增删改的效率。 单列索引 12-- 创建单列索引create index idx_ename on emp(ename); 单列索引触发规则，条件必须是索引列中的原始值。 单列函数，模糊查询，都会影响索引的触发 复合索引 12-- 创建复合索引create index idx_enamejob on emp(ename,job); 复合索引中第一列为优先检索列。 如果要触发复合索引，必须包含有优先索引中的原始值。 123select * from emp where ename = &#x27;SCOTT&#x27; and job=&#x27;xx&#x27;; -- 触发复合索引select * from emp where job = &#x27;xx&#x27;; -- 不触发索引select * from emp where ename = &quot;SCOTT&quot;; -- 触发单列索引 3. pl/sql编程语言 是对sql语言的扩展，使得sql语言具有过程化编程的特性。 比一般过程编程语言，更加灵活高效。 主要用来编写存储过程和存储函数等。 声明方法 赋值操作可以使用**:=**，也可以使用into查询语句赋值。 123456789101112131415declare -- 变量声明 i number(2) :&#x3D; 10; s varchar(10) :&#x3D;&#39;tobing&#39;; ena emp.ename%type; --引用型变量 emprow emp%rowtype; --记录型变量begin dbms_output.put_line(i); dbms_output.put_line(s); -- 应用型变量赋值 select ename into ena from emp where empno &#x3D; 7788; -- 记录型变量赋值 select * into emprow from emp where empno &#x3D; 7788; dbms_output.put_line(emprow.ename||&#39;工作为：&#39;||emprow.job);end; if判断 1234567891011121314-- 输入小于18的数字，输入‘less than 18’-- 输入大于18小于40的数字，输出‘18·40’-- 输入大于40的数字，输出‘older than 40’declare i number(3) :&#x3D;&amp;ii;begin if i&lt;18 then dbms_output.put_line(&#39;less than 18&#39;); elsif i&lt;40 then dbms_output.put_line(&#39;18-40&#39;); else dbms_output.put_line(&#39;older than 40&#39;); end if;end; while循环 循环输出1-10数值 12345678declare i number(1) :&#x3D; 1;begin while i&lt;11 loop dbms_output.put_line(i); i:&#x3D;i+1; end loop;end; exit循环【重点掌握】 123456789declare i number(1) :&#x3D;1;begin loop exit when i&gt;10; dbms_output.put_line(i); i:&#x3D;i+1; end loopend; for循环 1234567declare begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; 游标 可以存放多个对象，多行记录 123456789101112131415161718192021222324252627282930-- 输出emp表中所有员工姓名declare cursor c1 is select * from emp; -- 存储emp表所有记录 emprow emp%rowtype; -- 存储一行的变量begin open c1; loop fetch c1 into emprow; -- 取出c1中每行记录，存储到emprow中 exit when c1%nutfound; -- 结束标志 dbms_output.put_line(emprow.ename); -- 输出 end loop; close c1;end;-- 给指定部门涨工资declare -- 获取指定部门的所有empno cursor c2(eno emp.deptno%type) is select empno from emp where deptno &#x3D; eno; -- 用于存储每次获取到的empno en emp.empno%type;begin open c2(10); -- 获取10部门的所有empno loop fetch c2 into en; -- 循环取出10部门的empno exit when c2%notfound; -- 循环结束标志 update emp set sal&#x3D;sal+10 where cempno&#x3D;en; -- 通过取出的empno进行操作 end loop; close c2;end; 4. 存储过程 存储过程就是提前已经编译好的一段pl/sql语言，放置在数据库端，可以直接调用。 这一段pl/sql一般都是固定步骤的业务。 1234567891011121314--给指定员工涨100块--1.定义存储过程create or replace procedure p1(eno emp.empno%emp)isbegin update emp set sal&#x3D;sal+100 where empno &#x3D; eno; commitend;-- 2.使用存储过程declarebegin p1(7788); -- 调用存储过程，相当于给empno为7788的员工工资加100end; 5. 存储函数123456789101112131415161718--通过存储函数实现计算指定员工的年薪--1.定义存储函数create or replace function f_yearsal(eno emp.emono%type) return numberis s number(10);begin --将查询到的年薪记录在s select sal*12+nvl(comm,0) into s from emp where empno&#x3D;eno; --返回s return s;end;--2.使用存储函数declare s number(10);begin s:&#x3D;f_yearsal(7788); dbms_output.put_line(s);end; 存储过程和存储函数的参数都不能带长度。 存储函数的返回值不能带长度。 存储过程和存储函数的区别 语法区别：关键字不一样，存储函数比存储过程多了两个return 本质区别： 存储函数有返回值，而存储过程没有返回值。 如果存储过程想实现返回值的业务，必须要使用out类型的参数 即使是存储过程使用了out类型的参数，其本质也不是真的有了返回值 而是在存储过程内部给out类型参数赋值，在执行完毕后，我们直接拿到输出参数类型的值。 可以利用存储函数的特性，封装为一个函数。提供查询语句使用 123456789101112131415161718-- 需求：查询员工姓名及其对应部门-- 1.常规方法select e.ename,d.dnamefrom emp e,dept dwhere e.deptno = d.deptno;-- 2. 定义函数+查询-- 2.1定义存储函数：根据deptno查询dnamecreate or replace function f_dna(eno emp.empno%type) return dept.dname%typeis dna dept.dname%type; -- 存储查询到的dnamebegin -- 查询dname，并返回 select dname into dna from dept where deptno = eno; return dna;end;-- 2.2调用select e.ename ,f_dna(e.deptno)from emp e; 6. out类型1234567891011121314151617--使用存储过程来算年薪--1.定义存储过程create or replace procedure p_yearsal(eno emp.empno%type,yearsal out number)is s number(10); c emp.comm%type;begin select sal*12,nvl(comm,0) into s,c from emp where empno &#x3D; eno; yearsal &#x3D; s + c;end;--2.使用存储过程declare yearsal number(10);begin p_yearsal(7788,yearsal); dbms_output.put_line(yearsal);end; in和out类型参数的区别是什么？ 凡是涉及到into查询语句赋值或者:=赋值操作的参数，都必须使用out来修饰。 7. 触发器 触发器就是一个规则，在我们增删改操作的时候，只要满足规则，自动触发，无需调用。 分类 语句级触发器：不包含for each row的触发器。 行级触发器：包含了for each row的就是行级触发器。 加for each row 是为了使用:old或者:new对象或者一行记录 语句级触发器 1234567891011121314151617---需求：插入一条记录，输出一个“新员工入职”---分析：insert、操作之后、监听的表--创建触发器create or replace trigger t1after inserton persondeclarebegin dbms_output.put_line(&#39;一个新员工入职&#39;);end;--触发t1insert into person value(10,&#39;zenyet&#39;);commit 行级触发器 123456789101112131415161718192021---需求：不能给员工降薪---分析：update、操作之前、监听表--创建触发器create or replace trigger t2beforeupdateon personfor each rowdeclarebegin if :old.sal&gt;:new.sal then --抛出异常阻止执行 raise_application_error(-20001,&#39;不能给员工降薪&#39;); end if;end;--触发t2update emp set sal&#x3D;sal-1 where empno&#x3D;7788;commit; raise_application_error(-20001~-20999,’错误提示信息’); 触发器应用 12345678910111213141516171819---需求：实现主键自增长---分析：insert、插入之后、监听表--创建触发器create or replace triggle t3beforeinserton personfor each rowdeclarebegin select s_person.nextval into:new.pid from dual;end;--触发t3insert into emp(ename) values(&#39;zzz&#39;);commit; 8. Java操作Oracle Maven环境下使用Java连接Oracle执行SQL语句。 普通SQL语句 pom.xml 1234567891011121314&lt;dependencies&gt; &lt;!--连接oracle--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;10.2.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 测试方法 1234567891011121314151617181920212223242526272829public class OJdbcTest &#123; /** * 测试直接执行SQL语句 * @throws Exception */ @Test public void ojdbcCallTrodiction() throws Exception &#123; //1.注册驱动 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获取连接 Connection connection = DriverManager.getConnection(&quot;jdbc:oracle:thin:@192.168.106.10:1521:orcl&quot;, &quot;tobing&quot;, &quot;tobing&quot;); //3.获取预处理对象 PreparedStatement pstmt = connection.prepareStatement(&quot;select * from emp where empno=?&quot;); //4.设置参数 pstmt.setObject(1,7788); //5.执行查询 ResultSet rs = pstmt.executeQuery(); //6.遍历结果集 while(rs.next())&#123; String ename = rs.getString(&quot;ename&quot;); System.out.println(ename); &#125; //7.关闭资源 rs.close(); pstmt.close(); connection.close(); &#125;&#125; 存储过程 1234567891011121314151617181920212223/** * 调用存储过程 * @throws Exception */@Testpublic void ojdbcCallProcedure() throws Exception &#123; //1.注册驱动 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获取连接 Connection connection = DriverManager.getConnection(&quot;jdbc:oracle:thin:@192.168.106.10:1521:orcl&quot;, &quot;tobing&quot;, &quot;tobing&quot;); //3.获取预处理对象 CallableStatement cstat = connection.prepareCall(&quot;&#123; call p2(?,?) &#125;&quot;); //4.设置参数 cstat.setObject(1,7788); cstat.registerOutParameter(2, OracleTypes.NUMBER); //5.执行完毕 cstat.execute(); System.out.println(&quot;执行完毕&quot;); System.out.println(&quot;年薪为：&quot;+cstat.getObject(2)); //6.关闭资源 cstat.close(); connection.close();&#125; 存储函数 1234567891011121314151617181920212223/** * 测试调用存储函数 * @throws Exception */@Testpublic void ojdbcCallFunction() throws Exception &#123; //1.注册驱动 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获取连接 Connection connection = DriverManager.getConnection(&quot;jdbc:oracle:thin:@192.168.106.10:1521:orcl&quot;, &quot;tobing&quot;, &quot;tobing&quot;); //3.获取预处理对象 CallableStatement cstat = connection.prepareCall(&quot;&#123; ?=call f_yearsal(?) &#125;&quot;); //4.设置参数 cstat.setObject(2,7788); cstat.registerOutParameter(1, OracleTypes.NUMBER); //5.执行完毕 cstat.execute(); System.out.println(&quot;执行完毕&quot;); System.out.println(&quot;年薪为：&quot;+cstat.getObject(1)); //6.关闭资源 cstat.close(); connection.close();&#125; CallableStatment接口 CallableStatement是PreparedStatement子接口，是用于执行 SQL 存储过程的接口。 JDBC API 提供了一个存储过程 SQL 转义语法，该语法允许对所有 RDBMS 使用标准方式调用存储过程。此转义语法有一个包含结果参数的形式和一个不包含结果参数的形式。如果使用结果参数，则必须将其注册为 OUT 参数。其他参数可用于输入、输出或同时用于二者。参数是根据编号按顺序引用的，第一个参数的编号是 1。 {?= call [(,, …)]} {call [(,, …)]}","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://tobing.top/tags/Oracle/"}]},{"title":"Oracle-上","slug":"Oracle-上","date":"2020-01-19T15:22:49.000Z","updated":"2021-01-15T03:19:49.083Z","comments":true,"path":"2020/01/19/Oracle-上/","link":"","permalink":"https://tobing.top/2020/01/19/Oracle-%E4%B8%8A/","excerpt":"Oracle学习第一弹。","text":"Oracle学习第一弹。 Oracle-上1. 基本使用 创建表空间，并给表空间指定用户 123456789101112131415161718--创建表空间create tablespace tbspace --指定表空间名称datafile &#x27;c:\\tbspace.dbf&#x27; --指定表空间存储文件size 100m --指定初始大小autoextend on --指定自增长next 10m; --指定每次自增长大小--创建用户create user tobing --指定用户名identified by tobing --指定用户密码default tablespace tbspace; --指定使用的表--给用户授权--Oracle中常用角色connect --连接角色（基本角色）resource--开发者角色dba --超级管理员角色grant dba to tobing; -- 给tobing授权超级管理员角色 表结构的操作 1234567891011--创建表create table person( -- 创建person表 pid number(20), pname varchar2(10));--修改表结构alter table person add (gender number(1)); --添加一行alter table person modify gender char(1); --修改列类型alter table person rename column gender to sex; --修改类名称alter table person drop column sex; --删除一列 表数据的操作 12345678910111213141516--查询表中记录select * from person;---添加一条记录insert into person (pid,pname) values(1,&#x27;tobing&#x27;);commit;---修改一条记录update person set pname =&#x27;扶上梁&#x27; where pid = 1;commit;--三个删除---删除表中所有记录delete from person;---删除表结构drop table person;---先删除表，再创建表效果等于删除表中所有记录truncate table person; 在对表中数据进行增删改操作的时候，需要手动将事务提交，否则可能会导致操作的丢失。Oracle的默认事务隔离级别和MySQL是不一样的。 delete和truncate两种方式删除表中所有数据底层的实现原理是不一样的。delete是直接删除表中的记录，而truncate是先删除整个表结构，然后再创建一样的表结构。 在数据量比较大，特别是含有索引的表中，使用truncate方式效率远大于delete方式。 序列 序列不真的属于任何一张表，但是可以逻辑和表做绑点。 默认从1开始，依次递增，主要用来主键赋值使用。 dual：虚表，只是为了补全语法，没有任何意义。 1234567create sequence s_person;select s_person.nextval from dual;--序列使用insert into person(pid,pname) values(s_person.nextval,&#x27;小明&#x27;);commit;--查询效果select * from person; scott用户 scott是Oracle提供给初学者研究学习的一张表。 1234--解锁scott表alter user scott account unlock;--解锁scoot密码【也可以用于重置密码】alter user scott identified by tiger; 2. 单行函数 单行函数作用于一行，放回一个值 字符函数 1234-- upper()：将字符转换为大写select upper(&quot;tobing&quot;) from dual; -- 输出TOBING-- lowwer()：将字符转换为小写select lowwer(&quot;TOBING&quot;) from dual; -- 输出tobing 数值函数 123456-- round(number,n) 将数值保留n位（负数表示小数点前面）四舍五入select round(12,56,0) from dual; -- 输出13-- trunc(number,n) 直接将数值截断，保留n位select trunc(12,56,0) from dual; -- 输出12-- mod(number,n) 将number对n取余数select mod(10,3) from dual; -- 输出1 日期函数 12345678910-- 查询emp表中所有员工入职距离现在几天select sysdate-e.hiredate from emp e;-- 算出明天此刻select sysdate+1 from dual;-- 查询emp表中所有员工入职距离现在几月select months_between(sysdate-e.hiredate)from emp e;-- 查询emp表中所有员工入职距离现在几年select months_between(sysdate-e.hiredate)/12 from emp e;-- 查询emp表中所有员工入职距离现在几周select sysdate-e.hiredate/7 from emp e; 转换函数 1234567-- to_char(date,regex) 日期转字符串-- fm：表示不用0补位-- mi：分钟，由于不区分大小写，需要使用mi与mm区别-- hh24：使用24小时方式显示select to_char(sysdate,&quot;fm yyyy-mm-dd hh24:mi:ss&quot; ) from dual;-- to_date(char,regex) 字符串转日期select to_date(&quot;2018-12-12 12:12:12&quot;,&quot;fm yyyy-mm-dd hh24:mi:ss&quot;) from dual; 通用函数 1234-- 算出emp表中所有员工的年薪（月新*12+奖金）-- 存在问题：有点员工奖金为null，直接跟null运算结果是null-- 如何解决：使用nvl(value,number),如果value为null，使number替换select e.sal*12+nvl(e.comm,0) from emp e; 3. 条件表达式 通用用法 适用于Oracle和mysql 123456789101112131415161718-- 需求1：给emp表中的员工名称起中文名select e.ename, case e.ename when &#x27;SMITH&#x27; then &#x27;张三丰&#x27; when &#x27;ALLEN&#x27; then &#x27;张无忌&#x27; when &#x27;WARD&#x27; then &#x27;张翠山&#x27; else &#x27;无名&#x27; -- 可以省略 end -- 结束标记，不要忘记from emp e;-- 需求2：判断emp表中员工，&gt;3000为高收入，1500-3000为中等收入，其余为低收入select e.sal case then e.sal&gt;3000 then &#x27;高收入&#x27; then e.sal&gt;1500 then &#x27;中等收入&#x27; else &#x27;低收入&#x27; endfrom emp e; Oracle特有 oracle中除了取别名，动用单引号 1234-- 需求1：给emp表中的员工名称起中文名select e.ename decode(e.name,&#x27;SMITH&#x27;,&#x27;张三丰&#x27;,&#x27;WARD&#x27;,&#x27;张无忌&#x27;,&#x27;无名&#x27;) 中文名from emp e; 4. 多行函数 多行函数【聚合函数】：作用于多行，返回一个值。 12345select count(1) from emp; -- 查询总数量select max(sal) from emp; -- 查询最高工资select min(sal) from emp; -- 查询最低工作select sum(sal) from emp; -- 查询工作总和select avg(sal) from emp; -- 查询平均工资 5. 分组查询 分组查询常常可以结合聚合函数进行查询 查询出每个部门的平均工资 123select e.deptno, avg(e.sal) from emp egroup by e.deptno; 分组查询中，出现在group by后面的原始列才可以出现在select后面。 分组查询中，没有出现在group by后面的列，想在select之后出现，只能加上聚合函数。 123select e.deptno, e.salfrom emp egroup by e.deptno; 以上写法是错误的。因为分组后的结果是多行的，无法判断是哪一行的sal。 查询出平均工资高于2000的部门信息 1234select e.deptno,avg(e.sal)from emp egroup by e.deptnohaving avg(e.sal)&gt;2000; having用于过滤分组之后的数据 查询出每个部门工资高于800的平均工资 1234select e.deptno,avg(e.sal)from emp ewhere e.sal&gt;800group by e.deptno where用于过滤分组之前的数据 查询出每个部门员工工资高于800的平均工资且平均工资高于2000的部门 12345select e.deptno,e.salfrom emp ewhere e.sal&gt;800group by e.deptnohaving avg(e.sal)&gt;200 where 必须位于group by之前，having 必须位于group by之后 6. 多表查询0. 笛卡尔积 直接的无条件多表查询返回的结果是笛卡尔积（表间数据类的排列组合），笛卡尔积的很多内容往往是无效的，需要通过某些条件进行过滤。 1. 内连接和等值连接 等值连接 1234-- 查询出emp表中员工所有信息（员工的部门信息在dept表中）select *from emp e,dept dwhere e.deptno = d.deptno 使用where作为条件判断关键词。【推荐使用】 内连接 1234-- 查询出emp表中员工所有信息（员工的部门信息在dept表中）select *from emp e inner join dept don e.deptno = d.deptno 早期的写法，推荐使用等值连接的方式将其替换 2. 外连接 外连接可以解决多表中，要查询某一个表中的所有数据，而该数据与其他表无映射关系时的问题。 通用外连接 外连接有左外连接和右外连接之分。左右只是相对的概念。 123456789-- 查询出所有部门信息，以及部门下的员工【有的部门可能没有对应员工】select *from emp e right join dept don e.deptno = d.dpetno;-- 查询出所有员工信息，已经员工对应的部门【员工可能没有对应部门】select *from emp e left join dept don e.deptno = d.deptno; Oracle特有外连接 123456789-- 查询出所有部门信息，以及部门下的员工【有的部门可能没有对应员工】select *from emp e,dept dwhere e.deptno(+) = d.deptno-- 查询出所有员工信息，已经员工对应的部门【员工可能没有对应部门】select *from emp e,dept dwhere e.deptno = d.deptno(+) 注意（+）的位置 3. 自连接 自连接：就是站在不同角度把一张表看成多张表 12345678910-- 查询出员工姓名，员工领导姓名【员工，员工领导在同一张表】select e1.ename,e2.enamefrom emp e1,emp e2where e1.mgr = e2.empno-- 查询出员工姓名，员工部门名称，员工领导姓名，员工领导部门名称select e1.enam, d1.dname,e2.ename,d2 dnamefrom emp e1,dept d1,emp e2,dept d2where e1.mgr = e2.empno and e1.deptno = d1.deptno and e2.deptno = d2.deptno; 3. 子查询 子查询返回一个值 1234--查询与scott一样工资的员工的信息select * from emp where name in( select sal from emp where name =&#x27;scott&#x27;); 为避免scott不唯一导致问题，使用in而不是= 子查询返回一个集合 1234--查询出工资和10号部门任意员工一样的员工信息select * from emp where sal in( select sal from emp where depton = 10 ); 子查询返回一张表 12345678910111213141516--查询出每个部门的最低工资，和最低工资员工姓名，和该员工所在部门名称--1. 查询出每个部门及其对应的最低工资select e.deptno,min(e.sal)from emp egroup by e.deptno--2. 三表联查，得到最后结果select t.deptno, t.msal e.ename, dept.dnamefrom (select deptno,min(e.sal) msal from emp group by deptno) t,emp e,dept dwhere t.deptno = e.deptno, and t.msal = e.sal, and e.deptno = d.deptno; 4. 分页查询 行号rownum 当我们使用select操作的时候，每查询出一行记录，就会在该行上加上一个行号。 行号从1开始，依次递增，不能跳着走。 12345678--以下sql语句是先查询出来数据，再排序--由于查询数据时rownum已经存在，再排序会导致rownum是乱序的select rownum,e.* from emp e order by sal desc;--解决办法：嵌套查询select rownum,e.*from (select * from emp order by sal desc) e; 分页查询 123456--emp表工资倒序排列后，每页显示5条，查询第2页select * from( select rownum rn,tt.* from( select * from emp order by sal desc )tt where rownum&lt;11)where rn&gt;5 rownum行号不能写上大于一个正数","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://tobing.top/tags/Oracle/"}]},{"title":"SpringMVC-3-响应数据与文件上传","slug":"SpringMVC-3-响应数据与文件上传","date":"2020-01-07T11:29:33.000Z","updated":"2021-01-15T03:54:24.766Z","comments":true,"path":"2020/01/07/SpringMVC-3-响应数据与文件上传/","link":"","permalink":"https://tobing.top/2020/01/07/SpringMVC-3-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"SpringMVC第三弹。","text":"SpringMVC第三弹。 SpringMVC-3-响应数据与文件上传1. 响应数据 在使用SpringMVC响应数据时，控制器（controller）的返回值可以有三种。 字符串 controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 12345678910@RequestMapping(&quot;/sayHello&quot;) public String sayHello(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(&quot;sayHello方法执行了&quot;); User user = new User(); user.setUsername(&quot;Tobing&quot;); user.setPassword(&quot;root&quot;); user.setAge(19); request.setAttribute(&quot;user&quot;,user); return &quot;success&quot;; // 此处转发到success.jsp &#125; 执行原理 void 可以使用Servlet原生的API作为控制器参数，通过request和response对象进行转发或重定向 123456789101112@RequestMapping(&quot;/sayVoid&quot;)public void sayVoid(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(&quot;sayVoid方法执行了&quot;); //1.使用request转向页面 //request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response); //2.通过Response页面重定向 //response.sendRedirect(&quot;sayHello&quot;); //3.通过request直接写入响应结果 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;Hello World!!!&quot;);&#125; ModelAndView SpringMVC还提供ModelAndView对象可以用作控制器返回值。 123456789101112@RequestMapping(&quot;/testReturnModelAndView&quot;)public ModelAndView testReturnModelAndView()&#123; System.out.println(&quot;testReturnModelAndView方法执行了&quot;); ModelAndView mv = new ModelAndView(); User user = new User(); user.setUsername(&quot;Tobing&quot;); user.setPassword(&quot;root&quot;); user.setAge(19); mv.addObject(&quot;user&quot;,user); mv.setViewName(&quot;success&quot;); // 设置逻辑视图名称，视图解析器会根据名称前往指定视图 return mv;&#125; ModelAndView对象提供addObject方法可以将Object类型的对象封装到request域中。同时提供setViewName方法设置逻辑视图名称，这时视图解析器就可以根据名前往指定视图。 转发和重定向 controller方法在使用String返回值时，支持使用forward（转发）和redirect（重定向）关键字进行响应。 123456789@RequestMapping(&quot;testForwardOrRedirect&quot;)public String testForwardOrRedirect(HttpServletRequest request)&#123; User user = new User(); user.setUsername(&quot;actogo&quot;); user.setPassword(&quot;root&quot;); user.setAge(19); //return &quot;forward:/WEB-INF/pages/success.jsp&quot;; // 相当于request.getRequestDispatchet(&quot;url&quot;).forward(request,response); return &quot;redirect:sayHello&quot;;&#125; 2. 响应json数据 前端页面的ajax请求，发送json数据 12345678910111213141516171819202122232425&lt;body&gt; &lt;script&gt; $(function()&#123; $(&quot;#btn&quot;).click(function()&#123; // 点击按钮发送ajax请求 $.ajax(&#123; url:&quot;user/testJson&quot;, // 设置请求url //设置数据类型 contentType:&quot;application/json;charset=UTF-8&quot;, //设置数据 data:&#x27;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&#x27;, dataType:&quot;json&quot;, // 数据封装类型 type:&quot;post&quot;, // 数据提交方式 success:function(data)&#123; // data:服务器端响应的json的数据，进行解析 alert(data.username); alert(data.password); alert(data.age); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;&lt;/body&gt; 后端控制器使用RequestBody注解将json数据封装到指定JavaBean，使用ResponseBody注解将返回的JavaBean封装为json返回。 1234567891011@RequestMapping(&quot;testJson&quot;)public @ResponseBody User testJson(@RequestBody User user) &#123; // 输出RequestBody封装的JavaBean System.out.println(user); // 处理数据 user.setUsername(&quot;actogo&quot;); user.setAge(20); user.setPassword(&quot;root&quot;); // 返回数据 return user;&#125; 3. SpringMVC实现文件上传","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://tobing.top/tags/SpringMVC/"}]},{"title":"SpringMVC-2-参数绑定与常用注解","slug":"SpringMVC-2-参数绑定与常用注解","date":"2020-01-07T11:29:07.000Z","updated":"2021-01-15T03:18:48.759Z","comments":true,"path":"2020/01/07/SpringMVC-2-参数绑定与常用注解/","link":"","permalink":"https://tobing.top/2020/01/07/SpringMVC-2-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"SpringMVC第二弹。","text":"SpringMVC第二弹。 SpringMVC-2-参数绑定与常用注解1. 参数绑定 表单中的请求参数都是基于键值对的。SpringMVC绑定请求参数的过程是：把表单的请求参数作为控制器中方法的参数进行绑定。 SpingMVC请求参数的绑定是自动实现的，但要遵守规范。 1. 基本类型参数绑定 包含了基本数据类型和String类型 规范：参数名称必须和控制器方法参数一致，且严格区分大小写。 1&lt;a href=&quot;params/getUsername?username=tobing&quot;&gt;测试普通数据类型绑定&lt;/a&gt; 123456789@Controller(&quot;paramsController&quot;)@RequestMapping(&quot;/params&quot;)public class ParamsController &#123; @RequestMapping(value = &quot;/getUsername&quot;) public String getUsername(String username)&#123; System.out.println(&quot;用户名为：&quot;+username); return &quot;success&quot;; &#125;&#125; 2. POJO类型参数绑定 包含了自定义实体类，以及其中关联的实体类 规范：参数名称必须和实体类属性名称一致，且控制器方法参数就是实体类。 12345678 测试JavaBean类型绑定&lt;form method=&quot;post&quot; action=&quot;params/getUser&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br&gt; 账户密码：&lt;input type=&quot;text&quot; name=&quot;account.apwd&quot;/&gt;&lt;br&gt; 账户余额：&lt;input type=&quot;text&quot; name=&quot;account.money&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 1234567891011121314151617181920212223// JavaBeanpublic class User &#123; private String username; private String password; private Account account; // setter、getter and toString&#125;public class Account &#123; private String apwd; private Float money; // setter、getter and toString&#125;// Controller@Controller(&quot;paramsController&quot;)@RequestMapping(&quot;/params&quot;)public class ParamsController &#123; @RequestMapping(value = &quot;/getUser&quot;) public String getUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; 3. 数组和集合类型参数绑定 包括了List结构和Map结构 规范：集合类型请求参数必须在实体类中，且请求参数名称要和实体类的属性名称一致。 List：使用下标 Map：使用键值对 12345678910参数绑定map和list&lt;form method=&quot;post&quot; action=&quot;params/getUser&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br&gt; 账户密码：&lt;input type=&quot;text&quot; name=&quot;accounts[0].apwd&quot;/&gt;&lt;br&gt; 账户余额：&lt;input type=&quot;text&quot; name=&quot;accounts[0].money&quot;/&gt;&lt;br&gt; 账户密码：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#x27;one&#x27;].apwd&quot;/&gt;&lt;br&gt; 账户余额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#x27;one&#x27;].money&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 123456789101112131415161718192021222324// Javabeanpublic class User &#123; private String username; private String password; private Map&lt;String,Account&gt; accountMap; private List&lt;Account&gt; accounts; // setter、getter and toString&#125;public class Account &#123; private String apwd; private Float money; // setter、getter and toString&#125;// Controller@Controller(&quot;paramsController&quot;)@RequestMapping(&quot;/params&quot;)public class ParamsController &#123; @RequestMapping(value = &quot;/getUser&quot;) public String getUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; 4. 自定义类型转换器 当我们输入的数据格式不符合自动参数绑定的规范的时候，SpringMVC并不能帮助我们封装参数，会出错。（例如：2019/01/01可以自动封装Date，而2019-01-01会报400错误） 此时除了更改数据格式，还可以使用自定义类型转换器，把数据封装。 自定义类型转换器实际是我们把获取到的数据进行自定义封装。 使用步骤一：定义实现了Converter接口的实体类 1234567891011121314public class StringtoDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; if(source==null)&#123; throw new RuntimeException(&quot;没找到数据&quot;); &#125; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; throw new RuntimeException(&quot;日期格式异常！&quot;); &#125; &#125;&#125; 以上类实现了将yyyy-MM-dd格式的字符串转换为Date类型 在Spring配置文件中配置类型转换器 spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。 12345678910111213&lt;!--配置转换器--&gt;&lt;bean id=&quot;conversionServiceFactoryBean&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;!--添加自己实现的转换器--&gt; &lt;bean class=&quot;top.tobing.utils.StringtoDateConverter&quot;&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--配置spring开启mvc注解--&gt;&lt;!--引用转换器--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionServiceFactoryBean&quot;&gt;&lt;/mvc:annotation-driven&gt; 5. 使用ServletAPI对象作为方法参数 SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数。 支持的对象有：HttpServletRequest、HttpServletResponse 、HttpSession、 java.security.Principal 、Locale、InputStream 、OutputStream、 Reader、 Writer 使用是直接将对象定义在控制器方法参数中 12&lt;a href=&quot;params/getServletAPI&quot; &gt;获取Servlet原生API&lt;/a&gt; 123456789101112131415161718@Controller(&quot;paramsController&quot;)@RequestMapping(&quot;/params&quot;)public class ParamsController &#123; /** * 获取Servlet原生API * @param request * @param response * @return */ @RequestMapping(&quot;/getServletAPI&quot;) public String getServletAPI(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(request); System.out.println(request.getSession()); System.out.println(response); return &quot;success&quot;; &#125;&#125; 2. 常用注解1. RequestParam 作用：参数绑定时，把不符合规范的参数绑定到控制器方法指定的参数 属性： value：请求参数的名称 required：请求参数中是否必须提供此参数。默认值：true。（表示必须提供，如果不提供将报错。 ） 使用 12&lt;a href=&quot;annos/testRequestParam?name=tobing&quot;&gt;testRequestParam&lt;/a&gt;&lt;br&gt; 123456789101112@Controller(&quot;annoController&quot;)@RequestMapping(&quot;/annos&quot;)@SessionAttributes(value = &#123;&quot;username&quot;,&quot;password&quot;&#125;,types = &#123;Integer.class&#125;)public class AnnoController &#123; @RequestMapping(&quot;/testRequestParam&quot;) public String testRequestParam(@RequestParam(&quot;name&quot;) String usernmae)&#123; System.out.println(&quot;testRequestParam执行了&quot;); System.out.println(usernmae); return &quot;success&quot;; &#125;&#125; 将请求参数name绑定到控制器方法username参数上 2. RequestBody 作用：用于获取请求体内容（ key=value&amp;key=value…结构的数据），get 请求方式不适用。 属性： required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值 为 false，get 请求得到是 null。 使用： 12&lt;a href=&quot;annos/testRequestBody&quot;&gt;testRequestBody&lt;/a&gt;&lt;br&gt; 1234567@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String body)&#123; System.out.println(&quot;testRequestBody执行了&quot;); System.out.println(body); return &quot;success&quot;;&#125; 3. PathVaribale 作用：绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。 属性： value：用于指定url中占位符名称 required：是否必须提供占位符 使用： 12&lt;a href=&quot;annos/testPathVariable/1024&quot;&gt;testPathVariable&lt;/a&gt;&lt;br&gt; 1234567@RequestMapping(&quot;/testPathVariable/&#123;uid&#125;&quot;)public String testPathVariable(@PathVariable(&quot;uid&quot;) String id)&#123; System.out.println(&quot;testPathVariable执行了&quot;); System.out.println(id); return &quot;success&quot;;&#125; 4. RequestHeader（少用） 作用：获取请求头 属性： value：要获取的消息头名称 required：是否必须有次消息头 使用： 12&lt;a href=&quot;annos/testRequestHeader&quot;&gt;testRequestHeader&lt;/a&gt;&lt;br&gt; 1234567@RequestMapping(&quot;/testRequestHeader&quot;)public String testRequestHeader(@RequestHeader(value = &quot;Accept&quot;) String header)&#123; System.out.println(&quot;testRequestHeader执行了&quot;); System.out.println(header); return &quot;success&quot;;&#125; 获取请求头中的Accept消息 5. CookieValue 作用：把指定cookie传到控制器方法参数中 属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 使用： 12&lt;a href=&quot;annos/testCookieValue&quot;&gt;testCookieValue&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping(&quot;/testCookieValue&quot;)public String testCookieValue(@CookieValue(value = &quot;JSESSIONID&quot;) String cookie)&#123; System.out.println(&quot;testCookieValue执行了&quot;); System.out.println(cookie); return &quot;success&quot;;&#125; 6. ModeAttribute 作用： 可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可 以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key 使用场景 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数 据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 使用： 12&lt;a href=&quot;annos/testModelAttribute?username=tobing&quot;&gt;testModelAttribute&lt;/a&gt;&lt;br&gt; 修饰在方法上 1234567891011@RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user)&#123; System.out.println(&quot;testModelAttribut执行了&quot;+user.getUsername()); return &quot;success&quot;;&#125;@ModelAttributepublic void showModelAttribute(User user)&#123; System.out.println(&quot;showModelAttribut执行了&quot;+user.getUsername()); &#125; showModelAttribut会先执行 修饰在参数上：给指定参数赋值（方式一） 123456&lt;form method=&quot;post&quot; action=&quot;annos/testModelAttribute&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 1234567891011121314151617@ModelAttributepublic User showModel(String username,String password)&#123; User user = new User(); user.setUsername(username); user.setPassword(password); user.setBirthday(new Date()); System.out.println(&quot;showModel执行了&quot;+user); return user;&#125; @RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user)&#123; System.out.println(&quot;testModelAttribut执行了&quot;+user); return &quot;success&quot;;&#125; 修饰在参数上：给指定参数赋值（方式二） 123456789101112131415@ModelAttributepublic void showModel(String username, Map&lt;String,User&gt; map)&#123; User user = new User(); user.setUsername(username); user.setPassword(&quot;root&quot;); user.setBirthday(new Date()); map.put(&quot;u&quot;,user);&#125; @RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(@ModelAttribute(&quot;u&quot;) User user)&#123; System.out.println(&quot;testModelAttribut执行了&quot;+user); return &quot;success&quot;;&#125; 7. SessionAttribute 作用：用于多次执行控制器方法间的参数共享。 属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型。 使用： 1234&lt;a href=&quot;annos/testPut&quot;&gt;存入SessionAttribute&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;annos/testGet&quot;&gt;取出SessionAttribute&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;annos/complete&quot;&gt;删除SessionAttribute&lt;/a&gt;&lt;br&gt; 12345678910111213141516171819202122// 存入session @RequestMapping(&quot;/testPut&quot;) public String testPut(Model model)&#123; model.addAttribute(&quot;username&quot;,&quot;tobing&quot;); model.addAttribute(&quot;password&quot;,&quot;root&quot;); model.addAttribute(&quot;age&quot;,21); return &quot;success&quot;; &#125; // 取出session @RequestMapping(&quot;/testGet&quot;) public String testGet(ModelMap model)&#123; System.out.println(&quot;&quot;+model.get(&quot;username&quot;)+model.get(&quot;password&quot;)+model.get(&quot;age&quot;)); return &quot;success&quot;; &#125; // 删除session @RequestMapping(&quot;/complete&quot;) public String complete(SessionStatus status)&#123; status.setComplete(); return &quot;success&quot;; &#125;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://tobing.top/tags/SpringMVC/"}]},{"title":"SpringMVC-1-入门","slug":"SpringMVC-1-入门","date":"2020-01-07T11:27:39.000Z","updated":"2021-01-15T04:08:16.927Z","comments":true,"path":"2020/01/07/SpringMVC-1-入门/","link":"","permalink":"https://tobing.top/2020/01/07/SpringMVC-1-%E5%85%A5%E9%97%A8/","excerpt":"MVC框架，学习笔记第一弹。","text":"MVC框架，学习笔记第一弹。 SpringMVC-1-入门1. 三层架构和MVC1. 三层架构（了解） 开发架构一般有两种形式：C/S架构和B/S架构。JavaEE开发中几乎都是C/S架构，在C/S架构中标准的三层架构包括：表现层、业务层、持久层。 表现层 即是web层。负责接收请求、响应结果：通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。 表现层包含展示层和控制层：控制层负责接收请求，展示层负责结果展示 表现层通常依赖业务层。接收到的客户端请求一般会调用业务层处理，并将处理结果响应到客户端。 表现层一般使用MVC模型 业务层 即是service层。负责业务逻辑处理，web层依赖业务层，但业务层不依赖web层。 业务层可能会依赖持久层，如果要对数据持久化需要保证事务一致性。 事务应该放在业务层来控制。 持久层 即是dao层。负责数据持久化，持久层是和数据库交互，对数据库表进行CRUD。 2. MVC模型 MVC，Model View Controller，是一种用于设计创建web应用程序表现层的模式。 Model（模型）： 通常指数据模型。一般用于封装数据。 View（视图）： 通常指jsp或HTML。一般是展示数据。通常依据模型数据创建。 Controller（控制器）： 处理用户交互部分。一般处理程序逻辑。 2. SpringMVC概述1. SpringMVC是什么 基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring FrameWork 的后续产品。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 2. SpringMVC在三层架构的位置 3. SpringMVC入门案例 案例需求：初始的jsp页面（index.jsp）上有一个超链接。点击超链接可以跳转的另外的页面(success.jsp)。 1. 环境搭建 创建Maven工程，选择webapp 添加以下坐标 1234567891011121314151617181920212223242526272829303132&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置web.xml配置文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;!--springmvc核心控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置Servlet在启动时加载对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置springmvc.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=&quot;top.tobing&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置视图挤下去类--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置spring开启mvc注解--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 2. 代码编写 编写Controller 12345678@Controller(&quot;helloController&quot;)public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String transPage()&#123; System.out.println(&quot;页面转跳中.....&quot;); return &quot;success&quot;; &#125;&#125; index页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;第一个SpringMVC案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;SpringMVC入门案例：页面跳转&lt;/h3&gt; &lt;center&gt;&lt;a href=&quot;hello&quot;&gt;点我跳转&lt;/a&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 跳转的成功页面success 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页面跳转&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;跳转成功&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 3. 启动项目4. 入门案例流程 4. RequestMapping注解 用于建立请求URL和处理请求方法的对应关系 1234567@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123; // .... &#125; 注解出现的位置 类：出现在类上，表示请求URL的第一级目录。不写相当于根目录。 /user/…. /user/…. 方法：表请求URL的第二级目录。 /user/save /user/update 属性 value=path：指定请求URL method：指定请求方法 params：指定限制请求参数条件。 headers：指定限制请求头消息的条件 URL与处理方法的一一对应关系 1234&lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;SpringMVC入门案例：页面跳转&lt;/h3&gt; &lt;center&gt;&lt;a href=&quot;hello&quot;&gt;点我跳转&lt;/a&gt;&lt;/center&gt;&lt;/body&gt; 12345678@Controller(&quot;helloController&quot;)public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) // &lt;a href=&quot;a&quot;&gt; ----&gt; /hello public String transPage()&#123; System.out.println(&quot;页面转跳中.....&quot;); return &quot;success&quot;; &#125;&#125;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://tobing.top/tags/SpringMVC/"}]},{"title":"spring-3-基于注解ioc","slug":"spring-3-基于注解ioc","date":"2019-12-23T10:37:06.000Z","updated":"2021-01-15T04:09:02.610Z","comments":true,"path":"2019/12/23/spring-3-基于注解ioc/","link":"","permalink":"https://tobing.top/2019/12/23/spring-3-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3ioc/","excerpt":"Spring学习第三弹。","text":"Spring学习第三弹。 spring-3-基于注解Ioc配置1. 基于注解的Ioc配置 基于注解和xml的配置实现的功能都是一样的，都是要降低程序间耦合。 xml和注解的配置方式都很常用 1. 环境搭建 在pom.xml中添加spring的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; Maven添加依赖时默认把spring的aop导入。 2. 创建service、dao、view类 修改bean.xml要扫描的包 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:conetext=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--告诉spring容器使用要扫描的包--&gt; &lt;context:component-scan base-package=&quot;top.tobing&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 3. 使用注解 创建对象 @Component(value=””)：相当于一个xml配置中的一个bean @Controller(value=””)：用于表现层 @Service(value=””)：用于业务层 @Repository(value=””)：用于持久层 后面三个注解是第一个注解的衍生，他们4个的作用及属性一模一样。只是提供了更为明确的语义 注入数据 @Autowired：自动注入，不依赖setter，只能注入其他bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为bean的id，在ioc容器中中寻找，没找到就报错 @Qualifier（value=“”）：结合第一个注解使用，可以用于指定bean的id @Resource（name=””）：直接按照bean的id注入，只能注入其他bean类型 @Value（value=””）：注入基本数据类型和String类型 改变范围 @Scope（value=“”）：指定bean作用范围：单例(singleton)、多例(prototype)等。 生命周期（了解即可） @PostConstruct（）：指定初始化方法 @PreDestroy（）：指定摧毁方法 创建对象相关注解 @Component（value=“”）用于创建对象，value指定id，value为空时使用类名首字母小写来作为默认id。Controller、Service、Repository三个注解可以混用。 1234567891011121314151617181920212223//@Component@Service(&quot;userService01&quot;)public class UserServiceImpl implements UserService &#123; private UserDao userDao ; public String toString() &#123; return &quot;ServiceImpl01&quot;; &#125; public void save() &#123; userDao.save(); &#125;&#125;////////////////////////////////////////////////////////////////@Component@Service(&quot;userService02&quot;) // 不使用默认，使用自定义idpublic class UserServiceImpl1 implements UserService &#123; private UserDao userDao ; public String toString() &#123; return &quot;ServiceImpl02&quot;; &#125; public void save() &#123; userDao.save(); &#125;&#125; 123456789public class Client &#123; public static void main(String[] args) &#123; // 1.加载bean配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); // 2.获取bean对象 Object obj = ac.getBean(&quot;userService02&quot;);//改变id可以获取不同对象 System.out.println(obj); &#125;&#125; ServiceImpl02 注入数据相关注解 Dao层 12345678910111213@Repository(&quot;userDao01&quot;)public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;Dao save!&quot;); &#125;&#125;//////////////////////////////////////////////////@Repository(&quot;userDao02&quot;)public class UserDaoImpl1 implements UserDao &#123; public void save() &#123; System.out.println(&quot;Dao save!&quot;); &#125;&#125; Service层 123456789@Service(&quot;userService01&quot;)public class UserServiceImpl implements UserService &#123; @Autowired() //@Qualifier(&quot;userDao02&quot;) private UserDao userDao01 ; public void save() &#123; userDao01.save(); &#125;&#125; Ioc中存在多个的时候，会自动寻找与属性名相同的id的对象。 实际实际汇总常用@Qualifier指定固定id对象。 2. 基于xml的ioc案例 要求：使用spring的ioc对account表进行crud 1. 创建数据库1234567891011CREATE DATABASE eesy; -- 创建数据库USE eesy; -- 使用数据库CREATE TABLE account( -- 创建account表 id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT);-- 在account表中插入3条数据INSERT INTO account(NAME,money) VALUE(&quot;aaa&quot;,1000);INSERT INTO account(NAME,money) VALUE(&quot;bbb&quot;,3000);INSERT INTO account(NAME,money) VALUE(&quot;ccc&quot;,2000); 2. 创建Maven工程，导入依赖 创建maven工程 在pom.xml中导入要用到的依赖 数据库连接池c3p0 dbutils mysql junit spring-context pom.xml 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;!--spring-context--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接池c3p0--&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--dbutils--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3. 创建各层接口，实体类 实体类domain.Account–&gt;account表 123456public class Account implements Serializable &#123; private Integer id; private String name; private Float money;&#125; 持久层dao–&gt;操作account 12345678public interface AccountDao &#123; void save(Account account); void update(Account account); void delete(Integer id); List&lt;Account&gt; findAll(); Account findById(Integer id);&#125; dao.impl 123456789101112131415161718192021222324252627282930313233343536373839404142public class AccountDaoImpl implements AccountDao &#123; private QueryRunner runner; // 使用dbutils的QueryRunner查询 public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; public void save(Account account) &#123; try &#123; runner.update(&quot;insert into account(name,money) values(?,?)&quot;,account.getName(),account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void update(Account account) &#123; try &#123; runner.update(&quot;update account set name=? ,money=? where id = ?&quot;,account.getName(),account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void delete(Integer id) &#123; try &#123; runner.update(&quot;delete from account where id = ?&quot;,id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public List&lt;Account&gt; findAll() &#123; try &#123; return runner.query(&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public Account findById(Integer id) &#123; try &#123; return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 业务层service–&gt;调用持久层 12345678public interface AccountService &#123; void save(Account account); void update(Account account); void delete(Integer id); List&lt;Account&gt; findAll(); Account findById(Integer id);&#125; 4. 基于xml的bean注入 创建bean.xml 通过xml分别给各层的对象进行注入 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--为持久层对象注入--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;top.tobing.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--为到注入--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;top.tobing.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--为QueryRunner注入--&gt; &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--为DataSource注入--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5. 测试各层方法 使用ApplicationContext获取注入的对象 test.AccountServiceTest 1234567891011121314151617181920212223242526272829public class AccountServiceTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); AccountService accountService = context.getBean(&quot;accountService&quot;,AccountService.class); // 1. 查询所有// List&lt;Account&gt; accounts = accountService.findAll();// for (Account account : accounts) &#123;// System.out.println(account);// &#125; // 2. 根据id查询// Account account = accountService.findById(1);// System.out.println(account); // 3. 保存用户// Account acc = new Account();// acc.setMoney(12345F);// acc.setName(&quot;Tobing&quot;);// accountService.save(acc); // 4. 更新用户// Account acc = new Account();// acc.setMoney(22345F);// acc.setName(&quot;Tobing&quot;);// acc.setId(4);// accountService.update(acc); // 5. 删除用户 accountService.delete(4); &#125;&#125; 6. 原理图 3. 对以上案例进行基于注解的改造1. 创建新工程 复制以上工程的所有代码：test，main，pom.xml 2. 更改bean.xml 将bean.xml中的约束改为注解的约束。 同时添加“spring创建容器时扫描的包”。 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--告知spring在创建容器的时候要扫描的路径--&gt; &lt;context:component-scan base-package=&quot;top.tobing&quot;&gt;&lt;/context:component-scan&gt; &lt;!--为QueryRunner注入--&gt; &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--为DataSource注入--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 添加注解 给持久层、业务层添加注解 1234567@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; ...&#125; 1234567@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired private QueryRunner runner; ....&#125; 4. 运行测试（略）4. ioc案例存注解改造0. 必须的新注解 Configuration： 用于指定当前类是一个spring配置类，当创建容器时会从该类加载注解。 获取容器时需要使用AnnotationApplicationContext(有Configuration注解的类.class)。 12345678910@Configurationpublic class SpringConfiguration &#123; ....&#125;@Configurationpublic class JdbcConfiguration &#123; ...&#125; ComponentScan： 用于指定spring在初始化容器时要扫描的包。 作用和在spring的bean.xml中的componet-scan一致： 12&lt;context:component-scan base-package=&quot;top.tobing&quot;&gt;&lt;/context:component-scan&gt; 12345@ComponentScan(value = &quot;top.tobing&quot;)public class SpringConfiguration &#123; .... &#125; Bean： 只能放在方法上，表明将该方法返回的对象放在spring的容器中。 1234567891011121314public class JdbcConfiguration &#123; ... @Bean(&quot;runner&quot;) @Scope(&quot;prototype&quot;) // 指定为非单例 public QueryRunner getQueryRunner(DataSource dataSource)&#123; .... &#125; @Bean(&quot;dataSource&quot;) public DataSource getDataSource()&#123; .... &#125;&#125; PropertySource： 用于加载.properties文件中的配置。 例如我们配置数据源时可以把数据库相关信息写到properties配置文件中，这时就可以使用该注解指定配置文件的位置。 12345@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfiguration &#123; ...&#125; @Import： 用于导入其他配置类. 在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没有问题。 123456@Import(&#123;JdbcConfiguration.class&#125;)@ComponentScan(value = &quot;top.tobing&quot;)public class SpringConfiguration &#123;&#125; 1. 复制以上工程2. 添加注解 config 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configuration@Import(&#123;JdbcConfiguration.class&#125;) // 导入类@ComponentScan(value = &quot;top.tobing&quot;) // 指定扫描的包public class SpringConfiguration &#123;&#125;@Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) // 指定配置文件public class JdbcConfiguration &#123; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; /** * 获取runner * @param dataSource * @return */ @Bean(&quot;runner&quot;) // 将方法返回的对象放在spring容器中 @Scope(&quot;prototype&quot;) // 指定为非单例 public QueryRunner getQueryRunner(DataSource dataSource)&#123; return new QueryRunner(dataSource); &#125; /** * 获取数据源 * @return */ @Bean(&quot;dataSource&quot;) public DataSource getDataSource()&#123; try&#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/eesy&quot;); ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); ds.setUser(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125;&#125; 持久层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired // 自动注入 private QueryRunner runner; public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; public void save(Account account) &#123; try &#123; runner.update(&quot;insert into account(name,money) values(?,?)&quot;,account.getName(),account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void update(Account account) &#123; try &#123; runner.update(&quot;update account set name=? ,money=? where id = ?&quot;,account.getName(),account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void delete(Integer id) &#123; try &#123; runner.update(&quot;delete from account where id = ?&quot;,id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public List&lt;Account&gt; findAll() &#123; try &#123; return runner.query(&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public Account findById(Integer id) &#123; try &#123; return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 业务层 123456789101112131415161718192021222324@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void save(Account account) &#123; accountDao.save(account); &#125; public void update(Account account) &#123; accountDao.update(account); &#125; public void delete(Integer id) &#123; accountDao.delete(id); &#125; public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125; public Account findById(Integer id) &#123; return accountDao.findById(id); &#125;&#125; 配置文件jdbc.properties 12345jdbc.username=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.driver=com.mysql.jdbc.Driver 3. 测试 测试类 123456789101112public class AccountServiceTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfiguration.class); // 此处使用注解的方式创建容器 AccountService accountService = context.getBean(&quot;accountService&quot;,AccountService.class); // 1. 查询所有 List&lt;Account&gt; accounts = accountService.findAll(); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://tobing.top/tags/Spring/"}]},{"title":"spring-2-入门补充","slug":"spring-2-入门补充","date":"2019-12-11T12:21:07.000Z","updated":"2021-01-15T04:09:32.896Z","comments":true,"path":"2019/12/11/spring-2-入门补充/","link":"","permalink":"https://tobing.top/2019/12/11/spring-2-%E5%85%A5%E9%97%A8%E8%A1%A5%E5%85%85/","excerpt":"Spring学习第二弹。","text":"Spring学习第二弹。 Spring-2-入门补充 基于XML的IOC的细节 1. Spring中工厂的类结构图 1. BeanFactory和ApplicationContext的区别 BeanFactory才是Spring容器中的顶层接口。 ApplicationContext是它的子接口 创建对象的时间点不一样（区别） ApplicationContext：一读取配置文件，默认就会创建对象。有点像立即加载（使用应用在单列设计模式）。 BeanFactory：什么时候使用，什么时候加载。有点像延迟加载（适合多例场景）。 2. ApplicationContext接口的3个实现类 spring中ApplicationContext接口有三个实现类用于3种方式加载配置。 类根目录 ClassPathXmlApplicationContext 资源文件存放在res下。 磁盘任意目录 FileSystemXMLApplicationContext 资源配置文件存放在磁盘的其他地方。 注解 AnnotationConfigApplicationContext 12345// 方式1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);// 方式2ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;E:\\\\IdeaProjects\\\\spring02_introduction\\\\src\\\\main\\\\resources\\\\bean.xml&quot;); 2. IOC中bean标签和管理对象细节1. bean标签 作用： 用于配置对象来让spring来创建 默认情况下调用无参构造，如果没有参数则不能创建成功。 属性： id：给在容器中的对象指定唯一标识 class：指定类的全限定类名。用来反射创建对象。默认调用无参数构造方法 init-method：指定类中初始化方法名称 destroy-method：指定类中销毁方法名称 scope：指定对象作用的范围 singleton：单例（默认） prototype：多例 request：WEB项目中，Spring创建的Bean将其存入request域中 session：WEB项目中，Spring创建的Bean将其存入session域中 global session：WEB项目中，如果有多集群（多台服务器）的情况下，将其存入global session中 2. bean的作用范围和生命周期 单例：scope=“singleton” 一个应用只有一个对象的实例。作用范围：整个引用 生命周期： 出生：应用加载，创建容器时，对象被创建。 活着：容器存在，就一直活着。 销毁：应用卸载，容器销毁，对象被销毁。 多例：scope=”prototype” 每次访问对象，都会重新创建对象实例 生命周期 出生：当使用对象时，创建新的对象实例。 活着：对象被使用，一直活着。 死亡：长时间没有，java垃圾回收机制回收 3. 实例化Bean的三种方式 无参构造 静态工厂 实例工厂 使用无参构造（默认） 123456public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); public void save() &#123; userDao.save(); &#125;&#125; 1&lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; 使用静态工厂生产对象 12345public class StaticFactory &#123; public static UserServiceImpl createUserService()&#123; return new UserServiceImpl(); &#125;&#125; 12&lt;!--静态工厂生产对象--&gt;&lt;bean id=&quot;staticUserService&quot; class=&quot;top.tobing.factory.StaticFactory&quot; factory-method=&quot;createUserService&quot;&gt;&lt;/bean&gt; 使用实例工厂生产对象 12345public class InstanceFactory &#123; public UserServiceImpl createUserService()&#123; return new UserServiceImpl(); &#125;&#125; 123&lt;!--实例工厂生产对象--&gt;&lt;bean id=&quot;instanceUserService&quot; class=&quot;top.tobing.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceI&quot; factory-bean=&quot;instanceUserService&quot; factory-method=&quot;createUserService&quot;&gt;&lt;/bean&gt; 3. Spring的依赖注入 依赖注入，Dependency Injection（简称DJ）。它是spring框架核心ioc的具体实现。 在编写程序时。我们通过Ioc（控制反转）把对象创建的控制权交给了spring。 代码中不可能完全没有依赖，IOC解耦只是降低他们的依赖关系，不可能完全消除依赖关系，例如：业务层仍然需要调持久层。 在使用了spring之后，我们连通把这种依赖也交给了spring维护。 就是说，我们只需让框架把持久层对象传入业务层，而不是我们自己获取。 1. 构造函数注入 通过使用类中构造函数，给成员变量赋值。 赋值的过程是使用配置文件的方式（如xml），让spring帮我们注入。 constructor-arg标签 重写UserServiceImpl类用于演示依赖注入 123456789101112131415public class UserServiceImpl implements UserService &#123; private String name; private Integer age; private Date birthday; public UserServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void save() &#123; System.out.println(&quot;Save method!&quot;+name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 编写bean.xml，给上述service层的对象传值。 123456&lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;bir&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=&quot;bir&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 通过调用service层UserServiceImpl的save方法看是否注入成功 12345678public class UserUI &#123; public static void main(String[] args) &#123; // 1. 使用ApplicationContext接口（获取spring容器） ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = (UserService) ac.getBean(&quot;userService&quot;); userService.save(); &#125;&#125; 结果：Save method!张三,19,Wed Dec 11 17:31:25 CST 2019 依赖注入对应关系 构造函数依赖注入涉及标签 constructor-arg属性： ——————————-给谁赋值———————————– index：指定参数在构造函数参数列表的索引位置 type：指定参数在构造函数中的数据类型 name：指定参数在构造函数中的名称（实际中最常用） ——————————-赋什么赋值——————————– value：基本数据类型和String ref：赋值可以是其他bean，也就是说在配置文件中的其他bean 123456789101112&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt; &lt;!--给参数列表中，属性名为name的赋值--&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;!--给参数列表中，数据类型为Integer的参数赋值--&gt; &lt;constructor-arg type=&quot;java.lang.Integer&quot; value=&quot;19&quot;&gt;&lt;/constructor-arg&gt; &lt;!--给参数类表中，索引为2,（即第3个参数）赋值--&gt; &lt;!--ref用于引用id为bir的另外一个bean--&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;bir&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;bir&quot; class=&quot;java.util.Date&quot; &gt;&lt;/bean&gt; &lt;/beans&gt; 2. set方法注入 通过类中setter方法注入 property标签 重写UserServiceImpl 123456789101112public class UserServiceImpl implements UserService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; // 省略其余setter public void save() &#123; System.out.println(&quot;Save method!&quot;+name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 编写配置文件建议对应关系，注入 12345678&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;tobing&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;bir&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;bir&quot; class=&quot;java.util.Date&quot; &gt;&lt;/bean&gt;&lt;/beans&gt; 测试 1234// 1. 使用ApplicationContext接口（获取spring容器）ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);// 2. 调用方法UserService userService = (UserService) ac.getBean(&quot;userService&quot;); Save method!tobing,20,Wed Dec 11 18:27:46 CST 2019 3. p名称空间注入（本质调用setter方法） 通过在xml中导入p名称空间，使用p：注入属性名称=xxx来注入数据。 编写service层（和set方法一致） 编写配置文件 注意导入p空间： xmlns:p=”http://www.springframework.org/schema/p&quot; 注意非基本数据类型和String要使用：属性名-ref 来注入。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot; p:age=&quot;18&quot; p:name=&quot;Rongon&quot; p:birthday-ref=&quot;bir&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bir&quot; class=&quot;java.util.Date&quot; &gt;&lt;/bean&gt;&lt;/beans&gt; 4. 注入集合属性 通过setter，给集合成员（数组、List、Set、Map、Properties）传值。 给service层添加集合元素用于测试 123456789101112131415161718public class UserServiceImpl implements UserService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myPropers; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; // setter public void save() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myPropers); &#125;&#125; 编写配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt; &lt;!--字符数组--&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;value&gt;DDD&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;List1&lt;/value&gt; &lt;value&gt;List2&lt;/value&gt; &lt;value&gt;List3&lt;/value&gt; &lt;value&gt;List4&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;Set1&lt;/value&gt; &lt;value&gt;Set2&lt;/value&gt; &lt;value&gt;Set3&lt;/value&gt; &lt;value&gt;Set4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=&quot;myPropers&quot;&gt; &lt;props&gt; &lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;mapA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;mapB&quot; value=&quot;bbb&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;mapC&quot;&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 测试 12345678public class UserUI &#123; public static void main(String[] args) &#123; // 1. 使用ApplicationContext接口（获取spring容器） ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = (UserService) ac.getBean(&quot;userService&quot;); userService.save(); &#125;&#125; 12345[AAA, BBB, CCC, DDD][List1, List2, List3, List4][Set1, Set2, Set3, Set4]&#123;mapA=aaa, mapB=bbb, mapC=CCC&#125;&#123;testB=bbb, testA=aaa&#125; 注意 在集合数据注入时，同一种集合元素可以共用一种标签，例如： List结构： array、list、set Map结构： map、entry、props、prop","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://tobing.top/tags/Spring/"}]},{"title":"spring-1-入门","slug":"spring-1-入门","date":"2019-12-11T12:20:31.000Z","updated":"2021-01-15T04:10:08.262Z","comments":true,"path":"2019/12/11/spring-1-入门/","link":"","permalink":"https://tobing.top/2019/12/11/spring-1-%E5%85%A5%E9%97%A8/","excerpt":"Spring是核心是AOP和IOC，是框架中必不可少的一部分，本文记录了学习笔记。","text":"Spring是核心是AOP和IOC，是框架中必不可少的一部分，本文记录了学习笔记。 Spring-1-入门1. Spring的优势（先了解、使用中感悟） 方便解耦，简化开发 AOP编程的支持 声明式事务的支持 方便程序的测试 方便集成各种优秀框架 降低了JavaEE API的使用难度 Java源码是经典学习的范例 1. 方便解耦，简化开发 通过Spring提供的Ioc容器，可以对对象之间的依赖关系交给Spring进行控制，编码硬编码所造成的过度程序耦合。用户不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更加专注于上层的应用。 2. AOP编程的支持 通过Spring的AOP功能，方便进行切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应对。 3. 声明式事务的支持 从单调的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量 4. 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 5. 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Structs、Hibernate、Hessian、Quartz等）的直接支持 6. 降低了JavaEE API的使用难度 简化了如：JDBC、JavaMail、远程调用等的使用难度（对JavaEE API进行了略微封装），使得API使用难度大大降低。 7. Java源码是经典学习的范例 Spring源代码设计精妙、结构清晰、独具匠心。楚楚体现着对Java设计模式的灵活运用以及对Java技术的高深造诣。是学习的典范。 8. Spring的体系结构 2. IoC的概念及作用1.什么是耦合 耦合度 耦合度，也叫耦合性，是模块间关联程度。在软件工程中体现的是程序与程序之间的依赖程度。（Java中是类与类（或者方法与方法）之间的依赖程度） 高耦合，耦合越高程序越难以维护。 低耦合，常与高内聚一起来衡量模块独立程度的标准。 划分模块的准则是：高内聚、低耦合。 2. 耦合度的体现 程序之间的是必然存在依赖关系的，但是有的依赖是可以通过优化代码来消除的 以注册驱动为例，演示优化程序间依赖关系 采用DriverManager的register方法的形式注册驱动 12345678910public class JdbcDemo01 &#123; public static void main(String[] args) throws SQLException &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取连接 //3.获取预处理对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 分析以上程序可以知道，当com.mysql.jdbc.Driver这个类没有没导入的时候，该程序会在在编译期间就会报错误（注意是Error，而不是异常） 以Class.forName，即反射的方式注册驱动 12345678910public class JdbcDemo01 &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 //3.获取预处理对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 以反射的方式加载驱动时，只需要传入全限定类名的字符串表现形式，这种形式下，如果没有导入对应的驱动jar包，肯定也无法正常运行。但是在编译的时候却是可以通过的（运行时抛出异常，ClassNotFoundException）。 由以上两种方式，我们可以明显看出，第二种方式（即是以反射的形式）加载驱动的耦合度要低于直接创建对象的方式 以往开发中耦合度较高的程序 界面层要创建业务层对象实现业务 业务层要创建接口层对象实现dao 123public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl(); //此处要求存在AccountDaoImpl类&#125; 3. 如何解决耦合度（工厂模式、单列模式） 以上注册驱动案例中，我们发现以反射的形式加载驱动类时，即是我们把数据库驱动的依赖（dependency）去除，程序仍然能够正常编译。（运行是肯定不行的了） 但是这种方式也存在一个问题，程序扩展性太差，因为驱动的类名已经写死。当我们需要使用其他数据库时还需要将代码重写编译。 为了解决以上问题，实际中我们常常使用配置文件。 解决办法：创建Bean对象的工厂 Bean：在计算机英语中，有可重用组建的含义。 JavaBean：用java语言编写的可重用组件。 JavaBean并不仅仅局限于我们知道的实体类 JavaBean &gt; 实体类 JavaBean包含了service和dao等重用性较高的对象 使用JavaBean工厂对象 配置文件配置service和dao 配置的内容：唯一标识 = 全限定类名（key = value） 读取配置文件，通过反射来创建对象 可以使用xml或者properties 使用工厂模式解耦 加载包含全限定类名的配置文件。 根据配置文件中的全限定类名，以反射的方式创建对象。 1234567891011121314151617181920212223242526272829package top.tobing.beanfactory;import java.io.InputStream;import java.util.Properties;public class BeanFactory &#123; private static Properties pro; // 加载配置文件 static&#123; try&#123; pro = new Properties(); InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); pro.load(in); &#125;catch (Exception e) &#123; throw new ExceptionInInitializerError(&quot;没找到配置文件！&quot;); &#125; &#125; // 利用反射获取对象 public static Object getBean(String beanName)&#123; Object bean = null; try&#123; String className = pro.getProperty(beanName); bean = Class.forName(className).newInstance(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return bean; &#125;&#125; 工厂模式优化 以上代码中，虽然我们已经通过工厂模式降低了三层之间的耦合度，但是我们每次获取Impl对象的时候都要newInstance的方式（调用默认构造方法），主动申请对象。这样申请的对象每次都不一样。 这种方式的效率低下 解决办法 在初始化的时候，加装配置文件。 通过配置文件的信息，创建容器存储反射创建的对象。 每次在获取Bean对象的时候通过容器返回 12345678910111213141516171819202122232425262728293031323334353637383940package top.tobing.beanfactory;import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Properties;public class BeanFactoryPlus &#123; // 1. 读取配置文件 private static Properties pro; private static Map&lt;String,Object&gt; beans; static&#123; try&#123; pro = new Properties(); beans = new HashMap&lt;&gt;(); // 获取配置文件 InputStream in = BeanFactoryPlus.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); pro.load(in); // 遍历配置文件信息 Enumeration&lt;Object&gt; keys = pro.keys(); while(keys.hasMoreElements())&#123; String beanName = (String)keys.nextElement().toString(); String className = (String)pro.get(beanName); // 2. 反射创建对象 Object obj = Class.forName(className).newInstance(); // 3. 使用容器存储创建对象 beans.put(beanName,obj); &#125; &#125;catch (Exception e)&#123; throw new ExceptionInInitializerError(&quot;配置文件读取异常！&quot;); &#125; &#125; // 返回容器中存储的对象 public static Object getBean(String beanName)&#123; return beans.get(beanName); &#125;&#125; 4. 什么是Ioc？ Ioc，全称Inversion of Control，控制反转。可以理解为，把创建对象的权利交给了框架。 为何说降低耦合是控制反转？ 在创建依赖的对象时，一般的形式是通过new关键字直接创建对象。这种情况要求程序要与资源直接关联（程序对资源有直接控制权）。 在使用工厂模式解耦的时候，我们通过工厂类作为中间人，将多个资源与程序关联起来。 这时候，我们将程序对资源的控制权交给了工厂。因此成为控制反转。 Ioc 的作用 降低程序间的耦合度。 3. 使用Spring的Ioc解决程序耦合度 步骤： 下载spring开发包 创建业务层接口和实现类 创建持久层接口和实现类 基于XML配置（基于Maven） 获取spring的容器 通过容器创建对象 1. 下载spring开发包 Spring官网：www.spring.io Spring开发包下载地址： https://repo.spring.io/release/org/springframework/spring/ 目录结构 下载之后解压得到：spring-framework-5.0.2.RELEASE-dist文件夹 -spring-framework-5.0.2.RELEASE ​ -docs：API和开发规范 ​ -libs：jar包和源码 ​ -schema：约束 开发注意 spring5.0.2是基于jdk8编写的，需要jdk8或者以上的版本 tomcat需要8.5以上 2. 创建业务层，持久层接口以及对应的实现类 资源框架 代码 视图层 123456public class UserUI &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); userService.save(); &#125;&#125; 业务层 123456789public interface UserService &#123; void save();&#125;public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); public void save() &#123; userDao.save(); &#125;&#125; 持久层 12345678public interface UserDao &#123; void save();&#125;public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;UserDao--&gt; 查询用户&quot;); &#125;&#125; 3. 创建spring依赖（导入jar包） pom.xml文件下添加spring的依赖 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4. 添加bean配置文件 在资源目录下创建bean.xml文件 在spring参考文档(Spring Framework Documentation)core中找到bean.xml约束 配置service和dao 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--service配置--&gt; &lt;bean id=&quot;userService&quot; class=&quot;top.tobing.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!--dao配置--&gt; &lt;bean id=&quot;userDao&quot; class=&quot;top.tobing.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 5. 测试配置是否已经成功 将视图层，业务层和持久层的调用从new改为使用spring提供的Ioc 获取ApplicationContext对象 通过该对象的getBean获取对象 123456789101112public class UserUI &#123; public static void main(String[] args) &#123; // 1. 使用ApplicationContext接口（获取spring容器） ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); // 2. 根据bean的id获取对象 UserService userService = (UserService) ac.getBean(&quot;userService&quot;); UserDao userDao = ac.getBean(&quot;userDao&quot;,UserDao.class); System.out.println(userDao); System.out.println(userService); &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://tobing.top/tags/Spring/"}]},{"title":"Mybatis-7-注解开发","slug":"Mybatis-7-注解开发","date":"2019-11-30T13:16:17.000Z","updated":"2021-01-15T03:15:39.867Z","comments":true,"path":"2019/11/30/Mybatis-7-注解开发/","link":"","permalink":"https://tobing.top/2019/11/30/Mybatis-7-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"Mybatis学习第七弹。","text":"Mybatis学习第七弹。 Mybatis-7-注解开发 注解开发可以减少xml配置文件的编写。 1. Mybatis中常用的注解 @Insert：新增操作 @Update：更新操作 @Delete：删除操作 @Select：查询操作 @Result：结果集的封装 @Results：与Result一起使用，实现多个结果集封装 @ResultMap：实现引用@Results定义的封装 @One：一对一的结果集封装 @Many：一对多结果集封装 @SelectProvider：动态SQL映射 @CacheNamespace：二级缓存配置 2. 注解开发入门 根据数据库表封装实体类 使用注解方式开发持久层接口 修改SqlMapConfig.xml配置文件 测试 1. 根据数据库封装实体类 封装User表 1234567public class User implements Serializable &#123; private int id; private String username; private Date birthday; private String sex; private String address;&#125; 2. 使用注解方式开发持久层接口 把resources下xml配置文件删除 把SqlMapConfig下的mappers下的Mapper引用改为持久层接口的全限定类名。 使用注解开发 更改mapper 123&lt;mappers&gt; &lt;mapper class=&quot;top.tobing.dao.UserDao&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 注解开发 根据id查询数据 1234public interface UserDao &#123; @Select(&quot;Select * from user where id = #&#123;id&#125;&quot;) public User findById(int id);&#125; 3. 测试 检验注解开发是否能够正常查询出来数据 12345@Test public void findByIdTest()&#123; User user = userDao.findById(44); System.out.println(user); &#125; 结果：User{id=44, username=’CacheTest’, birthday=null, sex=’男’, address=’英国’} 3. 使用注解实现简单CRUD 使用注解开发实现简单的CRUD 使用注解配置：数据库列名和实体类属性名的一一对应（非常规） 创建实体类 此处故意使得实体类属性名和数据库列名不匹配 12345678public class User implements Serializable &#123; // 对应数据库的列名 private int userId; // ===&gt;id private String userName; // ===&gt;username private Date userBirthday; // ===&gt;birthday private String userSex; // ===&gt;sex private String userAddress; // ===&gt;address&#125; 在UserDao中添加用于对User进行CRUD的抽象方法 1234567891011121314151617181920212223242526272829303132333435public interface UserDao &#123; // 查询所有用户 @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;,value = &#123;// 建立数据库列和实体类字段名的一一对应 @Result(id = true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;userName&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;) &#125;) public List&lt;User&gt; findAll(); // 更加Id查询用户 @Select(&quot;Select * from user where id = #&#123;id&#125;&quot;) @ResultMap(&quot;userMap&quot;) // 使用userMap封装 public User findById(Integer id); // 保存用户信息 @Insert(&quot;insert into user values(#&#123;userId&#125;,#&#123;userName&#125;,#&#123;userBirthday&#125;,#&#123;userSex&#125;,#&#123;userAddress&#125;)&quot;) public int saveUser(User user); // 更新用户信息 @Update(&quot;update user set username=#&#123;userName&#125;,sex=#&#123;userSex&#125;,address=#&#123;userAddress&#125; where id = #&#123;userId&#125;&quot;) public int updateUser(User user); // 查询总记录数 @Select(&quot;Select count(*) from user&quot;) public int findTotal(); // 根据用户名模糊查询 @Select(&quot;Select * from user where username like #&#123;username&#125;&quot;) @ResultMap(&quot;userMap&quot;) // 使用userMap封装 public List&lt;User&gt; findByName(String username);&#125; 此处由于数据库列名和实体类的字段名不对应，需要通过使用注解@Results和@Result来建立数据库列名和实体类字段名的一一对应关系。 在需要封装结果集的地方使用注解@ResultMap引用自定义的封装。 测试建议 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class UserDaoTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private UserDao userDao; @Before public void init()&#123; try &#123; //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建工厂类 factory =new SqlSessionFactoryBuilder().build(in); //3.生产SqlSession对象 session = factory.openSession(); //4.获取代理对象 userDao = session.getMapper(UserDao.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @After public void destory() throws IOException &#123; session.commit(); session.close(); in.close(); &#125; @Test public void findByIdTest()&#123; User user = userDao.findById(44); System.out.println(user); &#125; // 查询所有用户 @Test public void findAllTest() &#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; // 保存用户信息 @Test public void saveUser() &#123; User u = new User(); u.setUserAddress(&quot;水帘洞&quot;); u.setUserBirthday(new Date()); u.setUserName(&quot;孙悟空&quot;); u.setUserSex(&quot;男&quot;); int res = userDao.saveUser(u); System.out.println(res); &#125; // 更新用户信息 @Test public void updateUser()&#123; User u = new User(); u.setUserName(&quot;孙悟饭&quot;); u.setUserAddress(&quot;水帘洞&quot;); u.setUserBirthday(new Date()); u.setUserSex(&quot;男&quot;); u.setUserId(47); int res = userDao.updateUser(u); System.out.println(res); &#125; // 查询总记录数 @Test public void findTotal()&#123; int total = userDao.findTotal(); System.out.println(total); &#125; // 根据用户名模糊查询 @Test public void findByName()&#123; List&lt;User&gt; users = userDao.findByName(&quot;%张%&quot;); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; 4. 使用注解查询复杂关系1. 注解说明12345@Results(id = &#x27;&#x27; value = &#123; @Result(), @Result(), ... &#125;) Results 1234public @interface Results &#123; String id() default &quot;&quot;; // 指定主键 Result[] value() default &#123;&#125;; // 指定类名和属性的对应关系（Result注解）&#125; Result 1234567891011public @interface Result &#123; boolean id() default false; // 是否为主键 String column() default &quot;&quot;; // 数据库列名 String property() default &quot;&quot;; // 实体类属性名 One one() default @One; // 使用@One注解 Many many() default @Many; // 使用@Many注解&#125; One 12345public @interface One &#123; String select() default &quot;&quot;; // 指定用于多表查询的sqlMapper // 覆盖全局的配置参数lazyLoadingEnable FetchType fetchType() default FetchType.DEFAULT; &#125; Many 12345public @interface Many &#123; String select() default &quot;&quot;; // 指定用于多表查询的sqlMapper FetchType fetchType() default FetchType.DEFAULT;&#125; 总结 @One 指定一对一 代替了&lt;assocation&gt;标签，是多表查询的关键。 用于指定查询返回单一对象 @Many 指定一对多 代替了&lt;Collection&gt;，是多表查询的关键 用于指定查询返回集合对象 2. 使用注解开发一对一的复制关系映射 需求：加载账号时，加载用户信息。（可根据情况延迟加载） 创建Account类和User类 12345678910111213141516// Account类public class Account implements Serializable &#123; private int id; private int uid; private double money; private User user; // 与账号一一对应的用户&#125;// User类public class User implements Serializable &#123; private int userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; private List&lt;Account&gt; accounts;&#125; 添加Account持久层dao并使用注解配置 123456789101112131415public interface AccountDao &#123; @Select(&quot;select * from account&quot;) @Results(id=&quot;accountMap&quot;, value = &#123; @Result(id = true,column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;uid&quot;,property = &quot;uid&quot;), @Result(column = &quot;money&quot;,property = &quot;money&quot;), @Result(column = &quot;uid&quot;, // 参数 property = &quot;user&quot;, // 封装的参数 one=@One(select=&quot;top.tobing.dao.UserDao.findById&quot;,// 调用UserDao.findById实现延迟查询 fetchType= FetchType.LAZY) // 延迟加载 ) &#125;) List&lt;Account&gt; findAll(); // 查询所有方法&#125; 添加User持久层dao并使用注解配置 123456789101112131415161718public interface UserDao &#123; // 查询所有用户 @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;,value = &#123; // 建立数据库列和实体类字段名的一一对应 @Result(id = true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;userName&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;) &#125;) public List&lt;User&gt; findAll(); // 更加Id查询用户 @Select(&quot;Select * from user where id = #&#123;id&#125;&quot;) @ResultMap(&quot;userMap&quot;) // 使用userMap封装 public User findById(Integer id);&#125; 测试数据 123456789@Test public void findAllTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) &#123; System.out.println(&quot;-------------------------&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125; 测试延迟加载 123456789@Testpublic void lazyLoadingTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) &#123; System.out.println(account.getMoney()); System.out.println(account.getId()); &#125;&#125; 3. 使用注解开发一对多的复杂关系映射 需求：查询用户信息，按需查询其账号信息。（延迟加载） User中加入List&lt;Account&gt; 编写User持久层接口并使用注解配置 1234567891011121314151617public interface UserDao &#123; // 查询所有用户 @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;,value = &#123; // 建立数据库列和实体类字段名的一一对应 @Result(id = true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;userName&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;), @Result(column = &quot;id&quot;,property = &quot;accounts&quot;,many = @Many( select = &quot;top.tobing.dao.AccountDao.findByUid&quot;, fetchType = FetchType.LAZY )) &#125;) public List&lt;User&gt; findAll();&#125; 编写Account持久层接口并使用注解配置 1234567891011121314151617181920public interface AccountDao &#123; @Select(&quot;select * from account&quot;) @Results(id=&quot;accountMap&quot;, value = &#123; @Result(id = true,column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;uid&quot;,property = &quot;uid&quot;), @Result(column = &quot;money&quot;,property = &quot;money&quot;), @Result(column = &quot;uid&quot;, property = &quot;user&quot;, one=@One(select=&quot;top.tobing.dao.UserDao.findById&quot;, fetchType= FetchType.LAZY) ) &#125;) List&lt;Account&gt; findAll(); @Select(&quot;select * from account where uid = #&#123;uid&#125;&quot;) @ResultMap(&quot;accountMap&quot;) List&lt;Account&gt; findByUid();&#125; 添加测试方法 1234567@Testpublic void findAllTest() &#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user.getUserName()); &#125;&#125; 5. 注解实现开启二级缓存1. SqlMapConfig配置123456&lt;configuration &gt; &lt;settings&gt; &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; ......&lt;/configuration&gt; 2. 持久层注解开启二级缓存1234@CacheNamespace(blocking =true)public interface UserDao &#123; .....&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"Mybatis-6-延迟加载","slug":"Mybatis-6-延迟加载","date":"2019-11-30T13:15:57.000Z","updated":"2021-01-15T04:16:37.797Z","comments":true,"path":"2019/11/30/Mybatis-6-延迟加载/","link":"","permalink":"https://tobing.top/2019/11/30/Mybatis-6-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/","excerpt":"Mybatis学习第六弹。","text":"Mybatis学习第六弹。 Mybatis-6-延迟加载与缓存1. 延迟加载1. 什么是延迟加载 延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。 延迟加载(lazy load)是(也称为懒加载)。 2. 为什么要使用延迟加载 实际开发中一张表往往关联着其他表，但每次查询不一定要用到其他表。 查询一张表比查询多张表速度要快，可以大大提高查询速度。 3. 延迟加载存在的问题 由于是用到了数据才去加载，所以在用户大量使用查询的时候，会导致查询结果较慢。 4. 延迟加载应用示例 场景 Account和User表 表名 列名1 列名2 列名3 列名4 列名5 Account id uid money User id username birthday sex address User可以有多个Account（即是一对多）。 Account通过uid与唯一的User关联。 需求 在通过查询Account时，不直接查询出其中的User。 在需要使用User信息部分（例如：调用getUser模拟使用User信息）时，才实行加载。 分析 Account中有User的属性用于关联User表查询的信息。 不调用其中的getUser方法的时候不查询User的数据（延迟加载）。 在Account的dao.xml配置返回值的时候将resultMap中的association添加select明确是使用延迟加载来查询User属性。 编码 给Account实体类中添加唯一User属性 123456public class Account implements Serializable &#123; private int id; private int uid; private double money; private User user; // 唯一user&#125; 在UserDao中添加根据id查询唯一User的抽象方法findById。 123public interface UserDao &#123; public User findById(Integer uid);&#125; 在AccountDao中添加findAll查询所有的方法。 123public interface AccountDao &#123; public List&lt;Account&gt; findAll();&#125; 在AccountDao.xml中Mapper下添加关联findAll查询方法的配置。 123456789101112131415&lt;mapper namespace=&quot;top.tobing.dao.AccountDao&quot;&gt; &lt;resultMap id=&quot;accountMap&quot; type=&quot;top.tobing.domain.Account&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;top.tobing.domain.User&quot; select=&quot;top.tobing.dao.UserDao.findById&quot; column=&quot;uid&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountMap&quot;&gt; select * from account; &lt;/select&gt;&lt;/mapper&gt; 此步骤在association中包含了select，可以实现按需加载User。 在UserDao.xml中添加关联findById的方法。 12345&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;select id=&quot;findById&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; select * from user where id = #&#123;uid&#125;; &lt;/select&gt;&lt;/mapper&gt; 在测试方法中测试是否实现延迟加载 不调用getUser等，与User信息相关的方法。 1234567@Test public void findAllTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) &#123; System.out.println(account.getMoney()); &#125; &#125; 查询结果 1234567891011121314152019-11-28 12:18:36,346 224 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Opening JDBC Connection2019-11-28 12:18:36,578 456 [ main] DEBUG source.pooled.PooledDataSource - Created connection 1038677529.2019-11-28 12:18:36,578 456 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@3de8f619]2019-11-28 12:18:36,582 460 [ main] DEBUG .tobing.dao.AccountDao.findAll - ==&gt; Preparing: select * from account; 2019-11-28 12:18:36,617 495 [ main] DEBUG .tobing.dao.AccountDao.findAll - ==&gt; Parameters: 2019-11-28 12:18:36,673 551 [ main] DEBUG .tobing.dao.AccountDao.findAll - &lt;== Total: 620000.040000.030000.021000.040000.050000.02019-11-28 12:18:36,675 553 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@3de8f619]2019-11-28 12:18:36,675 553 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@3de8f619]2019-11-28 12:18:36,676 554 [ main] DEBUG source.pooled.PooledDataSource - Returned connection 1038677529 to pool. 只查询了一次。 &gt; id为42时，调用getUser方法 12345678910@Test public void findAllTest()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) &#123; System.out.println(account.getMoney()); if(account.getUid()==42)&#123; // 只有id为42才查询。 System.out.println(account.getUser()); &#125; &#125; &#125; &gt; 只有id为42，才去执行查询User表（调用UserDao.xml中的findById） 123456User&#123;id=42, username=&#x27;Rongon&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;江苏&#x27;&#125;30000.021000.040000.050000.0User&#123;id=42, username=&#x27;Rongon&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;江苏&#x27;&#125; 5. 练习：以第4为例，实现查询用户User表，延迟加载用户的Account信息。 User表中添加关联的Account的字段。 12345678public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; // 用户对应的多个账号&#125; AccountDao接口中添加按照uid查询多个Account的方法 123public interface AccountDao &#123; List&lt;Account&gt; findAllByUid(Integer uid);&#125; UserDao接口中添加按照查询所有的方法\\ 123public interface UserDao &#123; public List&lt;User&gt; findAllAccount();&#125; AccountDao.xml中添加AccountDao接口对应的方法的配置 123&lt;select id=&quot;findAllByUid&quot; resultMap=&quot;top.tobing.domain.Account&quot;&gt; select * from account where uid = #&#123;id&#125;;&lt;/select&gt; UserDao.xml中添加UserDao接口对应的方法配置。 1234567891011121314151617&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.tobing.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;association property=&quot;accounts&quot; javaType=&quot;List&quot; select=&quot;top.tobing.dao.AccountDao.findAllByUid&quot; column=&quot;id&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAllAccount&quot; resultMap=&quot;userMap&quot;&gt; select * from user; &lt;/select&gt; &lt;/mapper&gt; 注意： association中的javaType是account对应的数据类型（List） association中的column参数是传给top/tobing/AccountDao.xml中的findAllByUid对应的mapper. 检验是否实现延迟查询 1234567891011121314151617181920212019-11-28 16:21:04,172 501 [ main] DEBUG ing.dao.UserDao.findAllAccount - ==&gt; Preparing: select * from user; 2019-11-28 16:21:04,207 536 [ main] DEBUG ing.dao.UserDao.findAllAccount - ==&gt; Parameters: 2019-11-28 16:21:04,261 590 [ main] DEBUG ing.dao.UserDao.findAllAccount - &lt;== Total: 6Tobing男==============================Rongon男==============================Zenyet男==============================尼古拉斯男==============================张无忌男==============================张三丰男============================== 1234567891011121314151617181920212223242526272019-11-28 16:21:44,570 217 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Opening JDBC Connection2019-11-28 16:21:44,776 423 [ main] DEBUG source.pooled.PooledDataSource - Created connection 1314838582.2019-11-28 16:21:44,776 423 [ main] DEBUG ansaction.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@4e5ed836]2019-11-28 16:21:44,779 426 [ main] DEBUG ing.dao.UserDao.findAllAccount - ==&gt; Preparing: select * from user; 2019-11-28 16:21:44,816 463 [ main] DEBUG ing.dao.UserDao.findAllAccount - ==&gt; Parameters: 2019-11-28 16:21:44,868 515 [ main] DEBUG ing.dao.UserDao.findAllAccount - &lt;== Total: 6Tobing男2019-11-28 16:21:44,869 516 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Preparing: select * from account where uid = ?; 2019-11-28 16:21:44,870 517 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Parameters: 41(Integer)2019-11-28 16:21:44,871 518 [ main] DEBUG ng.dao.AccountDao.findAllByUid - &lt;== Total: 1[Account&#123;id=1, uid=41, money=20000.0&#125;]==============================Rongon男2019-11-28 16:21:44,880 527 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Preparing: select * from account where uid = ?; 2019-11-28 16:21:44,881 528 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Parameters: 42(Integer)2019-11-28 16:21:44,882 529 [ main] DEBUG ng.dao.AccountDao.findAllByUid - &lt;== Total: 2[Account&#123;id=2, uid=42, money=40000.0&#125;, Account&#123;id=6, uid=42, money=50000.0&#125;]==============================Zenyet男2019-11-28 16:21:44,882 529 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Preparing: select * from account where uid = ?; 2019-11-28 16:21:44,883 530 [ main] DEBUG ng.dao.AccountDao.findAllByUid - ==&gt; Parameters: 43(Integer)2019-11-28 16:21:44,883 530 [ main] DEBUG ng.dao.AccountDao.findAllByUid - &lt;== Total: 1[Account&#123;id=3, uid=43, money=30000.0&#125;]============================== 6. 总结 与之前的立即相比。延迟加载在要延迟加载的association中添加了select、column等属性。 select:用于指定调用那个方法执行查询延迟加载部分内容。 column：用于指定查询延迟加载部分的参数。 javaType：要合实体类一一对应。 所谓延迟加载，在此处的体现是，根据需求，决定是否调用其他的方法（该方法可以实现查询延迟加载的部分数据）。 2.Mybatis中的缓存1. 缓存 What：存储在内存中临时数据。 Why：减少和数据库交互次数，提高执行效率。 When： 使用缓存：数据经常查询、数据不经常改变、数据正确性对最终结果影响不大。 不使用缓存：数据经常改变、数据正确性对最终结果影响很大（例如：商品库存、银行汇率、股市牌价等） 2. Mybatis中缓存机制 一级缓存： 是指Mybatis中SqlSession对象的缓存 当我们执行查询后，查询的结果会存入到SqlSession对象提供的一块区域中（一个Map）。 当我们查询同样的数据时，Mybatis会先去SqlSession中的区域找，如果存在直接拿来用。 因为一级缓存保存在SqlSession，所以当SqlSession对象消失，一级缓存自动消失。 二级缓存： 是指存储在SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 Mybatis默认不开启二级缓存 SqlSession执行相同Mapper映射下sql，执行commit提交，将会清空Mapper映射下的二级缓存 3. 一级缓存 Mybatis中默认开启一级缓存 验证步骤 创建User、UserDao、UserDao.xml 1234567public class User &#123; private int id; private String username; private Date birthday; private String sex; private String address;&#125; UserDao中添加一个用于查询的查询方法 123public interface UserDao &#123; public User findById(int id);&#125; UserDao.xml配置查询的SQL语句 12345&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;select id=&quot;findById&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; select * from user where id = #&#123;id&#125; ; &lt;/select&gt;&lt;/mapper&gt; 验证缓存查询结果 12345public void findByIdTest()&#123; User user = userDao.findById(44); // 第一次查询 System.out.println(user); User user1 = userDao.findById(44); // 第二次查询 System.out.println(user1); 12345DEBUG op.tobing.dao.UserDao.findById - ==&gt; Preparing: select * from user where id = ? ; DEBUG op.tobing.dao.UserDao.findById - ==&gt; Parameters: 44(Integer)DEBUG op.tobing.dao.UserDao.findById - &lt;== Total: 1top.tobing.domain.User@7fd7a283top.tobing.domain.User@7fd7a283 两次查询出来的对象地址相同 验证清楚缓存 调用clearCache、close等方法。 123456789101112public void findByIdTest()&#123; User user = userDao.findById(44); // 第一次查询 System.out.println(user); // 再次获取session// session.close();// session = factory.openSession();// userDao = session.getMapper(UserDao.class); // 另外一种方式清空数据 session.clearCache(); User user1 = userDao.findById(44); // 第二次查询 System.out.println(user1); 结果查询了两次 调用了commit更新等操作。 12345678910@Test public void firstCacheTest()&#123; User user = userDao.findById(44); // 第一次查询 System.out.println(user); user.setUsername(&quot;CacheTest&quot;); userDao.updateUser(user); user = userDao.findById(44); System.out.println(user); System.out.println(&quot;--------------&quot;); &#125; 此处也会跳过缓存，直接查询。 4. 二级缓存 同一个SqlSessionFactory得到的SqlSession可以共享二级缓存数据。 使用步骤： SqlMapConfig中开启二级缓存 Mapper中开启二级缓存 statement中使用二级缓存 SQLMapConfig开启二级缓存 1234&lt;!--开启二级缓存--&gt;&lt;settings&gt; &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; Mapper中开启二级缓存、statement使用二级缓存 12345678&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;!--Mapper开启缓存--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--查询时使用缓存--&gt; &lt;select id=&quot;findById&quot; resultType=&quot;top.tobing.domain.User&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;id&#125; ; &lt;/select&gt;&lt;/mapper&gt; 检验结果 1234567891011121314@Testpublic void secondCacheTest()&#123; SqlSession sqlSession1 = factory.openSession(); UserDao userDao1 = sqlSession1.getMapper(UserDao.class); User user1 = userDao1.findById(44); System.out.println(user1); sqlSession1.close(); SqlSession sqlSession2 = factory.openSession(); UserDao userDao2 = sqlSession2.getMapper(UserDao.class); User user2 = userDao2.findById(44); System.out.println(user2); sqlSession2.close();&#125; 结果显示查询了一次。 5. 总结 缓存是可以数据库开销。 Mybatis中有两种缓存：一级缓存和二级缓存 一级缓存作用范围在SqlSession中，SqlSession，commit（增删改）会清空缓存。 二级缓存作用范围在SqlSessionFactory，即是一个SqlSessionFactory生产出来的SqlSession共享同一二级缓存。 二级缓存会随着同一mapper任意一个SqlSession进行了commit而清空 一级缓存不需要手动开启。 二级缓存需要设置SqlMapConfig、Mapper、和要查询的方法。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"Mybatis-5-多表查询2","slug":"Mybatis-5-多表查询2","date":"2019-11-23T02:13:15.000Z","updated":"2021-01-15T04:17:13.308Z","comments":true,"path":"2019/11/23/Mybatis-5-多表查询2/","link":"","permalink":"https://tobing.top/2019/11/23/Mybatis-5-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A22/","excerpt":"Mybatis学习第五弹。","text":"Mybatis学习第五弹。 Mybatis-5-多表查询21. 多对多1. 开发步骤 建表 创建Maven工程 添加坐标文件 编写SqlMapConfig文件 创建实体类 创建实体类对应的Dao 创建Dao对应的配置文件 编写测试类 1. 建表 模拟用户角色 分析：一个用户有多个角色（一个人有学生、儿子、朋友等角色），一个角色可以赋予给多个用户（学生可以是很多人等） 创建三张表：Role表、User表、用户角色管理表 2. 创建Maven工程（略）3. 添加坐标文件 给pom文件添加：mysql，mybatis，dom4j，log4j，junit等坐标。 4. 编写SqlMapConfig文件 在resources文件夹下创建SqlMapConfig.xml，添加约束，编写MySQL的配置。 5. 创建实体类 根据创建的表，创建对应实体类User、Role 1234567891011121314151617// 用户表public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // 存放多一个用户多个角色 private List&lt;Role&gt; roles;&#125;// 角色表public class Role &#123; private Integer id; private String roleName; private String roleDesc; private List&lt;User&gt; users;&#125; 6. 创建实体类对应的Dao 根据需求编写抽象方法 1234public interface RoleDao &#123; // 查询所有角色 List&lt;Role&gt; findAll();&#125; 1234public interface UserDao &#123; // 查询所有用户 List&lt;User&gt; findAll();&#125; 7. 创建Dao对应配置文件 resources下创建top/tobing/dao(与包名对应)目录，在目录下创建dao对应配置文件 123456&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;!--数据库表名与对应实体类一致--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; SELECT * from user; &lt;/select&gt;&lt;/mapper&gt; 12345678910111213&lt;mapper namespace=&quot;top.tobing.dao.RoleDao&quot;&gt; &lt;!--建立数据库【表列名】以及对应的【实体类字段】关系--&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;top.tobing.domain.Role&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&gt; &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;/&gt; &lt;/resultMap&gt; &lt;!--数据库表名与对应实体类不一致--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; SELECT * from role ; &lt;/select&gt;&lt;/mapper&gt; 注意：由于Role表与数据库的表名称不一致，因此需要通过建立resutlMap关联数据库表列名和实体类字段名称。 8. 编写测试类测试 test目录下，创建top.tobing.test包，创建对应Dao的测试类 123456789101112131415161718192021222324252627282930313233// 通用初始化public class RoleDaoTest &#123; private InputStream in; private SqlSession session; private RoleDao roleDao; /** * 初始化方法 */ @Before // 在方法执行前执行 public void init()&#123; try&#123; //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建工厂类 SqlSessionFactory factory =new SqlSessionFactoryBuilder().build(in); //3.生产SqlSession对象 session = factory.openSession(); //4.获取代理对象 roleDao = session.getMapper(RoleDao.class); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 释放资源 */ @After // 在方法执行之后执行 public void destroy() throws IOException &#123; session.commit(); // 此处记得提交事务 session.close(); in.close(); &#125; 12345678// RoleDao @Test public void findAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for (Role role : roles) &#123; System.out.println(role); &#125; &#125; 1234# 查询结果Role&#123;id=1, roleName=&#x27;院长&#x27;, roleDesc=&#x27;管理整个学院&#x27;&#125;Role&#123;id=2, roleName=&#x27;总裁&#x27;, roleDesc=&#x27;管理整个公司&#x27;&#125;Role&#123;id=3, roleName=&#x27;校长&#x27;, roleDesc=&#x27;管理整个学院&#x27;&#125; 9. 案例实现多对多查询 开发步骤 业务需求 根据业务需求分析出SQL语句 编写Dao、Dao配置文件 测试方法 检验结果 需求一 需求：实现查询所有角色，包含其对应的用户信息 编写SQL 12345678910111213141516SELECT r.*, u.id uid, -- 给id起别名，防止查询得到的表的结果冲突 u.username, u.birthday, u.sex, u.addressFROM role r INNER JOIN user_role urON (ur.rid = r.id)INNER JOIN USER uON (ur.uid = u.id ) -- 条件 编写Dao接口 1234public interface RoleDao &#123; List&lt;Role&gt; findAll();&#125; 编写Dao对应配置文件 123456789101112131415161718192021222324252627282930313233343536&lt;mapper namespace=&quot;top.tobing.dao.RoleDao&quot;&gt; &lt;!--建立数据库【表列名】以及对应的【实体类字段】关系--&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;top.tobing.domain.Role&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&gt; &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;/&gt; &lt;collection property=&quot;users&quot; ofType=&quot;top.tobing.domain.User&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--数据库表名与对应实体类一致--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; SELECT r.id, r.`role_desc`, r.`role_name`, u.id uid, -- 给id起别名，防止查询得到的表的结果冲突 u.username, u.birthday, u.sex, u.address FROM role r INNER JOIN user_role ur ON (ur.rid = r.id) INNER JOIN USER u ON (ur.uid = u.id ) &lt;/select&gt;&lt;/mapper&gt; 测试 12345678public void findAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for (Role role : roles) &#123; System.out.println(&quot;-------------------------&quot;); System.out.println(role); &#125; &#125; 检测结果 12345-------------------------Role&#123;id=1, roleName=&#x27;院长&#x27;, roleDesc=&#x27;管理整个学院&#x27;, users=[User&#123;id=41, username=&#x27;Tobing&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;四川&#x27;, roles=null&#125;, User&#123;id=45, username=&#x27;张无忌&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;广东&#x27;, roles=null&#125;]&#125;-------------------------Role&#123;id=2, roleName=&#x27;总裁&#x27;, roleDesc=&#x27;管理整个公司&#x27;, users=[User&#123;id=41, username=&#x27;Tobing&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;四川&#x27;, roles=null&#125;]&#125; 需求二 查询所有的用户，包含其角色 SQL语句 1234567891011121314SELECT u.*, r.`id`, r.`role_desc`, r.`role_name`FROM USER uINNER JOIN user_role urON (ur.uid = u.`id`)INNER JOIN role rON (r.`id` = ur.`rid`) Dao接口 12345678public interface UserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; Dao接口配置文件 123456789101112131415161718192021222324252627282930313233&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.tobing.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;collection property=&quot;roles&quot; ofType=&quot;top.tobing.domain.Role&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;/&gt; &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--数据库表名与对应实体类一致--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;SELECT u.*, r.`id`, r.`role_desc`, r.`role_name`FROM USER uINNER JOIN user_role urON (ur.uid = u.`id`)INNER JOIN role rON (r.`id` = ur.`rid`) &lt;/select&gt;&lt;/mapper&gt; 测试 检验 12345-------------User&#123;id&#x3D;41, username&#x3D;&#39;Tobing&#39;, birthday&#x3D;null, sex&#x3D;&#39;男&#39;, address&#x3D;&#39;四川&#39;, roles&#x3D;[Role&#123;id&#x3D;41, roleName&#x3D;&#39;院长&#39;, roleDesc&#x3D;&#39;管理整个学院&#39;, users&#x3D;null&#125;]&#125;-------------User&#123;id&#x3D;45, username&#x3D;&#39;张无忌&#39;, birthday&#x3D;null, sex&#x3D;&#39;男&#39;, address&#x3D;&#39;广东&#39;, roles&#x3D;[Role&#123;id&#x3D;45, roleName&#x3D;&#39;院长&#39;, roleDesc&#x3D;&#39;管理整个学院&#39;, users&#x3D;null&#125;]&#125; 总结 多表查询的难点在于把需求转换为SQL语句 把SQL写出来，根据查询得到的数据，可以轻易写出Dao.xml配置文件。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"Mybatis-4-多表查询1","slug":"Mybatis-4-多表查询1","date":"2019-11-23T02:13:02.000Z","updated":"2021-01-15T04:17:43.735Z","comments":true,"path":"2019/11/23/Mybatis-4-多表查询1/","link":"","permalink":"https://tobing.top/2019/11/23/Mybatis-4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A21/","excerpt":"Mybatis学习第四弹。","text":"Mybatis学习第四弹。 Mybatis-4-多表查询1 表之间的关系：多对一、一对多、多对多。 Mybatis中多表查询的步骤 建表 构建对应的实体类 建立对应的配置文件 实现配置：查询A表时可以得到A中包含B表的信息，反之亦然。 1. 一对一方式一 需求：查询使用账户信息，关联查询下单的用户信息。 建表 123456789101112131415161718192021222324252627282930-- 创建user表DROP TABLE IF EXISTS USER ;-- 如果存在则删除该表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) NOT NULL , birthday DATE, sex CHAR(1) , address VARCHAR(256));-- 创建account表DROP TABLE IF EXISTS account;CREATE TABLE account( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, uid INT , money DOUBLE, FOREIGN KEY(uid) REFERENCES USER(id));-- 给user添加数据INSERT INTO USER VALUES (41,&#x27;Tobing&#x27;,NULL,&#x27;男&#x27;,&#x27;四川&#x27;), (NULL,&#x27;Rongon&#x27;,NULL,&#x27;男&#x27;,&#x27;江苏&#x27;), (NULL,&#x27;Zenyet&#x27;,NULL,&#x27;男&#x27;,&#x27;广东&#x27;), (NULL,&#x27;尼古拉斯&#x27;,NULL,&#x27;男&#x27;,&#x27;英国&#x27;);-- 给account添加数据INSERT INTO account VALUES (1,41,20000),(2,42,40000), (3,43,30000),(4,44,21000); 构建实体类 12345678910111213141516171819202122232425262728// account表实体类public class Account implements Serializable &#123; private int id; private int uid; private double money; //setter and getter ..... //toString&#125;// User表实体类public class User &#123; private int id; private String username; private Date birthday; private String sex; private String address; //setter and getter ..... //toString&#125;// 一对一多表查询结果的实体类public class AccountUser extends Account implements Serializable &#123; private int id; private int uid; private double money; private String username; private String address; //setter and getter ..... //toString&#125; 建立配置文件 1234public interface UserDao &#123; public List&lt;User&gt; findAll(); // 查询所有的用户 public User findById(int id); // 通过id查询用户&#125; 123456789&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; SELECT * from user ; &lt;/select&gt; &lt;select id=&quot;findById&quot; resultType=&quot;top.tobing.domain.User&quot; parameterType=&quot;java.lang.Integer&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; 1234public interface AccountDao &#123; public List&lt;AccountUser&gt; findAll();// 多表查询用户以及账户信息 &#125; 12345&lt;mapper namespace=&quot;top.tobing.dao.AccountDao&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.tobing.domain.AccountUser&quot;&gt; SELECT account.*,user.username,user.address FROM account,USER WHERE account.uid = user.id; &lt;/select&gt;&lt;/mapper&gt; 执行操作 1234567891011 // 申请资源// 释放资源@Test public void findAllTest() throws IOException &#123; //5.执行查询语句 List&lt;AccountUser&gt; accountUsers = accountDao.findAll(); //6.遍历输出 for(AccountUser au:accountUsers)&#123; System.out.println(au); &#125; &#125; 关键：写出多表查询的SQL语句，根据sql语句编写配置文件。 2. 方式二一对一 建表 构建实体类 编写Dao接口 编写接口对应的配置文件 使用Test查询 构建实体类 12345678910111213141516public class User &#123; private int id; private String username; private Date birthday; private String sex; private String address; ...&#125;public class Account implements Serializable &#123; private int id; private int uid; private double money; private User user; // 使用内置User对象的方式存放User数据 ...&#125; 编写AccountDao接口 123// 将多表查询到的数据直接封装到Account中public List&lt;Account&gt; findAllAccount(); 编写接口对应的配置文件:AccountDao.xml 123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;top.tobing.dao.AccountDao&quot;&gt; &lt;!--Account内建User存储数据--&gt; &lt;!--建立对应关系--&gt; &lt;resultMap id=&quot;account&quot; type=&quot;top.tobing.domain.Account&quot;&gt; &lt;!--对应着Account表中的id，uid，money基本类型属性--&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;!--联系着表的实体类属性--&gt; &lt;association property=&quot;user&quot; javaType=&quot;top.tobing.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAllAccount&quot; resultMap=&quot;account&quot;&gt; select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid = u.id; &lt;/select&gt;&lt;/mapper&gt; resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 说明 使用Test查询测试 12345678910@Testpublic void findAllAccountTest()&#123; List&lt;Account&gt; list = accountDao.findAllAccount(); for (Account account : list) &#123; System.out.println(&quot;------------------------------&quot;); System.out.println(account.getUser()); System.out.println(account); &#125;&#125; 运行结果 12345678910111213------------------------------User&#123;id=41, username=&#x27;Tobing&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;四川&#x27;&#125;Account&#123;id=1, uid=41, money=20000.0&#125;------------------------------User&#123;id=42, username=&#x27;Rongon&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;江苏&#x27;&#125;Account&#123;id=2, uid=42, money=40000.0&#125;------------------------------User&#123;id=43, username=&#x27;Zenyet&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;广东&#x27;&#125;Account&#123;id=3, uid=43, money=30000.0&#125;------------------------------User&#123;id=44, username=&#x27;尼古拉斯&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;英国&#x27;&#125;Account&#123;id=4, uid=44, money=21000.0&#125; 3. 一对多 需求：在User定义Accounts属性，用于存储一个用户的多个账号。 步骤： 修改User 修改UserDao接口 修改UserDao配置文件【重点】 编写测试方法 修改User类：给User类添加多个account的属性 12345678910public class User &#123; private int id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; // 新添加的accounts属性，用于存储一个用户的多个账号 ...&#125; 修改UserDao接口：新添加查询User类，包含accounts。 123// 新添加用于查询的方法public List&lt;User&gt; findAllAccounts(); 修改UserDao配置文件：添加封装accounts的配置文件【重点】 123456789101112131415161718192021222324252627282930&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;!--定义User结果集--&gt; &lt;resultMap id=&quot;userAccountsMap&quot; type=&quot;top.tobing.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;top.tobing.domain.Account&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAllAccounts&quot; resultMap=&quot;userAccountsMap&quot;&gt; select u.id, u.username, u.birthday, u.sex, u.address, account.id, account.uid, account.money from user u left join account on u.id = account.uid &lt;/select&gt;&lt;/mapper&gt; collection 标签 用于建立【一对多】中集合元素属性的对应关系。 此处定义了用户关联的账户信息【关联账户查询结果集】 ofType属性：指定结合元素的数据类型 分析 测试 12345678910@Test public void findAllAccountsTest()&#123; List&lt;User&gt; allAccounts = userDao.findAllAccounts(); for (User allAccount : allAccounts) &#123; System.out.println(&quot;------------------------&quot;); System.out.println(allAccount); System.out.println(allAccount.getAccounts()); &#125; &#125; 运行结果 12345678910111213141516------------------------User&#123;id=41, username=&#x27;Tobing&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;四川&#x27;&#125;[Account&#123;id=0, uid=41, money=20000.0&#125;]------------------------User&#123;id=42, username=&#x27;Rongon&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;江苏&#x27;&#125;[Account&#123;id=0, uid=42, money=40000.0&#125;, Account&#123;id=0, uid=42, money=50000.0&#125;]------------------------User&#123;id=43, username=&#x27;Zenyet&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;广东&#x27;&#125;[Account&#123;id=0, uid=43, money=30000.0&#125;]------------------------User&#123;id=44, username=&#x27;尼古拉斯&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;英国&#x27;&#125;[Account&#123;id=0, uid=44, money=21000.0&#125;, Account&#123;id=0, uid=44, money=40000.0&#125;]------------------------User&#123;id=46, username=&#x27;张三丰&#x27;, birthday=null, sex=&#x27;男&#x27;, address=&#x27;蜀山&#x27;&#125;[] 总结 无论是一对多还是一对一，编写时关键点在于能把SQL写出，再把SQL语句转换到配置文件中。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"Mybatis-3-动态SQL","slug":"Mybatis-3-动态SQL","date":"2019-11-23T02:12:52.000Z","updated":"2021-01-15T03:12:59.839Z","comments":true,"path":"2019/11/23/Mybatis-3-动态SQL/","link":"","permalink":"https://tobing.top/2019/11/23/Mybatis-3-%E5%8A%A8%E6%80%81SQL/","excerpt":"Mybatis学习第三弹。","text":"Mybatis学习第三弹。 Mybatis-3-动态SQLif标签 当我们传入的条件是多个，且不同条件查询语句不同的时候常常使用if 12345678910&lt;select id=&quot;findByUser&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username !=null and username!=&#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/select&gt; where标签 简化了 1 = 1 123456789101112&lt;select id=&quot;findByUser&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;username !=null and username!=&#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; foreach标签 诸如：select * from user id in（1,2,….） …..的语句 12345678910&lt;select id=&quot;findByIds&quot; resultType=&quot;top.tobing.domain.User&quot; parameterType=&quot;top.tobing.domain.QueryVo&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;ids!=null and ids.size()&gt;0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot; id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach的标签： collection：代表要遍历的集合元素，编写时不能写#{} open：代表语句开始的部分 close：代表语句结束的部分 separator：遍历元素之间的分隔符 item：代表遍历集合的每个元素的变量名 定义代码片段 当重复的语句过多的时候，可以自定义代码片段 123&lt;sql id=&quot;idySql&quot;&gt; select * from user&lt;/sql&gt; 引用自定义的代码片段：include标签 1234567891011&lt;select id=&quot;findByUser&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; &lt;include refid=&quot;diySql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;username !=null and username!=&#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 案例演示 UserDao.xml配置文件 12345678910111213141516171819202122232425262728293031323334&lt;!------------------------------定义变量-----------------------------&gt;&lt;sql id=&quot;diySql&quot;&gt; select * from user &lt;/sql&gt;&lt;!-----------------------------使用where和if标签动态查询------------------------------&gt;&lt;select id=&quot;findByUser&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; &lt;include refid=&quot;diySql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;username !=null and username!=&#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-----------------------------使用foreach动态查询------------------------------&gt;&lt;select id=&quot;findByIds&quot; resultType=&quot;top.tobing.domain.User&quot; parameterType=&quot;top.tobing.domain.QueryVo&quot;&gt; &lt;include refid=&quot;diySql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;user!=null&quot;&gt; &lt;if test=&quot;user.username!=null and user.username!=&#x27;&#x27;&quot;&gt; and username = #&#123;user.username&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test=&quot;ids!=null and ids.size()&gt;0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot; id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试方法 1234567891011121314151617181920212223242526272829303132333435363738public void findByOvTest() &#123; User u = new User(); u.setUsername(&quot;小二王&quot;); QueryVo ov = new QueryVo(); ov.setUser(u); List&lt;User&gt; users = userDao.findByOv(ov); for (User user : users) &#123; System.out.println(user); &#125;&#125; @Testpublic void findByUserTest()&#123; User u = new User(); u.setUsername(&quot;小二王&quot;); u.setAddress(&quot;%上海%&quot;); List&lt;User&gt; users = userDao.findByUser(u); for (User user : users) &#123; System.out.println(user); &#125;&#125; @Testpublic void findByIdsTest()&#123; //User u = new User(); //u.setUsername(&quot;小二王&quot;); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(42); ids.add(58); ids.add(48); QueryVo ov = new QueryVo(); //ov.setUser(u); ov.setIds(ids); List&lt;User&gt; users = userDao.findByIds(ov); for (User user : users) &#123; System.out.println(user); &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"Mybatis-2-CRUD","slug":"Mybatis-2-CRUD","date":"2019-11-23T02:12:31.000Z","updated":"2021-01-15T03:19:25.358Z","comments":true,"path":"2019/11/23/Mybatis-2-CRUD/","link":"","permalink":"https://tobing.top/2019/11/23/Mybatis-2-CRUD/","excerpt":"Mybatis学习第二弹。","text":"Mybatis学习第二弹。 Mybatis-2-简单CRUD 步骤 创建Maven工程 关联坐标 编写实体类和持久层接口 编写SqlMapConfig.xml 编写映射配置文件 编写测试类 添加其他查询功能 使用要求 持久层接口和持久层接口的映射配置必须在相同包下 持久层映射中mapper标签的namespace属性取值必须是持久层接口的全限定类名。 SQL语句的配置标签：select、insert、delete、update的id属性必须和持久层接口的方法名相同。 1. 创建Maven工程2. 导入坐标 pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 编写实体类和持久层接口 在main-&gt;java下讲解domain和dao包 domain-&gt;User实体类 12345678910111213141516package top.tobing.domain;import java.util.Date;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // getter and setter..... @Override public String toString() &#123; return ..... &#125;&#125; dao-&gt;UserDao持久层接口 12345678package top.tobing.dao;import top.tobing.domain.User;import java.util.List;public interface UserDao &#123; public List&lt;User&gt; findAll();&#125; 4. 编写SqlMapConfig.xml SqlMapConfig.xml用于配置数据库相关信息。以及关联UserDao的配置文件。 在resources目下新建SQLMapConfig.xml文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration &gt; &lt;!--连接数据库环境--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--连接数据库信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ee50&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;top/tobing/dao/UserDao.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5. 编写映射配置文件 每一个Dao接口对应一个映射配置文件 在resources下创建UserDao三级目录top-&gt;tobing-&gt;dao（记住要一级一级创建，不能和包一样创建） 在dao目录下创建UserDao.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.tobing.domain.User&quot;&gt; SELECT * from user ; &lt;/select&gt;&lt;/mapper&gt; namespace：要绑定Dao接口 id：指定Dao接口中的方法 resultType：设置返回值类型（全限定类名） 6. 编写测试类 test-&gt;java下创建top.tobing.test包，并创建UserDaoTest测试类用于测试是否可用。 1234567891011121314151617181920212223242526272829303132333435package top.tobing.test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import top.tobing.dao.UserDao;import top.tobing.domain.User;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserDaoTest &#123; @Test public void findAllTest() throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建工厂类 SqlSessionFactory factory =new SqlSessionFactoryBuilder().build(in); //3.生产SqlSession对象 SqlSession session = factory.openSession(); //4.获取代理对象 UserDao userDao = session.getMapper(UserDao.class); //5.执行查询语句 List&lt;User&gt; users = userDao.findAll(); //6.遍历输出 for(User user:users)&#123; System.out.println(user); &#125; //7.关闭资源 session.close(); in.close(); &#125;&#125; 7. 其他CRUD操作 到Dao接口中添加新方法 同时在UserDao.xml中管理方法，编写Sql 语句 在UserDaoTest中添加新的对应的测试方法 1. Dao接口中添加新方法1public User findById(int id); 2. UserDao.xml中绑定该方法，编写Sql语句123456&lt;mapper namespace=&quot;top.tobing.dao.UserDao&quot;&gt; ...... &lt;select id=&quot;findById&quot; resultType=&quot;top.tobing.domain&quot; parameterType=&quot;java.lang.Integer&quot;&gt; select * from user where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; 3. 在UserDaoTest中添加对应的测试方法12345678910111213141516171819@Test public void findById() throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建工厂类 SqlSessionFactory factory =new SqlSessionFactoryBuilder().build(in); //3.生产SqlSession对象 SqlSession session = factory.openSession(); //4.获取代理对象 UserDao userDao = session.getMapper(UserDao.class); //5.执行查询语句 User user = userDao.findById(49); //6.输出 System.out.println(user); //7.关闭资源 session.close(); in.close(); &#125; 8. 优化 由UserDaoTest中的代码可以看出，在每次创建测试类的时候都要读取配置文件，创建工厂类，获取SqlSession对象等，重复代码较多，因此考虑抽取共性部分将其封装为两个方法。 123456789101112131415161718192021222324252627282930313233private InputStream in;private SqlSession session;private UserDao userDao; /** * 初始化方法 */@Before // 在方法执行前执行public void init()&#123; try&#123; //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建工厂类 SqlSessionFactory factory =new SqlSessionFactoryBuilder().build(in); //3.生产SqlSession对象 session = factory.openSession(); //4.获取代理对象 userDao = session.getMapper(UserDao.class); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; /** * 释放资源 */@After // 在方法执行之后执行public void destroy() throws IOException &#123; session.commit(); // 此处记得提交事务 session.close(); in.close();&#125; 9. 批量CRUD 步骤 UserDao UserDao.xml UsetDaoTest 1. UserDao添加方法 java.top.tobing.dao.UserDao 1234567891011// 保存用户public void save(User user);// 更新用户void updateUser(User user);//根据Id删除用户void deleteUser(Integer serId);// 根据用户名模糊查找List&lt;User&gt; findByName(String name);// 查找用户记录条数int findTotal(); 2. UserDao.xml修改配置 resources-&gt;top/tobing/dao/UserDao.xml 123456789101112131415161718192021222324252627282930&lt;!---------------------------------------save-------------------------------------&gt;&lt;!--注意！在传入参数的时候，在sql语句中获取User的属性的时候，要以getAbc的方法为准，也就是说。要获取User中的getAbc()对应获取的属性，就填写#&#123;abc&#125;，即是getAbc方法去掉get并将首字母小写。--&gt;&lt;insert id=&quot;save&quot; parameterType=&quot;top.tobing.domain.User&quot;&gt; &lt;!--此处配置使用与保持添加之后自增长id--&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; INSERT into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);&lt;/insert&gt;&lt;!---------------------------------------updateUser-------------------------------------&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;top.tobing.domain.User&quot;&gt; update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id = #&#123;id&#125;;&lt;/update&gt;&lt;!---------------------------------------deleteUser-------------------------------------&gt;&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id = #&#123;id&#125;;&lt;/delete&gt;&lt;!---------------------------------------findByName-------------------------------------&gt;&lt;select id=&quot;findByName&quot; resultType=&quot;top.tobing.domain.User&quot; parameterType=&quot;java.lang.String&quot;&gt; SELECT * from user where username like #&#123;username&#125;;&lt;/select&gt;&lt;!---------------------------------------findTotal-------------------------------------&gt;&lt;select id=&quot;findTotal&quot; resultType=&quot;java.lang.Integer&quot;&gt; select count(*) from user;&lt;/select&gt; 3. 编写对应测试方法测试 test-&gt;java-&gt;top.tobing.test-&gt;UserDaoTest 12345678910111213141516171819202122232425262728293031323334@Testpublic void updateUserTest()&#123; User user = new User(); user.setUsername(&quot;张翠山&quot;); user.setAddress(&quot;广东省广州市&quot;); user.setSex(&quot;男&quot;); user.setId(50); user.setBirthday(new Date()); UserDao userDao = session.getMapper(UserDao.class); userDao.updateUser(user);&#125;@Testpublic void deleteUserTest()&#123; userDao.deleteUser(51);&#125;@Testpublic void findByIdTest()&#123; User user = userDao.findById(49); System.out.println(user);&#125;@Testpublic void findByNameTest()&#123; List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;); for (User user : users) &#123; System.out.println(user); &#125;&#125;@Testpublic void findTotlaTest()&#123; int total = userDao.findTotal(); System.out.println(&quot;数据条数为：&quot;+total);&#125; 细节 在sql语句中使用#{}字符： 它代表占位符，相当于原来 jdbc 部分所学prepareStatment的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 使用的是ognl表达式 ognl表达式 是Apache提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言。 一定的语法格式来获取数据：#{对象.对象} parameterType配置参数 基 本类 型和 String 我 们可 以直接 写类型 名称 ，也 可以 使用包 名 . 类名的 方式 ，例如 ： java.lang.String。 实体类类型（自定义），目前我们只能使用全限定类名 是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名， 而我们的是实体类并没有注册别名，所以必须写全限定类名。 resultType配置 resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 123456789101112131415161718&lt;!-- 建立 User 实体和数据库表的对应关系type 属性：指定实体类的全限定类名 id 属性：给定一个唯一标识，是给查询 select 标签引用用的。 --&gt; &lt;resultMap type=&quot;top.tobing.domain.User&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;userAddress&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;userBirthday&quot;/&gt; &lt;/resultMap&gt; id 标签：用于指定主键字段 result 标签：用于指定非主键字段 column 属性：用于指定数据库列名 property 属性：用于指定实体类属性名称 SqlMapConfig.xml配置文件 123456789101112131415161718-properties（属性） --property -settings（全局配置参数） --setting -typeAliases（类型别名） --typeAliase --package -typeHandlers（类型处理器） -objectFactory（对象工厂） -plugins（插件） -environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源） -mappers（映射器） --mapper --package properties（属性）配置的两种方式 直接定义 1234567&lt;properties&gt; &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;/&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;1234&quot;/&gt; &lt;/properties&gt; 引用定义 1234567891011121314151617&lt;!-- 配置连接数据库的信息 resource 属性：用于指定 properties配置文件的位置，要求配置文件必须在类路径下 resource=&quot;jdbcConfig.properties&quot; url 属性： URL： Uniform Resource Locator 统一资源定位符 http://localhost:8080/mystroe/CategoryServlet URL 协议 主机 端口 URI URI：Uniform Resource Identifier 统一资源标识符 /mystroe/CategoryServlet 它是可以在 web 应用中唯一定位一个资源的路径 --&gt;&lt;properties url=&quot;file:///D:/IdeaProjects/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.prop erties&quot;&gt; &lt;/properties&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; typeAliases(类型别名) Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发 12345678&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;top.tobing.domain.User&quot;/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name=&quot;top.tobing.domain&quot;/&gt; &lt;package name=&quot; 其它包 &quot;/&gt; &lt;/typeAliases&gt; mappers（映射器）尚未弄懂 resource：使用相对于类路径的资源 12&lt;mapper resource=&quot;top/tobing/dao/IUserDao.xml&quot; /&gt; class：使用mapper接口类路径 12&lt;mapper class=&quot;top.tobing.dao.UserDao&quot;/&gt; name：注册指定包下的使用Mapper接口 12&lt;package name=&quot;top.tobing.mybatis.mapper&quot;/&gt;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"MySQL-4-多表查询与事务","slug":"MySQL-4-多表查询与事务","date":"2019-11-23T02:11:26.000Z","updated":"2021-01-15T03:13:57.607Z","comments":true,"path":"2019/11/23/MySQL-4-多表查询与事务/","link":"","permalink":"https://tobing.top/2019/11/23/MySQL-4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/","excerpt":"MySQL学习第四弹。","text":"MySQL学习第四弹。 MySQL-4-多表查询与事务1. 多表查询 语法 123456select [列名列表]from [表名列表]where ..... 案例准备：两张表，部门表、员工表 123456789101112131415161718192021222324-- 创建部门表create table dept( id int primary key auto_increment, -- id 主键 自增长 name varchar(20));-- 创建员工表create table emp( id int primary key auto_increment, -- id 主键 自增长 name varchar(20), -- 姓名 gender char(1), -- 性别 salary double, -- 薪资 join_date date, -- 入职时间 dept_id int, foreign key(dept_id) references dept(id) -- 外键，关联dept表中的id);-- 给部门表添加信息insert into dept(name) values(&#x27;开发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;);-- 给员工表插入数据insert into emp(name,gender,salary,join_date,dept_id) values (&#x27;Tobing&#x27;,&#x27;男&#x27;,10000,&#x27;2018-10-01&#x27;,1), (&#x27;Rongon&#x27;,&#x27;男&#x27;,12000,&#x27;2018-10-01&#x27;,2), (&#x27;Zenyet&#x27;,&#x27;男&#x27;,13000,&#x27;2018-11-01&#x27;,1), (&#x27;Actogo&#x27;,&#x27;男&#x27;,10000,&#x27;2018-10-02&#x27;,2), (&#x27;尼古拉斯&#x27;,&#x27;男&#x27;,10000,&#x27;2018-10-01&#x27;,3); 笛卡尔积 每张表中元素的排列组合。 例如，集合A（n条数据）和集合B（m条数据），其笛卡尔积为m * n条 1234-- emp有3条数据-- dept有5条数据-- 以下语句查询为两表的笛卡尔积，一共15条数据SELECT * FROM emp,dept; 笛卡尔积得出的数据很多都是无用的，实际中常常根据需求消除数据。 1234567-- 查询emp表中每个员工的姓名，id，薪资以及部门。SELECT -- 查询emp表中的id、nam、salary以及dept表中的name emp.id,emp.name,emp.`salary`,dept.`name` FROM emp,dept -- 此处通常可以起别名WHERE emp.`dept_id`= dept.id; 多表查询的分类 内连接查询：显示、隐式 外连接查询：左外连接、右外连接 隐式内连接：使用where消除无用数据 1234567-- 以上笛卡尔积实例代码就是隐式外连接select [列名列表]from 表1，表2...where ..... 显示内连接 语法 1select 字段列表 from 表1 [inner] join 表2 on 条件 示例 12345678910SELECT * FROM emp JOIN dept ON emp.`dept_id`=dept.`id`;SELECT * FROM dept JOIN emp ON emp.`dept_id` = dept.id;SELECT dept.`name` ,emp.`name`, emp.`salary` FROM dept JOIN emp ON emp.`dept_id` = dept.id; 内连接查询 需要那些表的数据 条件是什么 查询什么字段 ​ 左外连接：查询【左表】中的所有数据，以及右表中与左表【交集部分】 语法 1select 字段列表 from 表1 left [outer] join 表2 on 条件; 示例：查emp表中的所有员工【存在部门为null】，以及每个员工对应的部门。 123-- 此处是可以查出dept_id 为null的员工select * from emp left join dept on emp.dept_id = dept.id; 右外连接：查询【右表】中的所有数据，以及左表中与右表【交集部分】 子查询 查询中嵌套查询，嵌套查询就称为子查询 子查询结果为单行单列 子查询结果为多行单列 子查询结果为多行多列 子查询结果为单行单列【用于条件】 需求：查询所有大于平均薪资的员工 结果用于条件。 12345678select name,salary from emp where salary &gt; (select avg(salary) from emp); -- 以上语句==&gt; avg.. 得到平均，在使用where查询 子查询结果为多行单列【使用in，用于条件】 需求：查询财务表和市场部所有员工 123456789select * from emp where dept_id in (select id from dept where name in(&#x27;财务部&#x27;,&#x27;市场部&#x27;)); -- 得到财务部和市场部的id 子查询结果为多行多列【用于虚拟表参与查询】 需求：查询入职时间为2019-10-01之后的员工信息和部门信息 12345678select * from dept t1, (select * from emp where emp.join_date &gt; &#x27;2018-10-01&#x27;) t2 -- 起别名where t1.id = t2.dept_id 从员工入职时间大于2018-10-01的【表t2】中，以及【dept表】中。查询两个id对应的信息。 t2是子查询得到的多行多列的，可以理解为一张新表 以上代码也可以通过内连接来实现相同功能。 12select * from dept,emp where emp.join_date &gt; &#x27;2018-10-01&#x27; and emp.dept_id = dept.id; 2. 多表查询案例 创建三张表 添加数据 根据需求查询 创建4张表：部门表dept、职务表job、工作等级表和员工表 1234567891011121314151617181920212223242526272829303132-- 创建部门表create table dept( id int primary key auto_increment, dname varchar(50), -- 部门名称 loc varchar(50) -- 工作地点);-- 创建职务表create table job( id int primary key, jname varchar(20), -- 职务名称 description varchar(50) -- 职务描述);-- 创建员工表create table emp( id int primary key auto_increment, ename varchar(50), -- 员工姓名 job_id int, -- 职务id mgr int, -- 上级领导 joindate date, -- 入职日期 salary double, -- 薪资 bonus double, -- 奖金 dept_id int, -- 部门编号 constraint emp_jobid_ref_job_id_fk foreign key (job_id) references job(id), foreign key(job_id) references job(id) -- 简写外键);-- 创建工资等级表create table salarygrade( grade int primary key, -- 等级 losalary int, -- 最高工资 hisalary int -- 最低工资); 分别给4张表添加数据 1234567891011121314151617181920212223242526272829303132333435363738-- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,&#x27;教研部&#x27;,&#x27;北京&#x27;), (20,&#x27;学工部&#x27;,&#x27;上海&#x27;), (30,&#x27;销售部&#x27;,&#x27;广州&#x27;), (40,&#x27;财务部&#x27;,&#x27;深圳&#x27;); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, &#x27;董事长&#x27;, &#x27;管理整个公司，接单&#x27;), (2, &#x27;经理&#x27;, &#x27;管理部门员工&#x27;), (3, &#x27;销售员&#x27;, &#x27;向客人推销产品&#x27;), (4, &#x27;文员&#x27;, &#x27;使用办公软件&#x27;); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20), (1002,&#x27;卢俊义&#x27;,3,1006,&#x27;2001-02-20&#x27;,&#x27;16000.00&#x27;,&#x27;3000.00&#x27;,30), (1003,&#x27;林冲&#x27;,3,1006,&#x27;2001-02-22&#x27;,&#x27;12500.00&#x27;,&#x27;5000.00&#x27;,30), (1004,&#x27;唐僧&#x27;,2,1009,&#x27;2001-04-02&#x27;,&#x27;29750.00&#x27;,NULL,20), (1005,&#x27;李逵&#x27;,4,1006,&#x27;2001-09-28&#x27;,&#x27;12500.00&#x27;,&#x27;14000.00&#x27;,30), (1006,&#x27;宋江&#x27;,2,1009,&#x27;2001-05-01&#x27;,&#x27;28500.00&#x27;,NULL,30), (1007,&#x27;刘备&#x27;,2,1009,&#x27;2001-09-01&#x27;,&#x27;24500.00&#x27;,NULL,10), (1008,&#x27;猪八戒&#x27;,4,1004,&#x27;2007-04-19&#x27;,&#x27;30000.00&#x27;,NULL,20), (1009,&#x27;罗贯中&#x27;,1,NULL,&#x27;2001-11-17&#x27;,&#x27;50000.00&#x27;,NULL,10), (1010,&#x27;吴用&#x27;,3,1006,&#x27;2001-09-08&#x27;,&#x27;15000.00&#x27;,&#x27;0.00&#x27;,30), (1011,&#x27;沙僧&#x27;,4,1004,&#x27;2007-05-23&#x27;,&#x27;11000.00&#x27;,NULL,20), (1012,&#x27;李逵&#x27;,4,1006,&#x27;2001-12-03&#x27;,&#x27;9500.00&#x27;,NULL,30), (1013,&#x27;小白龙&#x27;,4,1004,&#x27;2001-12-03&#x27;,&#x27;30000.00&#x27;,NULL,20), (1014,&#x27;关羽&#x27;,4,1007,&#x27;2002-01-23&#x27;,&#x27;13000.00&#x27;,NULL,10);-- 添加工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); 按照需求查询从三张表中查询相应数据 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 123456789101112select -- 2. 分析需要查询的数据 emp.id, emp.ename, emp.salary, job.jname, job.descriptionfrom -- 1. 分析需要使用的表 emp, jobwhere -- 3. 分析查询数据的条件 emp.job_id = job.id; 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 1234567891011121314select -- 2. 分析查询的数据 emp.ename, emp.salary, job.jname, job.description, dept.dname, dept.locfrom -- 1. 分析需要的表 emp, job, deptwhere -- 3. 分析查询条件 emp.job_id = job.id and emp.dept_id = dept.id; 查询员工姓名，工资，工资等级 1234567891011select -- 2. 分析显示的数据 emp.ename, emp.salary, salarygrade.gradefrom -- 1.分析需要表 emp, salarygradewhere -- 3. 分析条件【重点，难点】 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary -- emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 12345678910111213141516select -- 2. 分析显示的数据 emp.ename, emp.salary, job.description, job.jname, dept.loc, salarygrade.gradefrom -- 1.分析需要表 emp, job, salarygrade, deptwhere -- 3. 分析条件【重点，难点】 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary and emp.job_id = job.id and emp.dept_id = dept.id; -- emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary 查询出部门编号、部门名称、部门位置、部门人数 条件分析： 1. 先统计出emp表中的每个部门的人数。 2. 根据统计部门人数的表，以及部门表查询出结果 1234567891011select dept.id, dept.dname, dept.loc, t2.totalfrom dept t1, (select dept_id,count(id) total from emp group by dept_id) t2 -- 辅助表where t1.id = t2.dept_id; 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 12345678910111213141516171819202122-- 不可以查出空select t1.ename, t1.mgr, t2.id, t2.enamefrom emp t1, emp t2where t1.mgr = t2.id;-- 可以查出空select t1.ename, t1.mgr, t2.id, t2.enamefrom emp t1left join emp t2on t1.mgr = t2.id; 3. 事务 引入 在实际开发中，一个业务操作通常包含了多次数据库的操作。例如：转账。 创建表、添加数据 123456789-- 创建账号表create table account( id int primary key auto_increment, name varchar(10), balance double);-- 添加数据insert into account values(1,&quot;Tobing&quot;,1000),(null,&quot;Zenyet&quot;,1000); 模拟转账【正常情况】 12345-- 1.Tobing - 500update account set balance = balance - 500 where name = &#x27;Tobing&#x27;;-- 2.Zenyet + 500update account set balance = balance + 500 where name = &#x27;Zenyet&#x27;; 模拟转账【出现异常】 123456-- 1.Tobing - 500update account set balance = balance - 500 where name = &#x27;Tobing&#x27;;出现异常-- 2.Zenyet + 500update account set balance = balance + 500 where name = &#x27;Zenyet&#x27;; 此时会出现Tobing已经减掉500，而Zenyet却没有加上500。500凭空消失了 有以上案例我们可以看出 在实际开发中，一个事务往往包含了多次的数据库操作（本例中转账就包含了两个步骤），如果其中一个步骤出现了异常，往往会导致结果出现异常。 而数据库通过使用事务这一操作。将若干的数据库操作，定义在一个事务中，如果事务中任意语句执行出现异常，可以选择进行rollback，是数据库回滚到事务开始状态。如果执行没有问题，则可以commit，提交事务。 事务提交的分类 手动提交：MySQL默认自动提交，一条DML自动提交一次事务。 自动提交：Oracle默认手动提交，先开启事务，然后再提交 MySQL中修改事务默认的提交方式。 12345-- 查看事务提交的方式select @@autocommit;-- 修改默认提交方式 1代表自动提价 | 0代表手动提交set @@autocommit = 0; 事务的四大特征【重点】 原子性：是不可分割的最小单位，事务中的所有操作要么同时成功，要么同时失败。 持久性：事务commit或者rollback，数据库都会持久化保存数据 隔离性：多个事务之间相互独立 一致性：事务操作前后，数据总量不变。 事务的隔离级别 引入：多个事务之间隔离，相互独立。但是如果多个事务操作同一数据，会引发一些问题，设置隔离级别可以解决这些问题。 引发的问题 脏读：一个事务读取到另外一个事务没有提交（commit）的数据。 虚读（不可重复读）：同一事务中，两次读到的数据不一样。 幻读：一个事务操作数据表中的所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted（读未提交） 产生：脏读、不可重复读、幻读。 read committed（读已提交）： 产生：不可重复读、幻读。 repeatable read（可重复读）： 产生：幻读。 serializable（串行化）： 解决所有 注意 隔离级别从小到大安全性越来越高，但是效率越来越低 通常在特殊场景才会修改 隔离级别。一般使用默认隔离级别 Oracle默认read committed MySQL默认repeatable read 隔离级别操作 12345-- 查询隔离级别select @@tx_isolation;-- 修改隔离级别set global transaction isolation level [隔离级别字符串]","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"MySQL-3-数据库的设计","slug":"MySQL-3-数据库的设计","date":"2019-11-23T02:11:12.000Z","updated":"2021-01-15T04:14:52.003Z","comments":true,"path":"2019/11/23/MySQL-3-数据库的设计/","link":"","permalink":"https://tobing.top/2019/11/23/MySQL-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/","excerpt":"MySQL学习第三弹。","text":"MySQL学习第三弹。 MySQL-3-数据库的设计1. 表之间的关系1. 分类 一对一 人和身份证 一个人只有一个身份证，一个身份证对应一个人 一对多 部门和员工 一个部门有多个员工，而多个员工对应一个部门 多对多 学生和课程 一个学生可以选多门课程，一个课程可以被多个学生选择 2. 实现 一对多：例如，部门和员工 实现方式：在【多】的一方建立外键，指向【一】的一方的主键。 多对多：例如，学生和课程 实现方式：借助第三张中间表。表中至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一：人和身份证 实现方式：在任意一方添加唯一约束的主键，指向另外一方。 注意：实际中很少这种情况，既然存在一对一，为何不把它们放在同一张表中呢？ 3. 旅游线路的分析 旅游线路表、线路分类表、用户表 线路分类下有很多条旅游线路，一条旅游线路可以被多个用户收藏，一个用户可以收藏多条线路。 分析： 代码实现： 123456789101112131415161718192021222324252627282930313233343536-- 旅游分类表CREATE TABLE tab_categroy( cid INT PRIMARY KEY AUTO_INCREMENT, -- 主键，自增长 cname VARCHAR(100) NOT NULL UNIQUE -- cname 非空，唯一);-- 旅游线路表CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, -- 主键，自增长 rname VARCHAR(100) NOT NULL UNIQUE, -- rname 非空，唯一 price DOUBLE, rdate DATE, cid INT, -- 外键 -- 将cid与tab_categroy中的cid关联 FOREIGN KEY(cid) REFERENCES tab_categroy(cid));-- 用户表CREATE TABLE tab_user( uid INT PRIMARY KEY AUTO_INCREMENT, -- 主键，自增长 username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &#x27;男&#x27;, -- 性别，默认男 telephone VARCHAR(11), email VARCHAR(100));-- 收藏（连接用户与线路）CREATE TABLE tab_favorite( rid INT, DATE DATETIME, -- 关联时间 uid INT, PRIMARY KEY(rid,uid), FOREIGN KEY(rid) REFERENCES tab_route(rid), -- rid关联tab_route中的rid FOREIGN KEY(uid) REFERENCES tab_user(uid) -- uid关联tab_user中的uid); SQLyog架构设计器显示 2. 范式（略）","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"MySQL-2-基本操作","slug":"MySQL-2-基本操作","date":"2019-11-15T14:07:48.000Z","updated":"2021-01-15T04:15:13.344Z","comments":true,"path":"2019/11/15/MySQL-2-基本操作/","link":"","permalink":"https://tobing.top/2019/11/15/MySQL-2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"MySQL复习第二弹。","text":"MySQL复习第二弹。 MySQL-2-基本操作1. DDL：操作数据库、表 操作数据库：CRUD C（Create）：创建 1234-- 创建数据库create database [数据库名称]; create database if not exists [数据库名称]; -- 创建并判断是否存在create database [数据库名称] character set [字符集名称]; -- 创建并指定字符集 12-- 创建db4数据库，判断是否存在，并指定字符集为gbkcreate database if not exists db4 character set gbk; R（Retrieve）：查询 1234-- 查询所有数据库名称show databases;-- 查询某一个数据库的字符集：查询某一个数据库的创建语句show create database [数据库名称] U（Update）：修改 12-- 修改数据库字符集alter database [数据库名称] character set [字符集名称] D（Delete）：删除 1234-- 删除数据库drop database [数据库名称];-- 判断存在，存在再删除drop database if exists [数据库名称]; 使用数据库 1234-- 查询当前使用的数据库名称select database();-- 使用数据库use [数据库名称]; 操作表 C（Create）：创建 1234567-- 创建表create table [表名] ( 列名 数据类型, 列名 数据类型, ... -- 最后一个没有逗号); int：整数 double：浮点 date：日期（年月日），yyyy-MM-dd datetime：（年月日时分秒） yyyy-MM-dd HH:mm:ss timestamp：时间戳类型 包含年月日时分秒 yyyy-MM-dd（默认为当前系统时间） varchar：字符串 12-- 复制表create table [表名] like [被复制的表] R（Retrieve）：查询 12345-- 查询当前数据库下所有的表show tables;-- 查指定的表结构desc [表名] U（Update）：修改 1234567891011-- 修改表名alter table [表名] rename to [新的表名]-- 修改表的字符集alter table [表名] character set [字符集名称]-- 添加一列alter table [表名] add [列名] [数据类型]-- 修改列名称 类型alter table [表名] change [列名] [新列名] [新数据类型]-- 删除列alter table [表名] drop [列名] D（Delete）：删除 1234-- 删除表drop table [表名];drop table if exists [表名]; 2. DML：修改表中的数据 添加数据：insert 12345-- 插入insert into 表名(列名1，列名2，列名3....) values(值1，值2，值3...);insert into 表名 values(值1，值2，....); 列名要和值一一对应。 如果表名后，不定义列名，则给所有的列添加值。 除了数学类型，其他类型需要使用引号（单双都可以）引起来。 删除数据：delete 123456delete from [表名] [where 条件]-- 删除所有记录delete from [表名]; -- 不推荐使用。有多少天记录就输出第三条记录（按记录删除）truncate table [表名] -- 推荐使用，效率更高，先删除表，如果在创建一张的表（按表删除） 如果不加条件，则删除表中所有记录 修改数据：update 12update [表名] set [列1] = [列1], [列2] = [值2] .... [where 条件] 注意：如果不加任何条件，表中使用记录都会被更改。 3. DQL：查询表中记录 格式 123456789101112131415select [字段列表]from [表名列表]where [条件列表]group by [分组字段]having [分组之后的条件]order by [排序]limit [分页限定] 普通字段查询 123456789101112-- 多字段查询select 字段1，字段2... from [表名];-- 查询所有字段select * from [表名];-- 去除重复distinctselect distinct [列名] from [表名];-- 查询结果运行select *,(列1+列2) form [表名] -- 显示该表所有数据，并将列1和列2的也相加显示（不限于相加）select *,(列1+列2) as [新列名] from [表名] -- 将新加的类列名设置为【新列名】 as : 起别名 条件查询 12where [条件] 运算符 &lt;、&gt; between…and in(集合) like:模糊查询 ​ _：单个任意字符 ​ %：多个任意字符 is null and 或 &amp;&amp; or 或 || not 或 ！ 排序查询 123order by [子句]order by 排序字段1，排序方式1，排序字段2，排序方式2.... asc：默认，升序排序 desc：降序排序 聚合函数：将一列数据作为一个整体，降序纵向计算。（例如：求和） 123select count(列名) from [表名] -- 给某一列求个数select count(ifnull([列名],0)) from [表名] count：计算个数 一般选择非空的列，主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意：使用时排查null值，一般选择非空列 分组查询 group by 常用于对某个具有相同特征的整体进行操作 注意：分组之后，查询的字段只能写聚合函数和分组字段。否则没有意义 having和where的区别 where在分组之前进行限定，如果不满足条件，不参与分组。where之后不可以跟聚合函数。 having在分组后进行限定，如果不满足，则不会被查询出来。having可以进行聚合函数的判断。 分页查询 limit 123456-- 模拟每页显示3条内容-- 显示从0开始的3条记录select * from [表名] limit 0,3; -- 第一页-- 显示从3开始的3条记录select * from [表名] limit 3,3; -- 第二页 注意：limit是Mysql的方言 4. limit案例 创建学生表 12345678910CREATE TABLE student3( -- 创建学生表 id INT, -- id NAME VARCHAR(20), -- 姓名 age INT, -- 年龄 sex VARCHAR(10), -- 性别 address VARCHAR(30), -- 地址 math DOUBLE, -- 数学成绩 english DOUBLE -- 英语成绩); 插入数据 123456789INSERT INTO student3 VALUES (1,&quot;张三丰&quot;,20,&#x27;男&#x27;,&#x27;长安&#x27;,77,99), (2,&quot;张无忌&quot;,25,&#x27;男&#x27;,&#x27;西安&#x27;,99,45), (3,&quot;张翠山&quot;,28,&#x27;男&#x27;,&#x27;武汉&#x27;,99,12), (4,&quot;孙悟空&quot;,33,&#x27;男&#x27;,&#x27;花果山&#x27;,44,99), (5,&quot;猪八戒&quot;,50,&#x27;男&#x27;,&#x27;高老庄&#x27;,99,24), (6,&quot;白骨精&quot;,22,&#x27;女&#x27;,&#x27;蚕丝洞&#x27;,99,88), (7,&quot;蜘蛛精&quot;,23,&#x27;女&#x27;,&#x27;蜘蛛洞&#x27;,98,99); 使用limit分页显示查询 123456-- 每页显示5条记录SELECT * FROM student3 LIMIT 0,5;SELECT * FROM student3 LIMIT 5,5;-- 当查询第一页时，可以省略开始的页码SELECT * FROM student3 LIMIT 5; 5. 约束 约束是对表中的数据进行限定，保证数据的正确性，有效性和完整性。 分类 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束：not null,值不能为null 12345678910-- 创建表时，添加约束create table student( id int; name varchar(20) not null -- name属性不能为空);-- 创建表之后，添加约束alter table student modify name varchar(20) not null;-- 删除name的非空约束alter table student modify name varchar(20); 唯一约束：unique，值不能重复 123456-- 创建表时，添加唯一约束create table student( id int; id_key varchar(20) unique; -- id_key值唯一); 在Mysql中，唯一约束限定的列可以有多个null。 12345-- 删除唯一约束alter table student drop index id_key; -- 删除id_key列的唯一约束-- 创建表后，添加唯一约束alter table student modify id_key varchar(20) nuique; 主键约束：primary key 主键非空且唯一。 一张表只能有一个字段为主键。 主键就是表中记录的唯一标识。 12345678-- 创建表时，添加主键create table user( id int primary key; -- id为主键 username varchar(20););-- 删除主键alter table user drop primary key; 注意：删除主键并不是：alter table user modify primary key; 1234567891011-- 自增长（常常与主键一起使用）-- 创建表时，指定自增长crete table user( id int primary key auto_increament, -- 主键，自增长 name varchar(20));-- 删除自增长alter table user modify id int;-- 添加自增长alter table user modify id int auto_increament; 外键约束：foreign key，使得表与表之间产生关系。（保证了数据的完整性） 123456789101112-- 创建表时添加create table [表名]( ... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主列表名称));-- 删除外键alter table [表名] drop foreign key [外键名称]; -- 注意此处使用drop而非modify-- 创建表后，添加外键alter table [表名] add constraint [外键名称] foreien key (外键字段名称) references [主表名称](主表列名称); 6. 外键约束案例 引入 123456INSERT INTO emp (NAME,age,dep_name,dep_location) VALUES (&#x27;张三&#x27;,20,&#x27;研发部&#x27;,&#x27;广州&#x27;), (&#x27;李四&#x27;,21,&#x27;研发部&#x27;,&#x27;广州&#x27;), (&#x27;赵六&#x27;,24,&#x27;销售部&#x27;,&#x27;深圳&#x27;), (&#x27;王五&#x27;,15,&#x27;销售部&#x27;,&#x27;深圳&#x27;); 123456789+----+--------+------+-----------+--------------+| id | name | age | dep_name | dep_location |+----+--------+------+-----------+--------------+| 1 | 张三 | 20 | 研发部 | 广州 || 2 | 李四 | 21 | 研发部 | 广州 || 3 | 赵六 | 24 | 销售部 | 深圳 || 4 | 王五 | 15 | 销售部 | 深圳 |+----+--------+------+-----------+--------------+ 观察以上的数据可以看出，在部门和工作地址存在很多冗余的数据。 改进：引用外表 123456789101112131415161718192021222324-- 创建部门表CREATE TABLE department( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键，自增长 dep_name VARCHAR(20), dep_location VARCHAR(20));-- 创建员工表CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT -- 对应department表的主键);-- 添加数据INSERT INTO department VALUES (NULL,&#x27;销售部&#x27;,&#x27;深圳&#x27;), (NULL,&#x27;研发部&#x27;,&#x27;广州&#x27;);INSERT INTO employee VALUES (NULL,&#x27;张三丰&#x27;,20,1), (NULL,&#x27;张无忌&#x27;,21,1), (NULL,&#x27;猪八戒&#x27;,33,2), (NULL,&#x27;孙悟空&#x27;,33,2); 把部门和地址拆分出来之后，数据的冗余量下降了，但是会存在新的问题 什么问题？ 如果明天研发部取消了，直接从部门表中删除了研发部这条记录，但是删除的时候并不知道还有其他的员工记录关联了该记录。这就会导致数据不完整。 如何解决？ 外键约束 使用外键约束保证数据完整性 1234567891011121314151617-- 格式constraint 外键名称 foreign key (外键列名称) references 主键名称(主列表名称)-- 创建employee表给其添加外键约束-- 创建员工表CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT -- 对应department表的主键 constraint emp_dep_fk foreign key (dep_id) references department(id) -- 给dep_int 添加到department表的外键约束);-- 试图删除部门表中的id为1的部门delete from department where id = 1-- 执行时报以下错误Cannot delete or update a parent row: a foreign key constraint fails (`db8100`.`employee`, CONSTRAINT `emp_dep_fk` FOREIGN KEY (`dep_id`) REFERENCES `department` (`id`)) 此时，部门表已经和员工表建立了关系 7. 外键约束-级联 引入 当我们在使用外键连接了不同的表的时候，当我们要改动被关联表中的被关联的列的时候（如上图中，要改动department中的id的记录，如果直接修改department的记录，就会报错，因为id列的记录还被employee表的记录关联着，直接修改会导致出现数据丢失。） 解决办法 传统办法，条件更改，把所有关联要被修改的（外键记录）的都改为null，更改外键记录之后，在通过条件把以上修改的设置为新的记录。 级联 修改的时候把所有关联着该外键记录的值一同更新。 语法： 123Alter table [表名] add constraint [外键名称] foreign key (外键字段名称)references [主表名称](主表列名称) on update cascade on delete cascdae; 级联更新：on update cascade 级联删除：on delete cascade （谨慎使用，如果不注意容易导致删除很多数据）","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"MySQL-1-概述","slug":"MySQL-1-概述","date":"2019-11-15T14:06:55.000Z","updated":"2021-01-15T04:15:49.606Z","comments":true,"path":"2019/11/15/MySQL-1-概述/","link":"","permalink":"https://tobing.top/2019/11/15/MySQL-1-%E6%A6%82%E8%BF%B0/","excerpt":"本文是对MySQL的复习笔记。","text":"本文是对MySQL的复习笔记。 MySQL-1-概述1. 数据库引入 常见不同存放数据介质的比较 存储位置 优点 缺点 内存 速度快 断电丢失 硬盘 永久保存 操作数据不方便 数据库 永久保存、查询速度快、易于管理数据 占用资源，收费 何为数据库 存储数据的仓库 本质上是一个文件系统，还是以文件的方式存放在服务器中。 所有的关系型数据库都可以使用通用的SQL（ 指结构化查询语言，全称是 Structured Query Language。 ）语句对其进行管理 常见数据库 MySQL：免费开源，小型的数据库，MySQL被sun收购，sun被Oracle收购。6.X开始收费。 Oracle：收费大型数据库（收费单位：万） DB2：IBM，收费，常用于银行系统。 SQL Server：微软收费数据库。C#和.net语言常用 SQLite：嵌入式小型数据库，手机端。如：Android 2. 数据库安装与使用1. 安装 下载Mysql5.X 自行百度 2. 卸载 服务 找到名称为：MySql关闭 程序与功能中卸载 删除MySQL中的所有文件 删除C盘中ProgramDate目录关于MySQL的目录，且该目录为隐藏文件。 3. MySQL服务启动 搜索：服务 找到：名称为MySQL，开启 4. MySQL登录与退出 登录 12mysql -u[用户名] -p[密码] # 显式输入密码mysql -u[用户名] -p # 直接回车 # 隐式输入密码 12E:\\Code\\Personal_website\\tobing&gt;mysql -uroot -pEnter password: **** # *号代替了密码 退出：exit quit 12345mysql&gt; exit Byemysql&gt; quitBye 5. MySQL图形化软件 SQLyog 6. MySQL目录结构 bin：所有MySQL可执行文件，如mysql.exe。 data：存放系统必须的数据库 MySQLInstanceConfig.exe：数据库配置向导 C:\\ProgramData\\MySQL\\MySQL Server 5.5\\data：隐藏文件夹，存放自定义的数据库 7. 数据库管理系统 数据库管理系统：DataBase Management System，DBMS。指一种操作和管理数据库的大型软件，用于建 立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理 系统访问数据库中表内的数据 数据库管理程序(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用 中实体的数据，一般会在数据库创建多个表，以保存程序中实体 User 的数据。 数据库管理系统、数据库和表的关系 图 一个数据库服务器可以有多个数据库 一个数据库可以有多张表 一张表包含多条记录 3. 数据库语法初识1. SQL是什么 SQL：Structured Query Language 结构化查询语言 2. SQL的作用 是一种所有关系型数据库的查询规范，不同的数据库都支持。 通用的数据库操作语言，可以用在不同的数据库中。 不同的数据库 SQL 语句有一些区别 3. SQL语句分类 DDL：数据定义语言（Data Definition Language ） 建表，建库 DML：数据操纵语言（Data Manipulation Language） 对表中记录增删改查 DQL：数据查询语言（Data Query Language） 查询表中数据 DCL：数据控制语言（Data Control Language） 用户权限 4. MySQL方言 每条语句以分号结尾，如果在 SQLyog 中不是必须加的。 SQL 中不区分大小写，关键字中认为大写和小写是一样的 3中注释 123-- 这是注释&#x2F;* 这也是注释 *&#x2F;# 这还是注释","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"JDBC的封装","slug":"JDBC的封装","date":"2019-11-04T14:15:00.000Z","updated":"2021-01-15T03:10:51.126Z","comments":true,"path":"2019/11/04/JDBC的封装/","link":"","permalink":"https://tobing.top/2019/11/04/JDBC%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"本文对JDBC进行介绍。","text":"本文对JDBC进行介绍。 JDBC的封装1. 引入 即是使用了获取连接的工具类，简化了获取连接的操作。但是在编写程序查询数据库的时候，仍然需要编写较为繁杂的语句，封装结果，释放资源等。因此就有人将这些流程封装为工具包，提供给别人使用。让我们编写代码的时候，只需要关注SQL语句的执行。 2. Spring JDBC Spring框架对JDBC的简单封装，提供了JDBCTemplate对象简化JDBC的开发。 开发步骤 导入jar包 创建依赖于DataSource的JdbcTemplate对象。 调用JdbcTemplate的方法完成CRUD JDBCTemplate提供的方法 update()：执行DML。增、删、改。 queryForMap()：查询结果集，封装为map集合。列名为key，值为value 此方法的返回值长度只能是1。 queryForList()：将查询的结果封装为List。 此方法将每条记录封装为Map，然后将Map封装到List中。 query()：查询结果，将结果封装为JavaBean RowMapper参数（一个接口） 可以直接自己实现。 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject()：查询结果，将结果封装为对象 一般用于聚合函数的查询。例如：求和函数 案例： 导包（连接池，数据库驱动，JdbcTemplate包等） 创建Template对象 CRUD（以account为例） 修改1号数据的 balance 为 200000 添加一条记录 删除刚才添加的记录 查询id为1的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 account表 12345| id | name | balance |+----+--------+---------+| 1 | tobing | 99600 || 2 | acto | 100400 || 6 | rongon | 199900 | account对应的Account类 12345678910111213package top.tobing.domain;public class Account &#123; private Integer id; private String name; private Double balance; //getter and setter @Override public String toString() &#123;&#125;&#125; JdbcTemplate测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package top.tobing.jdbctemplate;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import top.tobing.domain.Account;import top.tobing.utils.JDBCUtils;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import java.util.Map;/*采用测试类的方式完成CRUD任务 */public class JdbcTemplateDemo01 &#123; //1. 修改1号数据的 balance 为 200000 @Test public void test01()&#123; // 获取JdbcTemplate JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); // 编写SQL语句 String sql = &quot;update account set balance = ? where id = 1&quot;; int i = template.update(sql, 300000); System.out.println(i); &#125; //2. 添加一条记录 @Test public void test02()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;insert into account values(null,?,?)&quot;; int i = template.update(sql, &quot;ggo&quot;, 200000); System.out.println(i); &#125; //3. 删除刚才添加的记录 @Test public void test03()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;delete from account where id = ?&quot;; int i = template.update(sql, 8); System.out.println(i); &#125; //4. 查询id为1的记录，将其封装为Map集合 @Test public void test04()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;select * from account where id = 1&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql); System.out.println(map); // &#123;id=1, name=tobing, balance=300000.0&#125; &#125; //5. 查询所有记录，将其封装为List @Test public void test05()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Map&lt;String, Object&gt;&gt; maps = template.queryForList(sql); for (Map&lt;String, Object&gt; map : maps) &#123; System.out.println(map); &#125; &#125; //6. 查询所有记录，将其封装为Emp对象的List集合 @Test public void test06()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Account&gt; list = template.query(sql, new RowMapper&lt;Account&gt;() &#123; @Override public Account mapRow(ResultSet rs, int i) throws SQLException &#123; Account a = new Account(); int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(&quot;balance&quot;); a.setId(id); a.setBalance(balance); a.setName(name); return a; &#125; &#125;); for (Account a : list) &#123; System.out.println(a); &#125; &#125; //6_1. 查询所有记录，将其封装为Emp对象的List集合 @Test public void test0601()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Account&gt; accounts = template.query(sql, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125; //7. 查询总记录数 @Test public void test07()&#123; JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); String sql = &quot;select count(id) from account&quot;; Long sum = template.queryForObject(sql, Long.class); System.out.println(sum); &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://tobing.top/tags/JDBC/"}]},{"title":"数据库连接池技术","slug":"数据库连接池技术","date":"2019-11-04T14:14:41.000Z","updated":"2021-01-15T03:51:14.799Z","comments":true,"path":"2019/11/04/数据库连接池技术/","link":"","permalink":"https://tobing.top/2019/11/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8A%80%E6%9C%AF/","excerpt":"池化技术是提供系统资源利用率必不可少的，接下来接受数据库连接池。","text":"池化技术是提供系统资源利用率必不可少的，接下来接受数据库连接池。 数据库连接池技术1. 引入 在对数据库进行操作的时候，每次执行不同操作，都要去申请连接对象，这样频繁地向系统申请资源会花费大量时间。因此人们引入了池子的概念：一开始就申请多个连接对象，并把这些连接对象放在池子中（容器），每次用的时候就从池子中拿，用完就放回池子中。 2. 概念 本质上就是一个存放了多个连接对象的容器（集合）。 3. 好处 节约系统资源 用户获取连接对象更加高效 4. 标准 Java对连接池定义了规范（即是接口），那就是javax.sql.DataSource接口。 DataSource：A factory for connections to the physical data source that this DataSource object represents. An alternative to the DriverManager facility, a DataSource object is the preferred means of getting a connection. An object that implements the DataSource interface will typically be registered with a naming service based on the Java™ Naming and Directory (JNDI) API. 连接池：一个DataSource对象代表了一个物理的连接数据库的连接的生产工厂。除了DriverManager功能外，DataSource是首选。 Connection getConnection()：Attempts to establish a connection with the data source that this DataSource object represents. Connection.close()：从连接池中获取到的Connection对象在调用close方法的时候会把该对象归还到连接池中。 5. 实现 一般我们不会实现，有数据库厂商实现。 有很多开源的连接池技术：C3P0、Druid（阿里巴巴提供） 6. 第三方连接池的使用：C3P0 开发步骤 导入c3p0提供的实现jar包、依赖jar包、数据库驱动包 c3p0-0.9.5.2.jar：实现jar包 mchange-commons-java-0.2.12.jar：依赖jar包 mysql-connector-java-5.1.37-bin.jar：数据库驱动包 定义配置文件 c3p0-config.xml 创建核心对象： 获取连接 在项目中新建libs文件夹用于存放jar包。 将配置文件放在classpath下，即是项目的src目录下。 修改配置文件 12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--连接数据库的url--&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db8100&lt;/property&gt; &lt;!--用户名--&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;!--密码--&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;!-- 初始的连接个数 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!--最大连接对象数--&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!--超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!--自定义的配置--&gt; &lt;named-config name=&quot;otherc3p0&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db8100&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;8&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 创建核心对象 获取连接 1234567891011121314151617181920212223package top.tobing.c3p0;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class JdbcPoolDemo01 &#123; public static void main(String[] args) throws SQLException &#123; // 创建核心对象ComboPooledDataSource // 使用默认配置 //DataSource ds = new ComboPooledDataSource(); // 指定配置 DataSource ds = new ComboPooledDataSource(&quot;otherc3p0&quot;); // 获取连接对象 Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 7. Druid的使用 开发步骤 导入jar包 druid-1.0.9.jar mysql-connector-java-5.1.37-bin.jar：数据库驱动包 定义配置文件 druid.properties 加载配置文件 获取连接池对象：通过工厂类DruidDataSourceFactory获取 获取连接 创建项目，创建libs目录，导入jar包 编写配置文件 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/db3username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 获取连接池对象 获取连接 123456789101112131415161718192021222324package top.tobing.druid;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;public class DruidDemo01 &#123; public static void main(String[] args) throws Exception &#123; //1. 导入jar包 //2. 定义配置文件 //3. 加载配置文件 Properties pro = new Properties(); InputStream in = DruidDemo01.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(in); //4. 获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5. 获取连接 Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 8.Druid工具类的抽取 考虑到即使使用类连接池技术，但在回去连接的时候步骤仍然比较繁琐，因此将其封装为工具类 定义JDBCUtils类 提供静态代码块用于加载配置文件，初始化连接池对象 提供方法 获取连接 释放资源 获取连接池 工具类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package top.tobing.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JDBCUtils &#123; private static DataSource ds = null; static&#123; try &#123; // 加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接对象 * @return * @throws SQLException */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 * @param conn * @param stat * @param rs */ public static void close(Connection conn, Statement stat, ResultSet rs)&#123; if(conn!=null)&#123; try &#123; conn.close(); // 归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stat!=null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(Connection conn,Statement stat)&#123; close(conn,stat,null); &#125;&#125; 测试工具类代码 123456789101112131415161718192021222324package top.tobing.druid;import top.tobing.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class DruidDemo02 &#123; public static void main(String[] args) throws SQLException &#123; //1.获取连接 Connection conn = JDBCUtils.getConnection(); //2.定义sql语句 String sql = &quot;insert into account values(null,?,?)&quot;; //3.获取pstat对象 PreparedStatement pstat = conn.prepareStatement(sql); //4.配置参数 pstat.setString(1,&quot;rongon&quot;); pstat.setDouble(2,199900); //5.执行查询 int row = pstat.executeUpdate(); System.out.println(row); &#125;&#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"JDBC复习","slug":"JDBC复习","date":"2019-11-02T02:43:05.000Z","updated":"2021-01-15T04:19:10.685Z","comments":true,"path":"2019/11/02/JDBC复习/","link":"","permalink":"https://tobing.top/2019/11/02/JDBC%E5%A4%8D%E4%B9%A0/","excerpt":"本文是对JDBC复习的笔记","text":"本文是对JDBC复习的笔记 JDBC复习1. 引入 回顾操作数据库（MySQL）的常用方式 第三方客户端：SQLyog等 MySQL自带命令行 Java访问（JDBC） 2. JDBC JDBC（ Java Database Connectivity ）： 是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。 每个 数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动。所以我们只需要会调用 JDBC 接口中的方法即可，数据库驱动由数据库厂商提供。 JDBC的好处： 开发访问数据库的程序，只需要会调用 JDBC 接口中的方法即可，不用关注类是如何实现的。 用同一套 Java 代码，进行少量的修改就可以访问其他 JDBC 支持的数据库 JDBC常用的的包 java.sql：所有与JDBC访问数据相关的接口和类 javax.sql：数据库拓展包，提供数据库额外功。比如：连接池 数据库驱动jar：数据库厂商基于JDBC接口的实现类。使用哪个就下载哪个。 JDBC核心API DriverManager：The basic service for managing a set of JDBC drivers. 管理和注册数据库驱动 得到数据库连接对象 Connection接口：A connection (session) with a specific database. 一个连接对象，可以用于创建Statement和PrepareStatement对象 Statement接口：The object used for executing a static SQL statement and returning the results it produces. PreparedStatement接口：An object that represents a precompiled SQL statement. ResultSet接口：A table of data representing a database result set, which is usually generated by executing a statement that queries the database. 3. Connection接口 Connection 接口，具体的实现类由数据库的厂商实现，代表一个连接对象。 提供了获取Statement的方法 Statement createStatement()：Creates a Statement object for sending SQL statements to the database. 4. Statement接口 Statement接口，The object used for executing a static SQL statement and returning the results it produces. int executeUpdate(String sql) ：Executes the given SQL statement, which may be an INSERT, UPDATE, or DELETE statement or an SQL statement that returns nothing, such as an SQL DDL statement. ResultSet executeQuery(String sql) ：Executes the given SQL statement, which returns a single ResultSet object. 5. ResultSet接口 ResultSet接口，封装数据库查询的结果集，对结果集进行下半年了，读取每一条记录。 A table of data representing a database result set, which is usually generated by executing a statement that queries the database. boolean next()：Moves the cursor forward one row from its current position. 数据类型 getXxx()： 通过字段名，参数是String类型，返回不同类型 通过列号，参数是整数，从1开始，返回不同类型 常用数据类型转换表 SQL 类型 Jdbc对应方法 返回类型 BIT(1) bit(n) getBoolean() boolean TINYINT getByte() byte SMALLINT getShort() short INT getInt() int BIGINT getLong() long CHAR,VARCHAR getString() String Text(Clob) Blob getClob getBlob() Clob Blob DATE getDate() java.sql.Date TIME getTime() java.sql.Time TIMESTAMP getTimestamp() java.sql.Timestamp java.sql.Date、Time、Timestamp，三个共同父类是：java.util.Date 6. 获取Statement 下载MySQL驱动jar包 创建工程，导入驱动jar包 编写业务逻辑 下载MySQL驱动jar包 解压下载的mysql-connector-java-5.1.48.zip，把其中的jar包导入项目中 创建工程，导入驱动jar包。 创建Java项目 导入jar 创建测试类JDBCDemo01.java 12345678910111213141516171819package top.tobing.demo01;import ...public class JDBCDemo01 &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 得到MySQL数据库的连接对象 String url = &quot;jdbc:mysql://localhost:3306/db8100&quot;; // 通过数据库地址、用户名、密码得到一个连接 Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;); // 输出连接 System.out.println(connection); // com.mysql.jdbc.JDBC4Connection@42d8062c // 获取Statement Statement statement = connection.createStatement(); // 输出Statement System.out.println(statement); // com.mysql.jdbc.StatementImpl@6043cd28 &#125;&#125; Class.forName(数据库驱动实现类) :加载和注册数据库驱动，数据库驱动由 mysql 厂商 “com.mysql.jdbc.Driver” 连接数据库的4个参数：用户名、密码、url、驱动类全限定类名。 连接数据库URL：协议名:子协议://IP地址:端口号?参数=参数值 jdbc:mysql://localhost:3306/test ?characterEncdoing = utf-8 7. 执行DDL操作 访问数据库通用步骤 要创建的表 字段 类型 id int name varchar(20) gender tinyint(1) birthday date 详细代码 123456789101112131415161718192021222324252627282930313233343536373839404142package top.tobing.demo01;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JDBCDemo2 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stat = null; try&#123; // 获取数据库连接对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db8100&quot;,&quot;root&quot;,&quot;root&quot;); // 通过连接对象获取执行SQL语句的Statement对象 stat = conn.createStatement(); // Statement对象执行语句 stat.executeUpdate(&quot;create table student (id int PRIMARY key auto_increment, name varchar(20) not null &quot; + &quot;,gender boolean,birthday date )&quot;); // 执行完毕 System.out.println(&quot;执行完毕&quot;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 if(stat!=null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 8. 执行DML操作 向student表中添加4条记录 id name gender birthday 1 张无忌 1 1993-03-24 2 张三丰 1 1993-03-24 3 张翠山 0 1993-03-24 4 赵四 1 1993-03-24 步骤： 创建连接对象 创建Statement语句对象 执行SQL查询语句： 返回影响行数 释放资源 代码 123456789101112131415161718192021222324package top.tobing.demo01;import ...public class JDBCDemo03 &#123; public static void main(String[] args) throws SQLException &#123; //1. 创建连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///db8100&quot;, &quot;root&quot;, &quot;root&quot;); //2. 创建Statement语句对象 Statement stat = conn.createStatement(); //3. 执行SQL查询语句： //4. 返回影响行数 int count = 0; // 记录改变的行数 count += stat.executeUpdate(&quot;insert into student values (null,&#x27;张三丰&#x27;,1,&#x27;1993-03-24&#x27;)&quot;); count += stat.executeUpdate(&quot;insert into student values (null,&#x27;张无忌&#x27;,1,&#x27;1993-03-24&#x27;)&quot;); count += stat.executeUpdate(&quot;insert into student values (null,&#x27;张翠山&#x27;,1,&#x27;1993-03-24&#x27;)&quot;); count += stat.executeUpdate(&quot;insert into student values (null,&#x27;张敏&#x27;,0,&#x27;1993-03-24&#x27;)&quot;); //5. 释放资源 rs.close() stat.close(); conn.close(); System.out.println(&quot;一个影响了&quot;+count+&quot;行&quot;); &#125;&#125; 使用完毕以后要关闭结果集 ResultSet，再关闭 Statement，再关闭 Connection 9. 执行DQL语句 查询student表中的数据 步骤： 得到连接对象 得到执行Statement对象 执行查询操作得到结果集ResultSet 变量结果集内容 输出内容 关闭资源 代码 123456789101112131415161718192021222324252627package top.tobing.demo01;import java.sql.*;public class JDBCDemo04 &#123; public static void main(String[] args) throws SQLException &#123; //1. 得到连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///db8100&quot;, &quot;root&quot;, &quot;root&quot;); //2. 得到执行Statement对象 Statement stat = conn.createStatement(); //3. 执行查询操作得到结果集ResultSet ResultSet rs = stat.executeQuery(&quot;select * from student&quot;); //4. 变量结果集内容 //5. 输出内容 while(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); boolean gender = rs.getBoolean(&quot;gender&quot;); Date birthday = rs.getDate(&quot;birthday&quot;); System.out.println(&quot;编号：&quot;+id+&quot;\\t姓名：&quot;+name+&quot;\\t性别：&quot;+gender+&quot;\\t生日：&quot;+birthday); &#125; //6. 关闭资源 stat.close(); conn.close(); &#125;&#125; 输出结果 1234编号：1 姓名：张三丰 性别：true 生日：1993-03-24编号：2 姓名：张无忌 性别：true 生日：1993-03-24编号：3 姓名：张翠山 性别：true 生日：1993-03-24编号：4 姓名：张敏 性别：false 生日：1993-03-24 10. 工具类的封装 回看以上代码发现，很多代码都重复，可以把这些重复的代码抽取出来，封装到工具类中。 工具类包含以下三个功能 把用到的字符串定义为常量：密码、账号、URL、驱动类 获取数据库的连接：getConnection 关闭资源：close(Connection conn,Statement stat),close(Connection conn,Statement stmt,ResultSet rs 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package top.tobing.util;import java.sql.*;/*1. 把用到的字符串定义为常量：密码、账号、URL、驱动类2. 获取数据库的连接：getConnection3. 关闭资源：close(Connection conn,Statement stat),close(Connection conn,Statement stmt,ResultSet rs) */public class JdbcUtils &#123; private static String PASSWORD = &quot;root&quot;; private static String USERNAME = &quot;root&quot;; private static String URL = &quot;jdbc:mysql:///db8100&quot;; private static String DRIVER = &quot;com.mysql.jdbc.Driver&quot;; public static Connection getConnection() &#123; Connection conn = null; try&#123; //1.加载驱动 Class.forName(DRIVER); //2.获取连接 conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125;catch (Exception e)&#123; &#125; return conn; &#125; public static void close(Connection conn, Statement stat)&#123; close(conn,stat,null); &#125; public static void close(Connection conn, Statement stat, ResultSet rs)&#123; if(stat!=null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 11. PreparedStatement 案例引入 数据库：有一张表，里面包含几个用户。 1234567create table user( id int primary key auto_increment, -- 主键，自增长 name varchar(20), -- 用户名 password varchar(20) -- 密码);insert into user values(null,&#39;tobing&#39;,&#39;root&#39;),(null,&#39;rongon&#39;,&#39;root&#39;); 查询用户用于登录 123456789101112131415## 查询成功mysql&gt; select * from user where name &#x3D; &#39;tobing&#39; and password &#x3D; &#39;root&#39;;+----+--------+----------+| id | name | password |+----+--------+----------+| 1 | tobing | root |+----+--------+----------+1 row in set (0.00 sec)## 查询失败mysql&gt; select * from user where name &#x3D; &#39;tobing&#39; and password &#x3D; &#39;rot&#39;;Empty set (0.00 sec)ERROR:No query specified Jdbc实现以上登录功能 1234567891011121314151617181920212223242526272829303132333435363738394041package top.tobing.demo01;import top.tobing.util.JdbcUtils;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.Scanner;public class JdbcDemo05Login &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); login(username,password); &#125; public static void login(String username,String password)&#123; Connection conn = null; Statement stat = null; ResultSet resultSet = null; try&#123; conn = JdbcUtils.getConnection(); stat = conn.createStatement(); resultSet = stat.executeQuery(&quot;select * from user where name = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password + &quot;&#x27;&quot;); if(resultSet.next())&#123; System.out.println(&quot;登录成功，欢迎你：&quot;+username); &#125;else&#123; System.out.println(&quot;登录失败！&quot;); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(conn,stat,resultSet); &#125; &#125;&#125; 结果 1234567891011请输入用户名：tobing请输入密码：roo登录失败！--------------------------------------------请输入用户名：tobing请输入密码：root登录成功，欢迎你：tobing 分析 从以上代码以及运行结果，咋一看觉得没有什么问题。但实际上以上查询存在SQL注入的安全问题。 12345请输入用户名：tobing请输入密码：rot&#x27; or &#x27;1&#x27; = &#x27;1登录成功，欢迎你：tobing 上面演示了，当我们输入了错误的密码的时候，依然可以成功登陆。 实际，以上代码在实际中是玩mysql查询了以下语句。这句语句只需要用户名存在即可成立！！！！ 1select * from user where name &#x3D; &#39;tobing&#39; and password &#x3D; &#39;rot&#39; or &#39;1&#39; &#x3D; &#39;1&#39; 解决方案：PreparedStatement PreparedStatement：An object that represents a precompiled SQL statement. 翻译：预编译SQL Statement对象 PreparedStatement是Statement接口的子接口，继承父类使用方法。 创建PreparedStatment PreparedStatement prepareStatement(String sql,…) :Creates a PreparedStatement object for sending parameterized SQL statements to the database. PreparedStatement接口中的方法 int executeUpdate() :Executes the SQL statement in this PreparedStatement object, which must be an SQL Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE; or an SQL statement that returns nothing, such as a DDL statement. ResultSet executeQuery() :Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query. PreparedStatement实现login 1234567891011121314151617181920212223242526272829303132package top.tobing.demo01;import top.tobing.util.JdbcUtils;import java.sql.*;import java.util.Scanner;/*使用PreparedStatment修改 */public class JdbcDemo06Login &#123; public static void main(String[] args) throws SQLException &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); login(username,password); &#125; public static void login(String username,String password) throws SQLException &#123; Connection conn = JdbcUtils.getConnection(); // 登录SQL语句，没使用单引号，用？充当占位符 String sql = &quot;select * from user where name = ? and password = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1,username); // 指定第一个参数为String，且是username的值 ps.setString(2,password); ResultSet rs = ps.executeQuery(); if(rs.next())&#123; System.out.println(&quot;登录成功，欢迎你：&quot;+username); &#125;else&#123; System.out.println(&quot;登录失败！&quot;); &#125; &#125;&#125; 结果 1234567891011请输入用户名：tobing请输入密码：root登录成功，欢迎你：tobing-------------------------------------------请输入用户名：tobing请输入密码：rot&#x27; or &#x27;1&#x27; = &#x27;1登录失败！ PreparedStatement执行原理(不是很理解SQL底层预编译的原理) 使用PreparedStatement的好处 prepareStatement()会先将 SQL 语句发送给数据库预编译。PreparedStatement 会引用着预编译后的结果。 可以多次传入不同的参数给 PreparedStatement 对象并执行。减少 SQL 编译次数，提高效率。 安全性更高，没有 SQL 注入的隐患 使用？充当占位符，减少了字符串拼接，是程序可读性提高。 实际中使用PreparedStatement的步骤 编写SQL语句，使用？占位。 获取PreparedStatement对象 设置实际参数，setXxx（占位符位置，传入值） 执行SQL语句 关闭资源 案例一：PreparedStatement的查询数据，并将其封装为学生对象案例 1234567891011121314151617181920package top.tobing.domain;import java.util.Date;public class Student &#123; private int id; private String name; private boolean gender; private Date birthday; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; // getter and setter ..... @Override public String toString() &#123;....&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package top.tobing.demo01;import top.tobing.domain.Student;import top.tobing.util.JdbcUtils;import java.sql.*;/*查询student，并将里面的数据封装为Student对象 */public class JdbcDemo07 &#123; public static void main(String[] args) throws SQLException &#123; // 创建学生对象 Student stu = new Student(); // 编写SQL语句，获取PreparedStatement对象 Connection conn = JdbcUtils.getConnection(); PreparedStatement pstat = conn.prepareStatement(&quot;select * from student where id = ?&quot;); // 设置参数 pstat.setInt(1,2); // 执行SQL语句 ResultSet rs = pstat.executeQuery(); while(rs.next())&#123; // 封装数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); boolean gender = rs.getBoolean(&quot;gender&quot;); Date birthday = rs.getDate(&quot;birthday&quot;); stu.setId(id); stu.setName(name); stu.setGender(gender); stu.setBirthday(birthday); &#125; // 关闭资源 JdbcUtils.close(conn,pstat); System.out.println(stu); &#125;&#125; 案例二：查询学生表将所有学生数据封装为Student对象 123456789101112131415161718192021222324252627282930313233343536package top.tobing.demo01;import top.tobing.domain.Student;import top.tobing.util.JdbcUtils;import ..../*将student中所有的学生信息封装到List中 */public class JdbcDemo08 &#123; public static void main(String[] args) throws SQLException &#123; // 创建List集合 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); // 编写SQL语句，获取预处理对象 Connection conn = JdbcUtils.getConnection(); PreparedStatement pstat = conn.prepareStatement(&quot;select * from student&quot;); // 查询所有 ResultSet rs = pstat.executeQuery(); while (rs.next())&#123; // 封装结果集 Student stu = new Student(); stu.setBirthday(rs.getDate(&quot;birthday&quot;)); stu.setGender(rs.getBoolean(&quot;gender&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setId(rs.getInt(&quot;id&quot;)); students.add(stu); &#125; // 关闭资源 JdbcUtils.close(conn,pstat); for(Student stu : students)&#123; System.out.println(stu); &#125; &#125;&#125; 案例三：执行DML操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package top.tobing.demo01;import top.tobing.util.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/*PreparedStatement执行DML操作 */public class JdbcDemo09DML &#123; public static void main(String[] args) throws SQLException &#123; // 插入 //insert(); // 更新 //update(); // 删除 delete(); &#125; /** * 插入insert * @throws SQLException */ public static void insert() throws SQLException &#123; // 编写SQL语句，获取preparedStatement对象 Connection conn = JdbcUtils.getConnection(); PreparedStatement pstat = conn.prepareStatement(&quot;insert into student values(null,?,?,?)&quot;); // 设置参数 pstat.setString(1,&quot;Tobing&quot;); pstat.setBoolean(2,true); pstat.setDate(3,java.sql.Date.valueOf(&quot;1999-05-03&quot;)); // 执行操作 int row = pstat.executeUpdate(); System.out.println(&quot;插入了&quot;+row+&quot;条记录&quot;); // 关闭资源 JdbcUtils.close(conn,pstat); &#125; /** * 更新update * @throws SQLException */ public static void update() throws SQLException &#123; // 编写SQL语句，获取pstat对象 Connection conn = JdbcUtils.getConnection(); PreparedStatement pstat = conn.prepareStatement(&quot;update student set name = ?,birthday =? where id = ?&quot;); // 设置参数 pstat.setString(1,&quot;尼古拉斯&quot;); pstat.setDate(2,java.sql.Date.valueOf(&quot;1999-06-16&quot;)); pstat.setInt(3,4); // 执行操作 int row = pstat.executeUpdate(); System.out.println(&quot;更新了&quot;+row+&quot;条记录&quot;); // 关闭资源 JdbcUtils.close(conn,pstat); &#125; /** * 删除delete * @throws SQLException */ public static void delete() throws SQLException &#123; // 编写SQL，获取pstat Connection conn = JdbcUtils.getConnection(); PreparedStatement pstat = conn.prepareStatement(&quot;delete from student where id = ? &quot;); // 设置参数 pstat.setInt(1,3); // 执行操作 int row = pstat.executeUpdate(); System.out.println(&quot;删除了&quot;+row+&quot;条记录&quot;); // 释放资源 JdbcUtils.close(conn,pstat); &#125;&#125; 12. JDBC的事务处理 Connection接口中与事务相关的API void setAutoCommit(boolean autoCommit)：Sets this connection’s auto-commit mode to the given state. void commit()：Makes all changes made since the previous commit/rollback permanent and releases any database locks currently held by this Connection object.（提交事务） void rollback()：Undoes all changes made in the current transaction and releases any database locks currently held by this Connection object.（回滚事务） 开发步骤 获取连接 开启事务 获取pstat 使用pstat更新两次 正常情况下提交事务 出现异常回滚事务 关闭自愿 案例 模拟：tobing给acto转账 200 字段 类型 id int name varchar(10) balance double 12345mysql&gt; create table accuont( -&gt; id int primary key auto_increment, -- 主键，自增长 -&gt; name varchar(10), -&gt; balance double -&gt; ); 1234567mysql&gt; select * from account;+----+--------+---------+| id | name | balance |+----+--------+---------+| 1 | tobing | 100000 || 2 | acto | 100000 |+----+--------+---------+ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package top.tobing.demo01;import top.tobing.util.JdbcUtils;import .../** * 事务处理 */public class JdbcDemo10Transaction &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstat = null; try&#123; // 获取连接 conn = JdbcUtils.getConnection(); // 开启事务 conn.setAutoCommit(false); // 编写SQL，获取pstat // tobing - 200 pstat = conn.prepareStatement(&quot;update account set balance = balance - ? where name = ?&quot;); pstat.setDouble(1,200); pstat.setString(2,&quot;tobing&quot;); pstat.executeUpdate(); // 模拟出现异常 System.out.println(100/0); // acto + 200 pstat = conn.prepareStatement(&quot;update account set balance = balance + ? where name = ?&quot;); pstat.setDouble(1,200); pstat.setString(2,&quot;acto&quot;); pstat.executeUpdate(); // 提交事务 conn.commit(); System.out.println(&quot;转账成功！&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); try&#123; // 捕获到异常，回滚事务 conn.rollback(); System.out.println(&quot;转账失败！&quot;); &#125;catch (SQLException e1)&#123; e1.printStackTrace(); &#125; &#125;finally &#123; // 关闭资源 JdbcUtils.close(conn,pstat); &#125; &#125;&#125; 1234567891011121314151617#### 没有出现异常，把100/0 语句去除，能够正常转账mysql&gt; select * from account;+----+--------+---------+| id | name | balance |+----+--------+---------+| 1 | tobing | 99600 || 2 | acto | 100400 |+----+--------+---------+#### 出现异常 ：转账失败mysql&gt; select * from account;+----+--------+---------+| id | name | balance |+----+--------+---------+| 1 | tobing | 99600 || 2 | acto | 100400 |+----+--------+---------+","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://tobing.top/tags/JDBC/"}]},{"title":"电信校园宽带安装路由器","slug":"电信校园宽带安装路由器","date":"2019-10-26T03:22:52.000Z","updated":"2021-01-15T03:08:08.921Z","comments":true,"path":"2019/10/26/电信校园宽带安装路由器/","link":"","permalink":"https://tobing.top/2019/10/26/%E7%94%B5%E4%BF%A1%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6%E5%AE%89%E8%A3%85%E8%B7%AF%E7%94%B1%E5%99%A8/","excerpt":"本文介绍本校电信校园网如何使用路由器拨号。","text":"本文介绍本校电信校园网如何使用路由器拨号。 电信校园宽带安装路由器（SWPU）1. 拿到电信号码，绑定学号 连接cmcc-edu 自动弹出网页选自服务 密码： 多运营商绑定 绑定号码密码 顺便在此界面下载拨号客户端 2. 打开拨号客户端 输入学号 密码 选择电信 3. 打开事件管理器 （win10搜索栏可以直接搜索）—-&gt;windows 日志—-&gt;Rasman 双击Rasman 拨号账号：&#123;SRUN2&#125;645&lt;xxxxxxxxx@dx（保存） 拔掉网线，把网线插到wan口，电脑连接路由器 cmd–&gt;ipconfig-&gt;网关（此步的目的是找到登录路由器的网关，如果事先知道，可以省略） 浏览器中输入网关地址，登录路由器 在路由器中输入：之前&#123;SRUN2&#125;645&lt;xxxxxxxxx@dx作为账号，密码是拨号客户端拨号时使用的密码。 总结 1到2步在购买电信卡时候会有教程。 主要在第3步 rasman.exe是Windows电话拨号程序 如果看了以上教程还不会安装，可以联系QQ：652916578有偿安装。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"校园宽带","slug":"校园宽带","permalink":"https://tobing.top/tags/%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6/"},{"name":"路由器","slug":"路由器","permalink":"https://tobing.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}]},{"title":"Mybatis-1-框架概述","slug":"Mybatis-1-框架概述","date":"2019-10-20T13:19:34.000Z","updated":"2021-01-15T03:12:35.083Z","comments":true,"path":"2019/10/20/Mybatis-1-框架概述/","link":"","permalink":"https://tobing.top/2019/10/20/Mybatis-1-%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/","excerpt":"Mybatis是持久层框架，本文是学习过程中的笔记。","text":"Mybatis是持久层框架，本文是学习过程中的笔记。 Mybatis-1-框架概述1. 什么框架1. 什么是框架2. 框架解决的问题3. 软件开发中分层的重要性4.分层开发下的常见框架5. Mybatis框架概述2. JDBC编程的分析1. JDBC开发回顾 开发步骤 加载驱动 获取数据库连接对象Connection 定义SQL语句 获取preparedStatement对象 设置参数 执行查询 封装结果集 2.jdbc问题分析 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能（线程池解决该问题）。 Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能 多也可能少，修改 sql 还要修改代码，系统不易维护。 3. Mybatis框架快速入门 开发步骤 下载Mybatis框架jar包、或者在maven工程中导入开发坐标 创建Maven工程，添加其他坐标 编写User实体类 编写持久层接口Dao 编写持久层接口的映射文件Dao.xml 编写SQLMapConfig.xml 编写测试类 注意：编写持久层映射文件也可以改为注解的方式，此时SqlMapConfig.xml的映射要改为该接口的全限定类名 4. 自定义Mybatis框架 知识点提要 工厂模式、构建者模式、代理模式，反射，自定义注解，注解的反射，xml解析，数据库元数据，元数据的反射等。 1. 流程分析 SqlMapConfig.xml 连接数据库信息 1234567&lt;!--数据库连接信息--&gt;&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ee50&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/dataSource&gt; 有以上信息，我们可以创建连接数据库的对象Connection。 映射配置文件 123&lt;mappers&gt; &lt;mapper class=&quot;top.tobing.dao.UserDao&quot;/&gt;&lt;/mappers&gt; 123&lt;mappers&gt; &lt;mapper resource=&quot;top/tobing/dao/UserDao.xml&quot;/&gt;&lt;/mappers&gt; 有以上信息，我们可以通过映射配置文件xml（或者注解的方式获取以下配置文件） SQL语句以及封装的结果类型 12345&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 有以上信息，我们可以得到执行的SQL语句，可以获取PreParedStatement对象，还得到了要返回封装结果类的全限定类名。 2. 前期准备 创建Maven工程 引入相关坐标 导入工具类（用于XML解析） 编写SQLMapConfig.xml 编写读取配置文件类 编写Mapper 编写Configuration配置类 编写实体类User 3. 基于XML的自定义Mybatis框架","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"}]},{"title":"效率使用win10","slug":"效率使用win10","date":"2019-10-20T02:07:28.000Z","updated":"2021-01-15T03:50:21.149Z","comments":true,"path":"2019/10/20/效率使用win10/","link":"","permalink":"https://tobing.top/2019/10/20/%E6%95%88%E7%8E%87%E4%BD%BF%E7%94%A8win10/","excerpt":"电脑作为我们最常用的生产力工具，如何高效地使用它对提高工作和学习的效率非常重要。","text":"电脑作为我们最常用的生产力工具，如何高效地使用它对提高工作和学习的效率非常重要。 效率使用win10 电脑作为我们最常用的生产力工具，如何高效地使用它对提高工作和学习的效率非常重要。 1. 桌面 桌面是我们在使用电脑的时候最常接触的界面，我们各种软件的访问都通过桌面的快捷方式。如何快速高效的整理桌面尤其重要。 我习惯把桌面分为三大区域：通用工具区，近期常用工具区，分类区。 通用工具区：常用社交软件，娱乐软件等。 近期常用工具区近期学习要用到的软件，目录快捷方式等。 分类区：很少用到的软件，一些已经完成的文档等。 以下便是我的桌面分类 2. 常用工具 使用软件是我们生产的根本，不同软件对提高我们使用效率尤为重要。 浏览器： Chrome：谷歌家，国产大部分浏览器的极速模式都使用了该浏览器内核。 Firefox：第二大浏览器，相对于谷歌浏览器，在本土化做的更好。 Edge Chrome：据说巨硬（微软）对其内存占用进行了优化 国产浏览器：我使用的是搜狗浏览器，虽然流氓，但是调教一番还是很方便，他的下载管理器尤其突出、通常结合迅雷使用。平时主要在切换极速模式和兼容模式（IE）的时候使用。 浏览器嫌配置麻烦，可以使用奔跑中的奶酪优化配置的。 https://www.runningcheese.com/ 浏览器插件： 某歌访问助手：主要用于查询问题。给Chrome安装插件。github下载链接 Tampermonkey：为安装其他插件提供平台 百度贴吧免登陆、网盘自动填写密码等等 广告拦截 迅雷Chrome支持：结合迅雷极速版、替代默认下载器 笔记软件 OneNote：微软系列，没有使用Typora的时候使用，支持同步，非常方便，但是嵌入代码这些比较麻烦。推荐非编码人员使用。 Typora：使用Markdown编写笔记，但不支持同步，主要用于编写博客和总结。 有道云笔记：在线，支持markdown，思维导图等，但是我很少使用。 Markdown语法：markdown非常流行，语法简单。推荐教程：https://www.runoob.com/markdown/md-tutorial.html 思维导图xmind：用于总结，理清学习框架非常有用。 开发常用 SQLyog：Mysql管理 Navicat for Mysql：同上 Postman：模拟各种请求 Cisco Packet Tracker ：网络工程师必备 其他常用软件 TeamViewer：远程控制软件，win10之后QQ使用远程控制有问题。 磁盘助手：免费的分区助手，磁盘格式转换助手。 火柴：everything+spotlight好用就万事，双击ctrl即可弹出。 卡硬工具箱：硬件检测。 VM、VBox：虚拟机，VM好用、VBox小巧免费 NetSeedMonitor：免费小巧的网速显示软件 Everything：本地搜索神器。 win10自带截图、画图：神器，非常好用。 3. 常用网站 编程学习： 菜鸟教程 廖雪峰 W3C 牛客网：面经、刷题等 LeetCode：刷题 导航：龙轩导航等 其他： 黑苹果：黑果小兵，远景论坛 知名博主：国光、白的夜、奔跑中的奶酪、阿虚的储物间 在线电影：片库网 在线动漫：樱花 2020.3.29更新","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://tobing.top/tags/Windows/"}]},{"title":"Java反射（Reflection）(三)","slug":"Java反射（Reflection）-三","date":"2019-10-19T13:59:40.000Z","updated":"2021-01-15T03:07:05.747Z","comments":true,"path":"2019/10/19/Java反射（Reflection）-三/","link":"","permalink":"https://tobing.top/2019/10/19/Java%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89-%E4%B8%89/","excerpt":"反射第三弹。","text":"反射第三弹。 Java反射（Reflection）(三)1. 通过Class获取Method的几个方法 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但`不包括继承`的方法。 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（`包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口`）的公共 member 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package top.tobing.reflection;import java.lang.reflect.Method;/** * 反射之方法 * @author Tobing */public class Demo05ReflectMethod1 &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; Class cls = Boy.class; //Method methodA = cls.getMethod(&quot;privateMethod&quot;);// java.lang.NoSuchMethodException //Method methodD = cls.getDeclaredMethod(&quot;eat&quot;); // java.lang.NoSuchMethodException Method methodB = cls.getDeclaredMethod(&quot;privateMethod&quot;); // 可以获取私有方法，但不可以获取父类方法 Method methodC = cls.getDeclaredMethod(&quot;publicMethodA&quot;); Method methodE = cls.getMethod(&quot;eat&quot;); // 可以获取父类私有方法，但不可以获取私有方法 System.out.println(methodB.getName()); System.out.println(methodC.getName()); System.out.println(methodE.getName()); Method methods[] = cls.getMethods(); System.out.println(&quot;======================================&quot;); System.out.println(&quot;Boy的所有方法(包含父类继承的)：&quot;); for(Method m:methods) &#123; System.out.println(&quot;getMethods:&quot;+m.getName()); &#125; System.out.println(&quot;======================================&quot;); Method methods1[] = cls.getDeclaredMethods(); for(Method m:methods1) &#123; System.out.println(&quot;getDeclaredMethods:&quot;+m.getName()); &#125; &#125;&#125;/* Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） */class P&#123; public void eat()&#123; System.out.println(&quot;This is p&#x27;s eat!&quot;); &#125;&#125;class Boy extends P&#123; public void publicMethodA() &#123; System.out.println(&quot;This is a public method A !&quot;); &#125; public void publicMethodB() &#123; System.out.println(&quot;This is a public method B !&quot;); &#125; private void privateMethod() &#123; System.out.println(&quot;This is a privateMethod!&quot;); &#125; &#125; 运行结果 12345678910111213141516171819202122privateMethodpublicMethodAeat======================================Boy的所有方法(包含父类继承的)：getMethods:publicMethodBgetMethods:publicMethodAgetMethods:eatgetMethods:waitgetMethods:waitgetMethods:waitgetMethods:equalsgetMethods:toStringgetMethods:hashCodegetMethods:getClassgetMethods:notifygetMethods:notifyAll======================================getDeclaredMethods:privateMethodgetDeclaredMethods:publicMethodBgetDeclaredMethods:publicMethodA 执行指定对象的方法 1234567891011121314151617181920212223package top.tobing.reflection;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 反射之方法 * @author Tobing */public class Demo05ReflectMethod2 &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Class cls = Boy.class; Method methodB = cls.getDeclaredMethod(&quot;privateMethod&quot;); // 可以获取私有方法，但不可以获取父类方法 Method methodC = cls.getDeclaredMethod(&quot;publicMethodA&quot;); Method methodE = cls.getMethod(&quot;eat&quot;); Boy b = new Boy(); //methodB.invoke(b); // cannot access a member of class top.tobing.reflection.Boy with modifiers &quot;private&quot; methodE.invoke(b); methodC.invoke(b); &#125;&#125; 运行结果 12This is p&#x27;s eat!This is a public method A ! 要想执行对象中的private方法，可以使用methodObj.setAccessible(true);来设置其是否可被访问 注意：setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 12methodB.setAccessible(true); // 设置private方法的访问属性methodB.invoke(b); // 执行方法 使用invoke调用静态方法 1234567// 使用invoke调用静态方法int temp = Integer.parseInt(&quot;123&quot;); // 以下代码等同于这一句话//1.获取Integer的字节码对象，通过字节码对象获取到方法 getMethod（方法名称，方法的参数列表）Method methodA = Integer.class.getMethod(&quot;parseInt&quot;,String.class); //2.通过invoke执行方法 invoke(执行方法所在的对象，执行方法需要的参数（不限个数）)Object obj = methodA.invoke(null,&quot;123&quot;);System.out.println(obj); 2. 调用构造方法（创建实例） 在Class类中提供了一个newInstance方法用来创建对象的实例 12Person p = new Person(); // 这两件代码都可以用于新建对象实例Person p = Person.class.newInstance(); 但是newInstance方法也有弊端：只能实例化带public修饰的空参数构造方法 为了解决以上缺陷，java的reflect的API提供Constructor对象，包含了构造方法的所有信息，可用于创建实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package top.tobing.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 反射之方法 * @author Tobing */public class Demo06ReflectMethod4 &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException &#123; // 方式一：使用newInstance()（不可以获取带参数） C c = C.class.newInstance(); // 方式二：获取Constructor类（可以获取带参数） // 不可以获取到非public Constructor con1 = C.class.getConstructor(); Constructor con2 = C.class.getConstructor(Integer.class); // 可以获取到非public构造方法 Constructor con3 = C.class.getDeclaredConstructor(String.class); // 使用Constructor类的newInstance方法 C c1= (C)con1.newInstance(); //调用空参数构造方法 C c2 = (C)con2.newInstance(12); //低氧 C c3 = (C)con3.newInstance(&quot;Tobing&quot;); &#125;&#125;class C&#123; private String name; private int id; public C() &#123; System.out.println(&quot;空参数public构造方法被调用了！！！&quot;); &#125; public C(Integer id) &#123; System.out.println(&quot;带参数public构造方法被调用了！！！&quot;); &#125; C (String name)&#123; this.name = name; System.out.println(&quot;带参数非public的构造方法执行了！！！&quot;); &#125; &#125; 运行结果 12345空参数public构造方法被调用了！！！空参数public构造方法被调用了！！！带参数public构造方法被调用了！！！带参数非public的构造方法执行了！！！ 3. 获取继承关系 获取父类Class 获取interface 1234567891011121314151617181920212223242526272829package top.tobing.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 反射之方法 * @author Tobing */public class Demo07ReflectInherit &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException &#123; Class cls1 = Integer.class; // 获取相关父类 Class cls2 = cls1.getSuperclass(); Class cls3 = cls2.getSuperclass(); System.out.println(&quot;Integer&#x27;s super class is :&quot;+cls2.getName()); System.out.println(&quot;Number&#x27;s super class is :&quot;+cls3.getName()); System.out.println(&quot;Object&#x27;s super class is :&quot;+cls3.getSuperclass()); // 获取interface Class[] interfaces = cls1.getInterfaces(); for(Class c:interfaces) &#123; System.out.println(c.getName()); &#125; &#125;&#125; 输出 12345Integer&#x27;s super class is :java.lang.NumberNumber&#x27;s super class is :java.lang.ObjectObject&#x27;s super class is :nulljava.lang.Comparable 4. 动态代理 如果根据字节码的创建时机来分类，可以分为静态代理和动态代理： 所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。 而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件 由于学识尚浅，未能详尽。 详细请访问以下文章。：https://juejin.im/post/5c1ca8df6fb9a049b347f55c","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://tobing.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"单片机实验","slug":"单片机实验","date":"2019-10-19T10:00:07.000Z","updated":"2021-01-15T03:53:43.383Z","comments":true,"path":"2019/10/19/单片机实验/","link":"","permalink":"https://tobing.top/2019/10/19/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C/","excerpt":"单片机时的实验。","text":"单片机时的实验。 单片机实验运行环境 单片机：STC89C52开发板，某宝有售 KEIL：用于编写程序 STC-ISP：程序写入 1. LED灯循环点亮 实现LED灯循环点亮 123456789101112131415161718192021222324252627282930#include &quot;reg52.h&quot; // 导入C52库#define uchar unsigned char// 延时函数void delay()&#123; uchar i,j; for(i=0;i&lt;255;i++) for(j=0;j&lt;255;j++);&#125;// 主函数int main()&#123; // 初始化 uchar i,temp; // 循环运行 while(1)&#123; // 循环前进移动 temp = 0x01; for(i=0;i&lt;8;i++)&#123; P1 = ~temp; delay(); temp = temp &lt;&lt;1; &#125; // 循环返回移动 temp = 0x80; for(i=0;i&lt;8;i++)&#123; P1= ~temp; delay(); temp =temp &gt;&gt;1; &#125; &#125;&#125; 2. 航标灯 模拟航标灯工作：在白天熄灭，在夜晚断续点亮，时间间隔2秒，即亮2秒，灭2秒，周期循环进行。（8个LED灯一起闪烁，用按键开关1模拟光线传感器，按下表示白天，松开表示夜晚） 123456789101112131415161718192021#include &quot;reg52.h&quot;#define uchar unsigned charsbit FLAG = P3^0; // 设置P3_0void delay()&#123; // 延时函数 unsigned int i,j; // 此处由于超出255，不能再使用uchar for(i=0;i&lt;2000;i++) for(j=0;j&lt;110;j++);&#125;int main()&#123; // 主函数 uchar temp; temp = 0x00; while(1)&#123; if(FLAG==0)&#123; // 白天 P1 = 0xff; // 无闪烁 &#125;else&#123; // 晚上 P1= ~temp; // 不断闪烁 temp = ~temp; delay(); &#125; &#125;&#125; 3. LED灯前进 上电时初始状态为LED灯D1亮其他熄灭，之后每按下一次S4按键，LED灯移动一位，每按下一次S5键，LED灯恢复到初始状态（注意在按键编程中加入去抖动延时及按键释放检测） 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;reg52.h&quot;#define uchar unsigned charsbit S4 = P3^2; sbit S5 = P3^3; void delay()&#123; // 延时 uchar i,j; for(i=0;i&lt;255;i++) for(j=0;j&lt;255;j++);&#125;void delay10ms()&#123; // 延时 uchar i,j; for(i=0;i&lt;30;i++) for(j=0;j&lt;110;j++);&#125;int main()&#123; uchar i,temp; i=1; temp = 0x01; P1 = ~temp; while(1)&#123; if(S4==0)&#123; // 按下一次LED灯前进一位 delay10ms(); // 延时 if(S4==0)&#123; while(S4==0); // 按键释放检测 temp = 0x01; temp = temp &lt;&lt;(i%8); P1 = ~temp; delay(); i++; &#125; &#125; if(S5==0)&#123; // 复位 delay10ms(); if(S5==0)&#123; while(S5==0); i=1; P1 = ~(0x01); &#125; &#125; &#125;&#125; 4. 动态刷新-显示学号 动态刷新程序，让数码管显示学号后8位 123456789101112131415161718192021222324252627282930#include &quot;reg52.h&quot;sbit WEI = P2^7;sbit DUAN = P2^6;// 阴极0-9对应端码unsigned char segment_code[] =&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 要显示的数字unsigned char stu_id[] = &#123;3,1,0,5,4,2,0,5&#125;;// 延时函数void delay()&#123; unsigned long i = 0x30; while(i--);&#125;// 主函数int main()&#123; unsigned long i; while(1)&#123; long i; // 此处不能为unsigned unsigned long temp; for(i=7;i&gt;=0;i--)&#123; P0=~(0x01&lt;&lt;i); // 每次移动一位 WEI=1; WEI=0; // 打开位锁存 P0 = segment_code[stu_id[i]]; // 每次每一位学号 DUAN=1;DUAN=0; // 打开端锁存 delay(); // 延时显示 P0 = 0x0; // 以下三句用于消隐 DUAN = 1; DUAN=0; &#125; &#125;&#125; 5. 动态显示000000001-&gt;99999999 动态刷新程序封装为一个函数，由main函数调用，在此基础上，让数码管循环加1显示，从0000 0001开始，一直加到9999 9999（检查实验结果） 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;reg52.h&quot;sbit WEI = P2^7;sbit DUAN = P2^6;// 阴极0-9对应端码unsigned char segment_code[] =&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 延时函数void delay()&#123; unsigned long i = 0x30; while(i--);&#125;// 动态刷新显示指定的数值void segDisplay(long number)&#123; long i; // 不能为unsigned unsigned long temp; for(i=7;i&gt;=0;i--)&#123; // 遍历每一个LED P0=~(0x01&lt;&lt;i); // 每次访问一个LED WEI=1; WEI=0; temp=number%10; // 每次获取一个数字 number/=10; // 砍掉获取到的数字 P0 = segment_code[temp];// 显示获取到的数字 DUAN=1;DUAN=0; delay(); // 延时显示 P0 = 0x0; // 消隐 DUAN = 1; DUAN=0; &#125;&#125;// 主函数int main()&#123; unsigned long i; while(1)&#123; for(i=1;i&lt;=99999999;i++)&#123; unsigned long k = 5; while(k--)&#123; // 此处为了防止过快显示 segDisplay(i); &#125; &#125; &#125;&#125; 6. 矩阵键盘扫描 编写矩阵键盘扫描程序，扫描矩阵按键，每次按下按键后，用数码管显示矩阵键值。 原理 原理： P3口高4位通高电，依次给P3低4位（每一行）通低电位。 通完电之后，读取P3口的高4位，如果通低电位的所在行，有按键被按下，则P3口的高4位必定有一位不是高电位。 假如S12被按下，则扫描到第三行的时候，读取P3口的高4位，则会读到：0xc0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &quot;reg52.h&quot;sbit WEI = P2^7;sbit DUAN = P2^6;unsigned char segment_code[] =&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char last_key = 0; // 用于保存上一次按下的按键// 延时void delay()&#123; unsigned long i = 0x10; while(i--);&#125;// 延时10msvoid delay10s()&#123; unsigned int i = 1*110; while(i--);&#125;// 显示传入参数函数void segDisplay(long number)&#123; long i; unsigned long temp; for(i=7;i&gt;=0;i--)&#123; P0=~(0x01&lt;&lt;i); WEI=1; WEI=0; temp=number%10; number/=10; P0 = segment_code[temp]; DUAN=1;DUAN=0; delay(); P0 = 0x0; DUAN = 1; DUAN=0; &#125;&#125;// 扫描矩阵键盘，并返回指定的值。int getKey()&#123; unsigned char temp; unsigned char key=0; unsigned char l; unsigned char i; for(i=0;i&lt;4;i++)&#123; P3 = ~(0x01&lt;&lt;i); // 循环设置P3口低4位为低电平，同时给P3口高4位通电 temp = P3; // 读取P3口 temp &amp;= 0xf0; // 去除读取到的低4位 if(temp!=0xf0)&#123; // 消除抖动判断是否有键被按下 delay10s(); if(temp!=0xf0)&#123; switch(temp)&#123;// 依次判断按下的是&quot;那一列?&quot; case 0xe0: key = 4*i+1; break; case 0xd0: key = 4*i+2; break; case 0xb0: key = 4*i+3; break; case 0x70: key = 4*i+4; break; &#125; &#125; &#125; &#125; if(key!=0)&#123; // 如果有键按下，更新矩阵按下的值last_key last_key = key; &#125; return last_key;&#125;// 主函数int main()&#123; unsigned char key; while(1)&#123; key = getKey(); segDisplay(key); &#125;&#125; 7. 中断控制数码管计数 用中断控制数码管计数，上电后数码管显示000000001，按下中断按键后数码管开始递增计时，再次按下时暂停计时，以此类推 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &quot;reg52.h&quot;sbit WEI = P2^7;sbit DUAN = P2^6;unsigned char segment_code[] =&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned long num= 1; // 用于递增变量unsigned char flag = 0; // 暂停还是递增的标志void delay()&#123; unsigned long i = 0x10; while(i--);&#125;void segDisplay(long number)&#123; // 显示指定数值函数 long i; unsigned long temp; for(i=7;i&gt;=0;i--)&#123; P0=~(0x01&lt;&lt;i); WEI=1; WEI=0; temp=number%10; number/=10; P0 = segment_code[temp]; DUAN=1;DUAN=0; delay(); P0 = 0x0; DUAN = 1; DUAN=0; &#125;&#125;// 中断函数void intr() interrupt 0 using 0 &#123; if(flag==1)&#123;// 如果是递增，这将标志位设置为暂停 flag=0; &#125;else&#123; // 如果是暂停，这将标志位设置为递增 flag=1; &#125;&#125;int main()&#123; EA= 1; // 总中断允许 EX0=1; // 允许外部中断0中断 IT0=1; // 选择外部中断0为跳延触发方式 while(1)&#123; if(flag==0)&#123; // 暂停 segDisplay(num); &#125;else&#123; // 递增 unsigned char i = 0x05; while(i--)&#123; // 此处减缓显示管的递增速度 segDisplay(num); &#125; num++; // 数字递增 &#125; &#125;&#125; 8. 蜂鸣器输出不同音调 编写定时器程序，实现输出特定精确频率的方波给蜂鸣器，实现不同的音调 步骤 计算机器周期：（1/单片机频率）*12 计算次数：（需要时间/机器周期） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;reg52.h&quot;sbit beep = P2^3; // 蜂鸣器所在端口double tones[] = &#123;523,587,659,698,783,880,987&#125;; // 中音的7个音调unsigned char flag; unsigned int i;// &quot;两个老虎&quot;的简单音谱unsigned int tigers[] = &#123;1,2,3,1,1,2,3,1,3,4,5,3,4,5,5,6,5,6,4,3,2,7,5,6,4,3,2,7,1,5,1,1,5,1&#125;;// 中断主程序void timer() interrupt 1 &#123; TH0 = (unsigned int)(65536-11059200/tones[flag]/24)/256; TL0 = (unsigned int)(65536-11059200/tones[flag]/24)%256; if(i==34)&#123; // 循环一遍之后，将蜂鸣器置空一段时间 beep = 1; &#125;else&#123; beep = ~beep; &#125;&#125;// 延时void delay()&#123; unsigned int i; unsigned char j; for(i=0;i&lt;300;i++) for(j=0;j&lt;110;j++);&#125;void main()&#123; unsigned char k =5; TMOD = 0x01; flag = 0; TH0 = (unsigned int)(65536-11059200/tones[flag]/24)/256; TL0 = (unsigned int)(65536-11059200/tones[flag]/24)%256; beep = 0; EA = 1; ET0 = 1; TR0 = 1; while(1)&#123; for(i=0;i&lt;34;i++)&#123; // 遍历“两个老虎”音调谱 flag = tigers[i]-1; delay(); &#125; while(k--)&#123; delay(); &#125; &#125;&#125; 9. 串口编程入门 步骤 初始化 串口初始化：SCON-&gt;REN 定时器初始化：PCON-&gt;TMOD 初始化初值：TMOD-&gt;比特率 启动定时器 开中断 中断接收 SCON：串口控制寄存器 每个位 SM0 SM1 SM2 REN TB8 RB8 TI RI 功能 方式选择 方式选择 - 允许串行接收位 - - - - 0 1 0 1 SM0、SM1（最常用） 方式1：8位异步收发，波特率可变 REN 允许：1 禁止：0 SCON常用赋值：0x50 PCON：特殊功能寄存器 SMOD - - - GF1 GF0 PD IDL PCON仅有最高位与串行口相关，其余是电源相关，因此使用是需要谨慎。 PCON仅有最高位与串行口相关，其余是电源相关，因此使用是需要谨慎。 PCON最高位：波特率 1比0翻倍。 此处为了不干扰其他选项：PCOM|=（0x01&lt;&lt;7）; TMOD：定时、计数器寄存器 TMOD GATE C/T M1 M0 GATE C/T M1 M0 T1 T1 T1 T1 T0 T0 T0 T0 GATE：门控位，是否计数 M1、M0工作方式：此处选择8位自动填装 M1= 1，M0=0，GATE TMOD = 0x20; 将以上初始化代码封装为函数 1234567891011121314void init()&#123; // 使用该函数的前提是导入了 reg52.h SCON = 0x40; PCON |= 0x80; TMOD &amp;= 0x0F; // 将高4位置0 TMOD |= 0x10; // 赋初值 19.2kbit TH1 = 0xFD; TL1 = 0xFD; // 启动定时器 TR1 = 1; // 开中断 EA = 1; ES = 1; &#125; 定义发送字符串函数 1234567void sendchar(char data)&#123; // 给发送缓冲区写值 SBUF = data; // 判断是否读取完毕 while(TI==0); TI=0;&#125; 定义中断的方式接收字符 1234567void getChar() interrupt 4 &#123; if(RI)&#123; RI = 0; ch = SBUF; read_flag = 1; // 读取一个字节的标志位（全局） &#125;&#125; 10. 串口通信-发送与接收 在PC端通过串口工具发送字符，在单片机一侧实现接收字符，再把接收到的字符发送回PC 代码 123456789101112131415161718192021222324252627282930313233343536#include &quot;reg52.h&quot;bit read_flag = 0; // 读取的标志位unsigned char ch; // 存放读取到的字符// 串口通信的初始化void init_serialcom( void ) &#123; SCON = 0x50 ; //SCON: serail mode 1, 8-bit UART, enable ucvr TMOD |= 0x20 ; //TMOD: timer 1, mode 2, 8-bit reload PCON |= 0x80 ; //SMOD=1; TH1 = 0xFA ; //Baud:9600 fosc=11.0592MHz IE |= 0x90 ; //Enable Serial Interrupt TR1 = 1 ; // timer 1 run TI=1; &#125;// 发送字符void send_char_com( unsigned char ch) &#123; SBUF = ch; while (TI== 0); TI= 0 ; &#125;// 串口监听字符void serial () interrupt 4 using 3 &#123; if (RI) &#123; RI = 0 ; ch=SBUF; read_flag= 1 ; &#125;&#125;void main()&#123; init_serialcom(); while(1)&#123; if(read_flag==1)&#123; // 判断是否读取到数据 send_char_com(ch); // 将读取到的数据发送出去 read_flag=0; // 将读取标志清零 &#125; &#125;&#125; 11. 串口通信-pc控制单片机 PC端通过串口发送命令，控制单片机外设工作，如PC端用十六进制发送0x01，点亮单片机上第一个LED灯，发送0x02，点亮第二个LED，以此类推 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;reg52.h&quot;bit read_flag = 0; // 读取的标志位unsigned char ch; // 存放读取到的字符// 串口通信的初始化void init_serialcom( void ) &#123; SCON = 0x50 ; //SCON: serail mode 1, 8-bit UART, enable ucvr TMOD |= 0x20 ; //TMOD: timer 1, mode 2, 8-bit reload PCON |= 0x80 ; //SMOD=1; TH1 = 0xFA ; //Baud:9600 fosc=11.0592MHz IE |= 0x90 ; //Enable Serial Interrupt TR1 = 1 ; // timer 1 run TI=1; &#125;// 发送字符void send_char_com( unsigned char ch) &#123; SBUF = ch; while (TI== 0); TI= 0 ; &#125;// 串口监听字符void serial () interrupt 4 using 3 &#123; if (RI) &#123; RI = 0 ; ch=SBUF; read_flag= 1 ; &#125;&#125;void main()&#123; init_serialcom(); while(1)&#123; if(read_flag==1)&#123; // 判断是否读取到数据 switch(ch)&#123; case 0x01: P1 = ~(0x01); break; case 0x02: P1 = ~(0x01&lt;&lt;1); break; case 0x03: P1 = ~(0x01&lt;&lt;2); break; case 0x04: P1 = ~(0x01&lt;&lt;3); break; case 0x05: P1 = ~(0x01&lt;&lt;4); break; case 0x06: P1 = ~(0x01&lt;&lt;5); break; case 0x07: P1 = ~(0x01&lt;&lt;6); break; default: P1 = ~(0x01&lt;&lt;7); break; &#125; read_flag=0; &#125; &#125;&#125; 12. 串口通信-多命令的读取与判断 制定一个简单的串口通信协议，如下表，编写单片机的串口中断程序，解析以下命令并执行 第一个字节 第二个字节 第三个字节 0xff：命令头部 0x01：点亮 0x02：熄灭 0x01：第一个LED 0x02：第二个LED … 例如：当PC端向单片机发送0xff 0x01 0x02 命令 则点亮第二个LED 当PC端向单片机发送0xff 0x02 0x05 命令 则熄灭第五个LED 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &quot;reg52.h&quot;unsigned char read_flag; // 命令标志位unsigned char ch; // 读取来自PC端的字符unsigned char is_light; // 灯亮标志位// 串口通信的初始化void init_serialcom( void ) &#123; SCON = 0x50 ; //SCON: serail mode 1, 8-bit UART, enable ucvr TMOD |= 0x20 ; //TMOD: timer 1, mode 2, 8-bit reload PCON |= 0x80 ; //SMOD=1; TH1 = 0xFA ; //Baud:9600 fosc=11.0592MHz IE |= 0x90 ; //Enable Serial Interrupt TR1 = 1 ; // timer 1 run TI=1; &#125; // 监听中断void serial () interrupt 4 using 3 &#123; if (RI)&#123; // 每当RI读取1个字节，就会置1 。 RI=0; // 读取标志位清零 ch=SBUF; // 从缓冲区获取数据 if(ch==0xff)&#123; // 读取到第一个命令（标志命令的开端） read_flag = 1;// 判断读到第一个命令 &#125;else&#123; if(read_flag==1)&#123; // 读取到第2个命令（灯亮的标志位） read_flag=2; // 设置标志位为2 if(ch==0x01)&#123; is_light = 1; // 设置灯亮 &#125;else if(ch==0x02)&#123; is_light = 0; // 设置灯灭 &#125; &#125;else if(read_flag==2)&#123; // 读取到第3个命令（灯控位） read_flag =0; // 将标志位清空 if(is_light)&#123; // 灯亮(将该位，置0，其他位不变) switch(ch)&#123; case 0x01: P1 &amp;= ~(0x01); break; case 0x02: P1 &amp;= ~(0x01&lt;&lt;1); break; case 0x03: P1 &amp;= ~(0x01&lt;&lt;2); break; case 0x04: P1 &amp;= ~(0x01&lt;&lt;3); break; case 0x05: P1 &amp;= ~(0x01&lt;&lt;4); break; case 0x06: P1 &amp;= ~(0x01&lt;&lt;5); break; case 0x07: P1 &amp;= ~(0x01&lt;&lt;6); break; case 0x08: P1 &amp;= ~(0x01&lt;&lt;7); break; &#125; &#125;else&#123; // 灯灭(将该位，置1，其他位不变) switch(ch)&#123; case 0x01: P1 |= (0x01); break; case 0x02: P1 |= (0x01&lt;&lt;1); break; case 0x03: P1 |= (0x01&lt;&lt;2); break; case 0x04: P1 |= (0x01&lt;&lt;3); break; case 0x05: P1 |= (0x01&lt;&lt;4); break; case 0x06: P1 |= (0x01&lt;&lt;5); break; case 0x07: P1 |= (0x01&lt;&lt;6); break; case 0x08: P1 |= (0x01&lt;&lt;7); break; &#125; &#125; &#125; &#125; &#125;&#125;void main()&#123; init_serialcom(); // 初始化参数 while(1); // 死循环等待读取完毕中断产生&#125; 注意： 本题难点不在于代码逻辑的实现，而是在于通信之间数据的交互 串口助手 注意： 在使用该助手的时候，在PC发送数据给单片机的时候，在选择HEX模式（十六进制）的时候，发送数据时不要加0x前缀或者在前面补0，直接写对应的数值，例如：ff 2 5不要写成0xff 0x02 0x05或者ff 02 05。否则出现的逻辑错误调试调到怀疑人生 每次使用时记得打开串口，而且使用前，波特率记得要选对，串口在左上角串口号可以看到当前使用的是哪一个串口。 已经完结了！！！！发现有什么错误，欢迎留言指出。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"物联网","slug":"物联网","permalink":"https://tobing.top/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"实验","slug":"实验","permalink":"https://tobing.top/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"单片机","slug":"单片机","permalink":"https://tobing.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"Java+Mysql实现简略超市信息管理系统","slug":"Java-Mysql实现简略超市信息管理系统","date":"2019-10-12T13:41:54.000Z","updated":"2021-01-15T04:21:05.955Z","comments":true,"path":"2019/10/12/Java-Mysql实现简略超市信息管理系统/","link":"","permalink":"https://tobing.top/2019/10/12/Java-Mysql%E5%AE%9E%E7%8E%B0%E7%AE%80%E7%95%A5%E8%B6%85%E5%B8%82%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"这以大一下程序设计题目为原型的系统，使用Java+JDBC+MySQL对C进行重写。","text":"这以大一下程序设计题目为原型的系统，使用Java+JDBC+MySQL对C进行重写。 JDBC+MySQL实现超市信息管理系统1. 概述 超市商品管理系统用于管理员、销售员的登录。管理员和销售员查看数据。管理员可以进行入库。销售可以销售商品 2. 需求分析 销售员，管理员登录 管理员添加商品信息，对商品信息修改 销售员可以对商品进行查询，出售等 3. 程序设计 实现方式： Java（JDBC）+MySQL 数据库表 用户表（User） id 姓名 用户名 密码 类型 商品信息表（Good） gid 商品名 品牌 进货时间 销售时间 进价 售价 剩余量 经办人 视图层 登录界面 管理员菜单界面 入库（新增或者添加） 商品名、品牌、进货时间、进价、进货量、经办人 查询 进货时间、商品名、剩余量、经办人 销售员菜单界面 销售（更新商品剩余量） 商品名 查询 销售时间、商品名、品牌、售价、剩余量 Dao层 用户表 商品表 流程图 4. 程序实现 工具 idea2019 Mysql5.5 jdk9.0 mysql驱动jar 1. 准备工作 创建数据库 12345678910111213141516171819202122232425CREATE DATABASE &#96;test&#96; # 创建数据库USE &#96;test&#96;; # 使用该数据库DROP TABLE IF EXISTS &#96;good&#96;; CREATE TABLE &#96;good&#96; ( # 创建商品表表 &#96;gid&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;goodname&#96; varchar(20) NOT NULL, # 商品名 &#96;goodbrand&#96; varchar(20) NOT NULL,# 商品品牌 &#96;intime&#96; date DEFAULT NULL, # 商品进货时间 &#96;saletime&#96; date DEFAULT NULL, # 商品销售时间 &#96;inprice&#96; double DEFAULT NULL, # 商品进价 &#96;saleprice&#96; double DEFAULT NULL, # 商品售价 &#96;stock&#96; int(11) DEFAULT NULL, # 商品剩余量 &#96;agent&#96; varchar(20) DEFAULT NULL,# 商品经办人 PRIMARY KEY (&#96;gid&#96;) # 主键) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;DROP TABLE IF EXISTS &#96;user&#96;; CREATE TABLE &#96;user&#96; ( # 创建用户表 &#96;id&#96; int(11) NOT NULL, &#96;username&#96; varchar(20) NOT NULL, # 用户名 &#96;password&#96; varchar(20) NOT NULL, # 密码 &#96;name&#96; varchar(20) NOT NULL, PRIMARY KEY (&#96;id&#96;) # 主键) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 下载驱动jar包 到Mysql官网下载mysql驱动包&lt;https://dev.mysql.com/downloads/connector/j/&gt; Windows平台选择Platform Independent 安装Mysql（省略，自行百度安装） 安装JDK（省略，自行百度安装） 2. 项目创建 项目目录框架 测试Mysql的连接情况 测试代码 1234567891011121314151617181920212223package top.tobing.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class ConnTest &#123; public static void main(String[] args) throws Exception &#123; // 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 获取连接对象 Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;); // 定义sql 语句 String sql = &quot;select * from user&quot;; // 创建执行对象 Statement statement = connection.createStatement(); // 执行查询sql语句 ResultSet resultSet = statement.executeQuery(sql); // 输出结果集 System.out.println(resultSet); &#125;&#125; 如果成功输出结果集的哈希地址，则说明成功连接上数据库 1. 封装JDBC工具类：JDBCUtils 目的，简化开发流程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package top.tobing.utils;import java.sql.*;public class JDBCUtils &#123; static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到数据库的连接 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;root&quot;); &#125; /** * 关闭所有打开的资源 */ public static void close(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭所有打开的资源 */ public static void close(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(conn, stmt); &#125;&#125; 2. 编写JavaBean 根据创建的数据库表，在domain包中创建对应的JavaBean类 123456789101112131415161718192021222324252627282930313233343536373839package top.tobing.domain;// 对用用户表public class User &#123; private int id; private String username; private String password; private String name; private boolean isadmin; public boolean isIsadmin() &#123; return isadmin; &#125; public void setIsadmin(boolean isadmin) &#123; this.isadmin = isadmin; &#125; ...省略其他getter和setter方法&#125;// 对用商品表import java.util.Date;public class Good &#123; private int gid; private String goodname; private String goodbrand; private Date intime; private Date saletime; private double inprice; private double saleprice; private int stock; private String agent; public int getGid() &#123; return gid; &#125; public void setGid(int gid) &#123; this.gid = gid; &#125; ...省略其他getter和setter方法&#125; 3. 登录功能 登录界面：可以获取用户名，密码。根据返回的用户类型调用创建管理类或者销售类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.tobing.view;import top.tobing.dao.UserDao;import top.tobing.domain.User;import java.sql.SQLException;import java.util.Scanner;public class Login &#123; public Login()&#123; while(true)&#123; this.show(); &#125; &#125; // 数据库操作对象 UserDao userDao =new UserDao(); private void show() &#123; // 获取登录账号和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;------------超市商品管理系统------------&quot;); System.out.print(&quot;-1. 用户名：&quot;); String username = sc.next(); System.out.print(&quot;-2. 密 码：&quot;); String password = sc.next(); System.out.println(&quot;------------超市商品管理系统------------&quot;); // 根据登录用户名密码到数据库查询 User login = null; try &#123; login = userDao.login(username, password); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if(login!=null)&#123; System.out.println(&quot;登录成功！&quot;); if(login.isIsadmin())&#123; //System.out.println(&quot;你好，管理员&quot;); new AdminMenu(login); &#125;else&#123; //System.out.println(&quot;你好，销售员&quot;); new SaleMenu(login); &#125; //System.out.println(login); &#125;else&#123; System.out.println(&quot;Error！账号或密码有误，请重新输入！&quot;); &#125; &#125;&#125; 根据用户名密码查询数据库 1234567891011121314151617181920212223242526272829303132public class UserDao &#123; /** * 根据用户名密码登录 * @param username * @param password * @return * @throws SQLException */ public User login (String username,String password) throws SQLException &#123; User user = null; Connection connection = JDBCUtils.getConnection(); Statement statement = connection.createStatement(); String sql = &quot;select * from user where username = &#x27;&quot;+username+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27;&quot;; //System.out.println(&quot;sql=:&quot;+sql); ResultSet resultSet = statement.executeQuery(sql); if(resultSet.next())&#123; user = new User(); int id = resultSet.getInt(&quot;id&quot;); String username1 = resultSet.getString(&quot;username&quot;); String name = resultSet.getString(&quot;name&quot;); String password1 = resultSet.getString(&quot;password&quot;); boolean isadmin = resultSet.getBoolean(&quot;isadmin&quot;); user.setId(id); user.setUsername(username); user.setPassword(password); user.setName(name); user.setIsadmin(isadmin); &#125; return user; &#125;&#125; 4. 公共管理界面 公共菜单功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package top.tobing.view;import top.tobing.dao.GoodDao;import top.tobing.domain.Good;import top.tobing.domain.User;import java.util.List;import java.util.Scanner;public class Menu &#123; User user = null; public Menu(User user)&#123; this.user = user; &#125; GoodDao goodDao = new GoodDao(); /** * 通用商品查询 */ public void findGoods()&#123; Good g = new Good(); while(true)&#123; System.out.println(&quot;-----------商品查询-----------&quot;); System.out.println(&quot;-1. 根据商品名称&quot;); System.out.println(&quot;-2. 根据商品品牌&quot;); System.out.println(&quot;-3. 根据商品经办人&quot;); System.out.println(&quot;-0. 退出&quot;); System.out.print(&quot;-请输入你的选择：&quot;); Scanner sc = new Scanner(System.in); int i = sc.nextInt(); List&lt;Good&gt; goods =null; switch (i)&#123; case 1: System.out.print(&quot;请输入商品名称：&quot;); String name = sc.next(); goods = goodDao.findByName(name); System.out.println(&quot;--------------------------------------------&quot;); System.out.println(&quot;商品名称\\t\\t商品品牌\\t\\t商品进价\\t\\t商品剩余\\t\\t商品经办人&quot;); for (Good good : goods) &#123; showGood(good); &#125; break; case 2: System.out.print(&quot;请输入商品品牌：&quot;); String brand = sc.next(); goods = goodDao.findByBrand(brand); System.out.println(&quot;--------------------------------------------&quot;); System.out.println(&quot;商品名称\\t\\t商品品牌\\t\\t商品进价\\t\\t商品剩余\\t\\t商品经办人&quot;); for (Good good : goods) &#123; showGood(good); &#125; break; case 3: System.out.print(&quot;请输入商品经办人：&quot;); String agent = sc.next(); goods = goodDao.findByAgent(agent); System.out.println(&quot;--------------------------------------------&quot;); System.out.println(&quot;商品名称\\t\\t商品品牌\\t\\t商品进价\\t\\t商品剩余\\t\\t商品经办人&quot;); for (Good good : goods) &#123; showGood(good); &#125; break; case 0: System.out.println(&quot;退出&quot;); return; default: System.out.println(&quot;输入有误请重新输入&quot;); break; &#125; &#125; &#125; /** * 展示商品 * @param good */ public void showGood(Good good)&#123; System.out.println(good.getGoodname()+&quot;\\t\\t&quot;+good.getGoodbrand()+&quot;\\t\\t&quot;+good.getInprice()+&quot;\\t\\t&quot;+good.getStock()+&quot;\\t\\t&quot;+good.getAgent()); &#125;&#125; 5. 管理员功能 管理员可以通过管理界面的选项选择对商品的操作 查看商品信息（基础自公共菜单） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package top.tobing.view;import top.tobing.dao.GoodDao;import top.tobing.domain.Good;import top.tobing.domain.User;import java.util.List;import java.util.Scanner;/** * 管理员管理菜单 */public class AdminMenu extends Menu&#123; public AdminMenu(User user)&#123; super(user); this.show(); &#125; GoodDao goodDao = new GoodDao(); private void show() &#123; while(true)&#123; System.out.println(&quot;------------欢迎光临!&quot;+user.getUsername()+&quot;------------&quot;); System.out.println(&quot;-1. 商品入库&quot;); System.out.println(&quot;-2. 查看商品&quot;); System.out.println(&quot;-0. 退出&quot;); System.out.print(&quot;-请输入：&quot;); Scanner sc = new Scanner(System.in); int i = sc.nextInt(); if(i==1)&#123; newGoods(); // 添加商品（商品入库） &#125;else if(i==2)&#123; findGoods();// 查找商品 &#125;else if(i==0)&#123; return; &#125;else&#123; System.out.println(&quot;输入数字有误！&quot;); &#125; &#125; &#125; /** * 商品入库 */ private void newGoods()&#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;-----------商品进货-----------&quot;); System.out.print(&quot;-商品名称：&quot;); String name = sc.next(); System.out.print(&quot;-商品品牌：&quot;); String brand = sc.next(); System.out.print(&quot;-商品数量：&quot;); int num = sc.nextInt(); System.out.print(&quot;-商品进价：&quot;); double price = sc.nextDouble(); List&lt;Good&gt; list = goodDao.findByName(name); if(list!=null&amp;&amp;(!list.isEmpty()))&#123;// 已经存在商品 Good good = list.get(0); int temp = good.getStock(); goodDao.updateByName(name,num+temp); &#125;else&#123; Good g = new Good(); g.setGoodname(name); g.setGoodbrand(brand); g.setStock(num); g.setInprice(price); g.setAgent(user.getName()); goodDao.addNewGoods(g); &#125; &#125;&#125; 6. 销售员功能 销售员可以通过商品名称和商品数量销售商品 查看商品信息（继承自菜单父类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package top.tobing.view;import top.tobing.dao.GoodDao;import top.tobing.domain.Good;import top.tobing.domain.User;import java.util.List;import java.util.Scanner;/** * 销售人员管理菜单 */public class SaleMenu extends Menu &#123; public SaleMenu(User user)&#123; super(user); this.show(); &#125; GoodDao goodDao = new GoodDao(); private void show() &#123; while(true)&#123; System.out.println(&quot;------------欢迎光临!&quot;+user.getUsername()+&quot;------------&quot;); System.out.println(&quot;-1. 销售商品&quot;); System.out.println(&quot;-2. 查看库存&quot;); System.out.println(&quot;-0. 退出&quot;); System.out.print(&quot;-请输入：&quot;); Scanner sc = new Scanner(System.in); int i = sc.nextInt(); if(i==1)&#123; //System.out.println(&quot;商品销售&quot;); saleGood(); &#125;else if(i==2)&#123; //System.out.println(&quot;查看库存&quot;); findGoods(); &#125;else if(i==0)&#123; return; &#125;else&#123; System.out.println(&quot;输入数字有误！&quot;); &#125; &#125; &#125; public void saleGood()&#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入要销售的商品名称：&quot;); String name = sc.next(); System.out.print(&quot;请输入要销售数量：&quot;); int num = sc.nextInt(); List&lt;Good&gt; list = goodDao.findByName(name); if(list!=null&amp;&amp;(!list.isEmpty()))&#123; Good good = list.get(0); if(good.getStock()&lt;num)&#123; System.out.println(&quot;商品数量不足！！剩余：&quot;+good.getStock()); &#125;else&#123; goodDao.updateByName(name,good.getStock()-num); &#125; &#125;else&#123; System.out.println(&quot;商品名不存在，请重新选择！！！！&quot;); &#125; &#125;&#125; 6.商品Dao 用于对good表的增删改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package top.tobing.dao;import top.tobing.domain.Good;import top.tobing.utils.GoodMapper;import top.tobing.utils.JDBCUtils;import java.sql.*;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class GoodDao &#123; /** * 根据姓名查询商品 * @param name * @return * @throws Exception */ public List&lt;Good&gt; findByName(String name) &#123; Connection connection = null; ResultSet resultSet =null; Statement statement = null; List&lt;Good&gt; list =null; try &#123; connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;select * from good where goodname = &#x27;&quot; + name + &quot;&#x27;&quot;; resultSet = statement.executeQuery(sql); list = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; Good good = GoodMapper.getObject(resultSet); list.add(good); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125; /** * 根据品牌查询 * @param brand * @return */ public List&lt;Good&gt; findByBrand(String brand) &#123; Connection connection = null; ResultSet resultSet =null; Statement statement = null; List&lt;Good&gt; list =null; try &#123; connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;select * from good where goodbrand = &#x27;&quot; + brand + &quot;&#x27;&quot;; resultSet = statement.executeQuery(sql); list = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; Good good = GoodMapper.getObject(resultSet); list.add(good); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125; /** * 根据经办人查询 * @param agent * @return */ public List&lt;Good&gt; findByAgent(String agent) &#123; Connection connection = null; ResultSet resultSet =null; Statement statement = null; List&lt;Good&gt; list =null; try &#123; connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;select * from good where agent = &#x27;&quot; + agent + &quot;&#x27;&quot;; resultSet = statement.executeQuery(sql); list = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; Good good = GoodMapper.getObject(resultSet); list.add(good); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125; /** * 添加新商品 * @param good */ public void addNewGoods(Good good)&#123; Connection connection = null; ResultSet resultSet =null; Statement statement = null; List&lt;Good&gt; list =null; try &#123; connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;insert into good(goodname,goodbrand,intime,inprice,stock,agent) &quot; + &quot;values(&#x27;&quot;+good.getGoodname()+&quot;&#x27;,&#x27;&quot;+good.getGoodbrand()+&quot;&#x27;,&#x27;&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(new Date()) + &quot;&#x27;,&#x27;&quot;+good.getInprice()+&quot;&#x27;,&#x27;&quot;+good.getStock()+&quot;&#x27;,&#x27;&quot;+good.getAgent()+&quot;&#x27;)&quot; ; statement.execute(sql); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 更新已经存在的商品数量 * @param name * @param num */ public void updateByName(String name,int num) &#123; Connection connection = null; ResultSet resultSet =null; Statement statement = null; List&lt;Good&gt; list =null; try &#123; connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;update good set stock = &quot;+num+&quot; where goodname =&#x27;&quot;+name+&quot;&#x27;&quot;; System.out.println(sql); statement.execute(sql); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 7. 额外的类 封装结果集的GoodMapper类 123456789101112131415161718192021222324252627282930313233package top.tobing.utils;import top.tobing.domain.Good;import java.sql.Date;import java.sql.ResultSet;import java.sql.SQLException;public class GoodMapper &#123; public static Good getObject(ResultSet resultSet) throws SQLException &#123; Good g = new Good(); int gid = resultSet.getInt(&quot;gid&quot;); String goodname = resultSet.getString(&quot;goodname&quot;); String goodbrand = resultSet.getString(&quot;goodbrand&quot;); Date intime = resultSet.getDate(&quot;intime&quot;); Date saletime = resultSet.getDate(&quot;saletime&quot;); double inprice = resultSet.getDouble(&quot;inprice&quot;); double saleprice = resultSet.getDouble(&quot;saleprice&quot;); int stock = resultSet.getInt(&quot;stock&quot;); String agent = resultSet.getString(&quot;agent&quot;); g.setGid(gid); g.setGoodbrand(goodbrand); g.setGoodname(goodname); g.setIntime(intime); g.setSaleprice(saleprice); g.setSaletime(saletime); g.setInprice(inprice); g.setStock(stock); g.setAgent(agent); return g; &#125;&#125; 主程序类GoodsAdminSystem 12345678package top.tobing.test;import top.tobing.view.Login;public class GoodsAdminSystem &#123; public static void main(String[] args) &#123; Login login = new Login(); &#125;&#125; 3. 项目回顾 项目实际框架 4. 项目效果 大概执行效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859------------超市商品管理系统-------------1. 用户名：admin-2. 密 码：root------------欢迎光临!admin-------------1. 商品入库-2. 查看商品-0. 退出-请输入：2-----------商品查询------------1. 根据商品名称-2. 根据商品品牌-3. 根据商品经办人-0. 退出-请输入你的选择：3请输入商品经办人：tobing--------------------------------------------商品名称 商品品牌 商品进价 商品剩余 商品经办人华为Mate10 华为 1999.0 299 tobing华为P30 华为 3999.0 1324 tobing魅族16 魅族 1999.0 888 tobing-----------商品查询------------1. 根据商品名称-2. 根据商品品牌-3. 根据商品经办人-0. 退出-请输入你的选择：0退出------------欢迎光临!admin-------------1. 商品入库-2. 查看商品-0. 退出-请输入：1-----------商品进货------------商品名称：华为Mate10-商品品牌：华为-商品数量：999-商品进价：1999------------欢迎光临!admin-------------1. 商品入库-2. 查看商品-0. 退出-请输入：0------------超市商品管理系统-------------1. 用户名：saler-2. 密 码：root------------欢迎光临!saler-------------1. 销售商品-2. 查看库存-0. 退出-请输入：1请输入要销售的商品名称：华为P30请输入要销售数量：100000商品数量不足！！剩余：1324------------欢迎光临!saler-------------1. 销售商品-2. 查看库存-0. 退出-请输入：0 5. 总结 本系统从构思到实现一共花费6hours 编写本系统主要熟悉一下开发流程 本系统任然存在很多缺陷 没有使用数据库连接池 没有使用prepareStatement 没有对非法输入进行判断（负数，数据库注入等） 程序的功能非常简陋 此程序的功能如有其它缺陷，请自行判断修改。本人不维护。","categories":[{"name":"技术应用","slug":"技术应用","permalink":"https://tobing.top/categories/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://tobing.top/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"}]},{"title":"Java注解","slug":"Java注解","date":"2019-10-07T09:21:15.000Z","updated":"2021-01-15T03:05:22.491Z","comments":true,"path":"2019/10/07/Java注解/","link":"","permalink":"https://tobing.top/2019/10/07/Java%E6%B3%A8%E8%A7%A3/","excerpt":"在框架的使用过程中，常用到注解，本文对注解进行简单介绍。","text":"在框架的使用过程中，常用到注解，本文对注解进行简单介绍。 注解 定义：注解（Annotation），也叫元数据。一种代码级别的说明。 它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 类比 注释：给程序员看 注解：给计算机看 1. 编译检查 @Override： 2. 编写文档 @author ：作者 @version：版本 @since： @return：返回值 3. Java中预定义的注解 @Override：检测该被该注解标注的方法是否是继承自父类（接口） @Deprecated：表示该方法已经过时 @SuppressWarnings()：压制警告 123456789101112131415161718192021222324252627282930313233package top.tobing.annotation;/** * Java内预定义的注解 * @author Tobing * @version 1.0 * @since 1.5 */public class Demo01Annotation01 &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.run(); &#125;&#125;class Animal&#123; private String name; public void eat() &#123; System.out.println(&quot;吃吃吃！！！&quot;); &#125;&#125;// 压制所有的警告@SuppressWarnings(&quot;all&quot;)class Cat extends Animal&#123; // 表示该方法是继承自父类的 @Override public void eat() &#123; System.out.println(&quot;吃鱼！！！&quot;); &#125; // 表示该方法已经过时，不建议使用 @Deprecated public void run() &#123; System.out.println(&quot;飞檐走壁！！！！&quot;); &#125;&#125; 4. 自定义注解 如何自定义呢？照葫芦画瓢 — &gt; 查看@Deprecated源码 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123; ......&#125; 以下是自定义的注解：MyAnno.java 123package top.tobing.annotation;public @interface MyAnno &#123;&#125; 对自定义的注解反编译 123456E:\\Code&gt;javac MyAnno.java # 编译获取字节码文件E:\\Code&gt;javap MyAnno # 反编译字节码文件Compiled from &quot;MyAnno.java&quot;# 反编译得到的代码public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 从以上编译所的代码可以知道注解的本质 本质：注解本质上就是一个接口，该接口默认继承了Annotation接口 public interface MyAnno extends java.lang.annotation.Annotation Annotation：The common interface extended by all annotation types. Annotation：所有注解类型拓展的公共接口。 注解属性：接口的抽象方法 要求： 属性返回值类型 基本数据类型 String 枚举 注解 以上类型的数值 定义了属性，在使用时需要给属性赋值 定义属性时，使用default关键字给定默认值，使用注解时可以不进行赋值 只有一个属性需要赋值，并且名称是value，可以value可以省略，直接赋值即可。 数值赋值是，值需要用{}包裹。如果数组中只有一个值则可以省略{} 以下是代码演示 12345678910111213141516171819202122232425package top.tobing.annotation;// 自定义注解Annopublic @interface MyAnno &#123; //int show(); // int //String show2(); // String //MyAnno1 anno1(); // 注解类型 String name(); String[] cats(); int[] ages(); int age() default 10; // 赋值了默认，可以不需要数值&#125;// 自定义注解@interface MyAnno1&#123; String value(); // 只有一个值，且值的名称为value&#125;//////////////使用注解//////////////////// age由于定义了default，可以不赋值// cats是数组，赋值多个的时候使用大括号包裹// ages是数值，赋值一个的时候，可以省略大括号@MyAnno(name=&quot;张三&quot;,cats= &#123;&quot;小王&quot;,&quot;小白&quot;&#125;,ages=10)// 省略了value=@MyAnno1(&quot;Value&quot;)public class Demo01Annotation2 &#123;&#125; 元注解 用于描述注解的注解（可以体会到元意思） @Target：描述注解的作用时机 ElementType取值 ElementType.TYPE：可以作用在类上 ElementType.METHOD：可以作用在方法上 ElementType.FIELD：可以作用在成员变量上 @Retention：描述注解被保留的阶段 @Retention(保留阶段) RetentionPolicy.RUNTIME：保留到class字节码文件中，并且被JVM读取到（这个最常用） RetentionPolicy.SOURCE：略 RetentionPolicy.CLASS：略 @Documented：描述注解是否被抽取到api中 @Inherited：描述注解是否被子类继承 1234567891011121314151617181920212223// 以下元注解表述了：注解保留到class字节码文件中，并且被JVM读取到（这个最常用）@Retention(RetentionPolicy.RUNTIME)// 以下元注解表述了：注解可以被抽取到API中@Documented// 以下元注解表述了：自定义注解可以被子类继承@Inherited// 以下元注解表述了：自定义注解可以被使用在类（TYPE）、方法（METHOD）、成员变量（FIELD）@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)@interface MyAnno2&#123; String value();&#125;package top.tobing.annotation;@MyAnno2(&quot;类&quot;)public class Demo01Annotation3 &#123; @MyAnno2(&quot;成员变量&quot;) private String name; @MyAnno2(&quot;方法&quot;) public void show() &#123; &#125;&#125; 5. 注解的应用1. 代替xml配置文件 传统的获取全限定类名，方法名，需要定义xml配置文件中，利用文件流获取xml，并将其中内容读取。操作比较麻烦。 使用注解可以代替此功能 自定义获取className methodName的注解:Load.java 123456789101112package top.tobing.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Load &#123; String className(); String methodName();&#125; 通过自定义注解获取className，methodName，利用反射执行该方法 12345678910111213141516171819202122232425262728293031323334353637package top.tobing.annotation;import java.lang.reflect.Method;@Load(className=&quot;top.tobing.annotation.Demo&quot;,methodName=&quot;show&quot;)public class Demo04AnnotationReflect &#123; public static void main(String[] args) throws Exception &#123; // 获取本类字节码文件对象 Class&lt;Demo04AnnotationReflect&gt; demoClass = Demo04AnnotationReflect.class; /** 此处本质上是获取了，内存中实现的Load接口的子类对象执行方法的返回值 public class LoadImpl&#123; public String className()&#123; return &quot;top.tobing.annotation.Demo&quot;; &#125; public String methodName()&#123; return &quot;show&quot;; &#125; &#125; */ // 获取注解对象 Load load = demoClass.getAnnotation(Load.class); // 获取注解的内容 String className = load.className(); String methodName = load.methodName(); System.out.println(className); System.out.println(methodName); // 通过类名以及方法名称利用反射，执行方法 //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125; 2. 自动以测试 要测试的类 12345678910111213141516171819202122232425262728package top.tobing.annotation.test;public class Cal &#123; //加法 @MyCheck public void add()&#123; String str = null; str.toString(); System.out.println(&quot;1 + 0 =&quot; + (1 + 0)); &#125; //减法 @MyCheck public void sub()&#123; System.out.println(&quot;1 - 0 =&quot; + (1 - 0)); &#125; //乘法 @MyCheck public void mul()&#123; System.out.println(&quot;1 * 0 =&quot; + (1 * 0)); &#125; //除法 @MyCheck public void div()&#123; System.out.println(&quot;1 / 0 =&quot; + (1 / 0)); &#125; public void show()&#123; System.out.println(&quot;永无bug...&quot;); &#125;&#125; 测试使用的注解 12345678910package top.tobing.annotation.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyCheck &#123; &#125; 测试类 123456789101112131415161718192021222324252627282930package top.tobing.annotation.test;import java.lang.reflect.Method;public class CalTest &#123; public static void main(String[] args) &#123; //1. 创建计算器对象 Cal c = new Cal(); //2. 获取计算器字节码文件 Class cls = c.getClass(); //3. 通过字节码文件获取使用方法 Method[] methods = cls.getMethods(); int num = 0;//记录异常出现的次数 for(Method m:methods) &#123; // 判断方法上是否包含注解 if(m.isAnnotationPresent(MyCheck.class)) &#123; // 包含，捕获异常 try &#123; m.invoke(c); &#125;catch(Exception e) &#123; num++; System.out.println(m.getName()+&quot;出现异常了&quot;); System.out.println(&quot;异常名称为：&quot;+e.getCause().getClass().getSimpleName()); System.out.println(&quot;异常原因是：&quot;+e.getCause().getMessage()); System.out.println(&quot;----------------------&quot;); &#125; &#125; &#125; System.out.println(&quot;本次测试一共出现&quot;+num+&quot;次异常&quot;); &#125;&#125; 运行结果 123456789101112add出现异常了异常名称为：NullPointerException异常原因是：null----------------------1 - 0 =1div出现异常了异常名称为：ArithmeticException异常原因是：/ by zero----------------------1 * 0 =0本次测试一共出现2次异常 总结 在实战开发中，我们通常是使用注解，而并不是定义注解 此处复习注解是为了更好地学习框架。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"注解","slug":"注解","permalink":"https://tobing.top/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Java反射（Reflection）(二)","slug":"Java反射（Reflection）-二","date":"2019-10-05T13:08:20.000Z","updated":"2021-01-15T03:04:38.659Z","comments":true,"path":"2019/10/05/Java反射（Reflection）-二/","link":"","permalink":"https://tobing.top/2019/10/05/Java%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89-%E4%BA%8C/","excerpt":"反射介绍第二弹。","text":"反射介绍第二弹。 Java反射（Reflection）(二) 获取了某个Object实例对应的Class，我们就可以通过反射获取他的一切信息。 1. 访问字段(Filed) 通过Class访问字段（Field）信息的几个方法 Field getField(String name) ：获取指定名称的Field（包含父类，子类的public的Field） Filed getDeclaredField(String name) ：获取指定名称的Filed（包含子类的所有Field） Field[] getFields() ：获取所有Field（包含父类，子类的public的Field） Filed[] getDeclaredFields() ：获取所有Filed（包含子类的所有Field） 12345678910111213141516171819202122232425262728293031323334353637package top.tobing.reflection;import java.lang.reflect.Field;/** * 获取实例的字段信息 * @author Tobing */public class Demo02ReflectField &#123; public static void main(String[] args) throws NoSuchFieldException, SecurityException &#123; Student stu = new Student(); // 获取Student名称为id的Field System.out.println(stu.getClass().getField(&quot;name&quot;)); System.out.println(stu.getClass().getField(&quot;id&quot;)); System.out.println(stu.getClass().getDeclaredField(&quot;score&quot;)); // 以下语句会抛出:java.lang.NoSuchFieldException 该方法不能找到父类的public方法 //System.out.println(stu.getClass().getDeclaredField(&quot;name&quot;)); Field[] fields1 = stu.getClass().getFields(); // 获取stu的使用public修饰的方法 System.out.println(&quot;stu的public修饰Field（包含父类）：&quot;); for(Field f:fields1) &#123; System.out.println(f.getName()); &#125; Field[] fields2 = stu.getClass().getDeclaredFields(); System.out.println(&quot;本类中的所有属性（包含private）：&quot;); for(Field f:fields2) &#123; System.out.println(f.getName()); &#125; &#125;&#125;class Human&#123; public String name;&#125;class Student extends Human &#123; public String id; private double score;&#125; 12345678910# 输出结果public java.lang.String top.tobing.reflection.Human.namepublic java.lang.String top.tobing.reflection.Student.idprivate double top.tobing.reflection.Student.scorestu的public修饰Field（包含父类）：idname本类中的所有属性（包含private）：idscore Field的常用操作 String getName() 返回此 Field 对象表示的字段的`名称 ` Class&lt;?&gt; getType() 返回一个 Class 对象，它标识了此 Field 对象所表示字段的`声明类型`。 int getModifiers() 以整数形式返回由此 Field 对象表示的字段的` Java 语言修饰符`。 1234567891011121314151617181920212223242526272829package top.tobing.reflection;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 字段的常用方法 * @author Tobing */public class Demo03ReflectField2 &#123; public static void main(String[] args) throws NoSuchFieldException, SecurityException &#123; Teacher t = new Teacher(); Field f2 = t.getClass().getDeclaredField(&quot;age&quot;); Field f1 = t.getClass().getDeclaredField(&quot;name&quot;); System.out.println(&quot;-----------------------------------------------------&quot;); System.out.println(&quot;名称：&quot;+f1.getName()); System.out.println(&quot;返回值类型：&quot;+f1.getType()); System.out.println(&quot;Java语言修饰符int形式：&quot;+f1.getModifiers()); System.out.println(&quot;isPrivate：&quot;+Modifier.isPrivate(f1.getModifiers())); System.out.println(&quot;-----------------------------------------------------&quot;); System.out.println(&quot;名称：&quot;+f2.getName()); System.out.println(&quot;返回值类型：&quot;+f2.getType()); System.out.println(&quot;Java语言修饰符int形式：&quot;+f2.getModifiers()); System.out.println(&quot;isPublic：&quot;+Modifier.isPublic(f2.getModifiers())); &#125;&#125;class Teacher&#123; private String name; public int age;&#125; 1234567891011# 输出结果-----------------------------------------------------名称：name返回值类型：class java.lang.StringJava语言修饰符int形式：2isPrivate：true-----------------------------------------------------名称：age返回值类型：intJava语言修饰符int形式：1isPublic：true 2. 访问字段的值 Object get(Object obj) ：返回指定实例对应字段的值 Returns the value of the field represented by this Field, on the specified object. void setAccessible(boolean flag) ：设置是否可以范围（权限不够的时候） ​ Set the accessible flag for this object to the indicated boolean value. 123456789101112131415161718192021222324252627282930package top.tobing.reflection;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 字段的常用方法 * @author Tobing */public class Demo03ReflectField3 &#123; public static void main(String[] args) throws Exception&#123; People p = new People(); p.setName(&quot;张三丰&quot;); Field f1 = p.getClass().getDeclaredField(&quot;name&quot;); // f1.get(p); //直接执行该语句会抛出异常java.lang.IllegalAccessException // cannot access a member of class top.tobing.reflection.People with modifiers &quot;private&quot; //不能访问修饰符为private的字段 // 暴力反射，忽略修饰符 // 通常情况下，如果修饰符权限不够就考虑使用该方法（反射是非常规的用法） f1.setAccessible(true); Object obj = f1.get(p); System.out.println(obj); // 输出： 张三丰 f1.set(p,&quot;张无忌&quot;); System.out.println(f1.get(p)); // 修改后输出 张无忌 &#125;&#125;class People&#123; private String name; public int age; public void setName(String name) &#123; this.name = name; &#125;&#125; 总结 理解还未深入，仍需学习。","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://tobing.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java反射（Reflection）(一)","slug":"Java反射（Reflection）-一","date":"2019-10-04T09:09:32.000Z","updated":"2021-01-15T03:04:06.511Z","comments":true,"path":"2019/10/04/Java反射（Reflection）-一/","link":"","permalink":"https://tobing.top/2019/10/04/Java%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89-%E4%B8%80/","excerpt":"在Java常用的框架中，反射被频繁的使用，本文介绍反射的简单使用。","text":"在Java常用的框架中，反射被频繁的使用，本文介绍反射的简单使用。 Java反射（Reflection）(一)1. 什么是反射 通过Class实例获取class（包含类和接口）信息的方法称为反射（Reflection）。 2. Class类 除了基本数据类型:int double long等之外，其他的类型都是class，包括了interface class 是由JVM动态加载的 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。 123public final class Class&#123; private Class()&#123;&#125;&#125; 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例与之关联起来 1Class c1 = new Class(String); Class实例是JVM内部创建的，Class类的构造方法是private，只能由JVM能创建Class实例。 JVM拥有的每一个Class实例都关联了一个数据类型（class 或者 interface） Class实例包含了class的所有信息：name，package，super，interface，field，method等 因此我们可以通过Class实例来获取对应class的所有信息 如何获取到Class实例（三种方法） 通过类的静态变量 1Class strClass = String.class; 通过类实例的getClass()方法 12Stirng s = &quot;Hello&quot;;Class strClass = s.getClass()； 通过Class.forName(&quot;全限定类名&quot;)获取 1Class strClass = Class.forName(&quot;java.lang.String&quot;); 注意 因为Class实例在JVM中是唯一的，所以可以用==比较两个Class 3. 反射的目的1. 获取Class实例的全部信息 运行实例 123456789101112131415161718192021222324252627282930package top.tobing.reflection;/** * 通过反射获取类的全部信息 * @author Tobing */public class Demo01Reflection &#123; public static void main(String[] args) &#123; printClassINFO(&quot; &quot;.getClass()); printClassINFO(Runnable.class); printClassINFO(java.time.Year.class); printClassINFO(String[].class); printClassINFO(int.class); &#125; /** * 打印传入Class的信息 * @param c 传入的Class */ public static void printClassINFO(Class c) &#123; System.out.println(&quot;------------------------------------------&quot;); System.out.println(&quot;简单类名：&quot;+c.getSimpleName()); System.out.println(&quot;全限定类名：&quot;+c.getName()); if(c.getPackage()!=null) &#123; System.out.println(&quot;包名：&quot;+c.getPackageName()); &#125; System.out.println(&quot;接口？：&quot;+c.isInterface()); System.out.println(&quot;枚举？：&quot;+c.isEnum()); System.out.println(&quot;数组？：&quot;+c.isArray()); System.out.println(&quot;基本数据类型？：&quot;+c.isPrimitive()); &#125;&#125; 运行结果 1234567891011121314151617181920212223242526272829303132333435363738------------------------------------------简单类名：String全限定类名：java.lang.String包名：java.lang接口？：false枚举？：false数组？：false基本数据类型？：false------------------------------------------简单类名：Runnable全限定类名：java.lang.Runnable包名：java.lang接口？：true枚举？：false数组？：false基本数据类型？：false------------------------------------------简单类名：Year全限定类名：java.time.Year包名：java.time接口？：false枚举？：false数组？：false基本数据类型？：false------------------------------------------简单类名：String[]全限定类名：[Ljava.lang.String;接口？：false枚举？：false数组？：true基本数据类型？：false------------------------------------------简单类名：int全限定类名：int接口？：false枚举？：false数组？：false基本数据类型？：true 2. 通过Class实例来创建对应类型实例 代码如下 12Class c = String.class; //获取String Class的实例String s = (String)c.newInstance(); //通过实例创建String实例 注意 Class.newInstance()方式创建类实例时，只能调用该类的public无参数构造方法 4. 反射的一些细节动态加载 JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。 动态加载class的特性对于Java程序非常重要。利用此特性，我们才能在运行期根据条件加载不同的实现类。 例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下： 1234567891011121314151617&#x2F;&#x2F; Commons Logging优先使用Log4j:LogFactory factory &#x3D; null;if (isClassPresent(&quot;org.apache.logging.log4j.Logger&quot;)) &#123; factory &#x3D; createLog4j();&#125; else &#123; factory &#x3D; createJdkLog();&#125;boolean isClassPresent(String name) &#123; try &#123; Class.forName(name); return true; &#125; catch (Exception e) &#123; return false; &#125;&#125; 这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。 总结 JVM为每个加载的类（或者接口）创建了与之关联的Class实例 通过Class实例可以获取class全部信息，此过程称为反射（Reflection）。 JVM是动态加载class的 注意：本文章参考于廖雪峰，如要学习，请访问廖雪峰网站 ​","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://tobing.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Idea:java 不支持发行版本5","slug":"Idea-java-不支持发行版本5","date":"2019-10-03T10:00:16.000Z","updated":"2021-01-15T04:21:37.817Z","comments":true,"path":"2019/10/03/Idea-java-不支持发行版本5/","link":"","permalink":"https://tobing.top/2019/10/03/Idea-java-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/","excerpt":"在使用Intellij idea构建Maven工程的时候，运行报错Error : java 不支持发行版本5。本文针对该问题提出了几个解决方法。","text":"在使用Intellij idea构建Maven工程的时候，运行报错Error : java 不支持发行版本5。本文针对该问题提出了几个解决方法。 Intellij idea : java 不支持发行版本51. 问题描述 在使用Intellij idea构建Maven工程的时候，运行报错Error : java 不支持发行版本5。 2. 问题原因 Idea 中的java的编译器使用了1.5版本来编译，导致无法通过。【不够严谨】 maven工程默认以JDK1.5作为编译运行的版本，但是1.5版本太低，不被idea支持。 3. 解决办法 方法一 File—-&gt;ProjectStructure—–&gt;Module File—-&gt;ProjectStructure—–&gt;Project 修改如下设置，使其为1.5以上 再到File—&gt;Settings—&gt;Build,Ex….—&gt;Java Compiler，将其内容修改问如下。 方法二【推荐】 在maven工程的pom文件中指定编译和运行的jdk版本 1234&lt;properties&gt; &lt;maven.compiler.source&gt;1.9&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.9&lt;/maven.compiler.target&gt;&lt;/properties&gt; properties标签与dependencies同一级","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"Intellij idea","slug":"Intellij-idea","permalink":"https://tobing.top/tags/Intellij-idea/"}]},{"title":"GithubPage绑定域名问题","slug":"GithubPage绑定域名问题","date":"2019-10-03T02:50:45.000Z","updated":"2021-01-15T03:03:16.586Z","comments":true,"path":"2019/10/03/GithubPage绑定域名问题/","link":"","permalink":"https://tobing.top/2019/10/03/GithubPage%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98/","excerpt":"在每次使用hexo d推送文章到githubPage的时候，如果不配置，直接输入绑定的域名将无法访问，本文将介绍如何解决这个问题。","text":"在每次使用hexo d推送文章到githubPage的时候，如果不配置，直接输入绑定的域名将无法访问，本文将介绍如何解决这个问题。 1. 问题描述 在每次使用hexo d推送文章到githubPage的时候，如果不配置，直接输入绑定的域名将无法访问。（404Error） 2. 问题原因 在每次hexo d 推送文章的时候。GithubPage仓库的CNAME文件都会被刷掉，导致githubpage认不出指定域名，不允许访问。 3. 解决办法 在本地的source目录中添加CNAME，并且在其中输入你的域名（例如本站域名是tobing.top），不需要添加http协议前缀。（推荐使用该方法，一劳永逸） 每次推送完毕之后，登录github到githubpage仓库的Settings中修改Github Pages的Custom domain为指定域名（格式同上）。（该方法每次推送都要设置，麻烦） 总结 在source目录添加CNAME文件，注意无后缀。编辑其内容为你的域名。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://tobing.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://tobing.top/tags/Hexo/"},{"name":"GithubPage","slug":"GithubPage","permalink":"https://tobing.top/tags/GithubPage/"},{"name":"域名绑定","slug":"域名绑定","permalink":"https://tobing.top/tags/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"}]},{"title":"git的常用命令","slug":"git的入门使用","date":"2019-10-02T13:06:58.000Z","updated":"2021-01-15T03:01:16.125Z","comments":true,"path":"2019/10/02/git的入门使用/","link":"","permalink":"https://tobing.top/2019/10/02/git%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","excerpt":"git在日常开发必不可少，本文介绍了git常用命令。","text":"git在日常开发必不可少，本文介绍了git常用命令。 Git的常用命令1. 初始化仓库1$ git init # 初始化仓库 2. 添加修改到暂存区12$ git add [文件名] # 添加指定文件到暂存区$ git add * # 添加所有文件到暂存区 3. 添加修改到工作区1$ git commit -m &quot;修改了什么&quot; # 提交修改并指定修改说明 4. 推送修改到远程服务器123$ git remote add [shortname] [url]$ git remote add origin git@github.com:[username]/[respName].git # 添加指定仓库$ git push -u origin master # 推送修改 可能存在的问题 1234567891011[UserName]@[UserName] MINGW64 /e/Code/JavaRe (master)$ git push -u origin master # 推送的时候出现了以下错误To github.com:[Username]/[respName].git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &#x27;git@github.com:[Username]/[respName].git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 问题根源：远程服务器仓库中的文件和本地的不一样。（之前直接在GitHub添加了readme文件） 解决：12$ git pull --rebase origin # 使用pull合并文件$ git push -u origin master # 合并完毕之后再更新 5. 克隆12$ git clone [url]$ git clone git@github.com:[username]/[respName].git # 克隆远程服务器文件到本地中 总结 对应git的命令仍然不够熟练 对于git的工作流程理解仍不够到位 对应github的使用欠缺 写此文件便于记忆","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"https://tobing.top/tags/git/"}]},{"title":"Java集合","slug":"Java集合","date":"2019-10-02T12:35:08.000Z","updated":"2021-01-15T03:48:51.107Z","comments":true,"path":"2019/10/02/Java集合/","link":"","permalink":"https://tobing.top/2019/10/02/Java%E9%9B%86%E5%90%88/","excerpt":"Java集合在Java语言生态的重要地位不可忽视，接下来让我们一探究竟。","text":"Java集合在Java语言生态的重要地位不可忽视，接下来让我们一探究竟。 Java集合1. 背景 没有集合之前，Java已经可以存储对象，那就是数组 。数组既可以存基本数据类型，也可以存同一种引用数据类型。对数组查找是高效的，但是数组一旦定义长度就不可变，而且只能存放同一种类型。 在程序设计的过程中，我们经常用到：队列、链接表、树和散列表等数据结构。没有集合前，如果我们需要用的，必须每次都自己定义非常麻烦，因此Java设计者就将这些数据结构封装起来提供给程序员使用。 2. Java集合的特点 高性能。对于集合中的类，Java开发人员对其实现是高效的。一般很少人去改动这些已经很成熟其高效的API 抽象性。集合类允许不同类型的集合以相同的方式和高度互操作方式工作； 扩展性。集合类容易扩展和修改，程序员可以很容易地稍加改造就能满足自己的数据结构需求。 3. 集合的好处 降低了开发难度。不必要再自己实现数据结构。 提高了运行速度。集合类的内部实现是高效的 高抽象性。借助泛型，只要了解了这些类的使用方法，就可以将它们应用到很多数据类型中。如果知道了LinkedList&lt;String&gt;的使用方法，也会知道LinkedList&lt;Double&gt;怎么用，则无需为每一种数据类型学习不同的API 高重用性。借助泛型，就算对集合类中的元素类型进行了修改，集合类相关的代码也几乎不用修改。 4. Java集合框架 Java集合框架包含两大类：集合（Collection）和图（Map）。 Collection存放一个元素集合；Map存放键值对映射 1. Collection接口： 最基本的集合接口，存储一组不唯一，无序的对象。 Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。 2. List接口： 有序、可重复Collection，可控制插入位置。 可以通过下标访问 3. Set接口 一组无序、不可重复元素 4. SortedSet接口 继承Set，保存有序 5. Map接口 存放一组键值对对象，提供key（键）到value（值）的映射。 6. Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。 7. SortedMap 继承自Map，使Key保存在升序 8. Enumeration 可以枚举（一次获得一个）对象集合中的元素。 被迭代器取代 注意：Set和List区别 Set List 无序、不可重复 有序、可重复 查找效率低；删除和插入效率高 查找效率高。插入删除效率低 插入删除不会引起元素位置改变 动态增长。插入删除会引起元素位置改变 HashSet TreeSet ArrayList LinkedList Vector 5. 集合使用 ArrayList的遍历 123456789101112131415161718192021222324252627282930313233package top.tobing.collection;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * ArrayList的使用 * @author Tobing */public class Demo01CollArrayList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;!&quot;); // 遍历一：增强for变量 for(String s:list) &#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); // 遍历二：转为数组 String[] strArr = new String[list.size()]; list.toArray(strArr); for(int i=0;i&lt;strArr.length;i++) &#123; System.out.print(strArr[i]+&quot; &quot;); &#125; System.out.println(); // 遍历三：迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; &#125;&#125; 结果 123Hello World ! Hello World ! Hello World ! Map的遍历 123456789101112131415161718192021222324252627282930313233package top.tobing.collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * 变量Map * @author Tobing */public class Demo02CollMap &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;1&quot;,&quot;One&quot;); map.put(&quot;2&quot;,&quot;Two&quot;); map.put(&quot;3&quot;,&quot;Three&quot;); map.put(&quot;4&quot;,&quot;Four&quot;); // 遍历一：二次取值（常用） for(String key:map.keySet()) &#123; System.out.print(key+&quot;:&quot;+map.get(key)+&quot;\\t&quot;); &#125; System.out.println(); // 遍历二：Map.entrySet使用迭代器 Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while(it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.print(entry.getKey()+&quot;:&quot;+entry.getValue()+&quot;\\t&quot;); &#125; System.out.println(); // 遍历三：推荐，容量大的时候 for(Map.Entry&lt;String, String&gt; entry:map.entrySet()) &#123; System.out.print(entry.getKey()+&quot;:&quot;+entry.getValue()+&quot;\\t&quot;); &#125; &#125;&#125; 结果 1231:One 2:Two 3:Three 4:Four 1:One 2:Two 3:Three 4:Four 1:One 2:Two 3:Three 4:Four","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://tobing.top/tags/%E9%9B%86%E5%90%88/"}]},{"title":"魅蓝Note5获取完整Root权限","slug":"魅蓝Note5获取完整Root权限","date":"2019-10-02T10:54:17.000Z","updated":"2021-01-15T02:58:41.837Z","comments":true,"path":"2019/10/02/魅蓝Note5获取完整Root权限/","link":"","permalink":"https://tobing.top/2019/10/02/%E9%AD%85%E8%93%9DNote5%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4Root%E6%9D%83%E9%99%90/","excerpt":"介绍如何获取魅蓝note5的root权限","text":"介绍如何获取魅蓝note5的root权限 魅蓝note5获取完整root 确认手机的系统版本是否为6.7.7.1 beta,如果不是则点击页面中链接下载。 备份数据，开始刷机 进入系统之后，联网登录账户，只有登录账户才可以打开root权限，其他东西先别动。 重启之后，安装supersu，点击更新二进制文件，重启。 注意:版本一定要是这个本页面链接下的版本。而且在软件获取root权限的时候，supersu是无法操作的，解决办法是直接进入supersu授权 获取root权限可以干什么 装框架 装linux linux+内网穿透 = 服务器","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://tobing.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"root","slug":"root","permalink":"https://tobing.top/tags/root/"},{"name":"魅蓝Note5","slug":"魅蓝Note5","permalink":"https://tobing.top/tags/%E9%AD%85%E8%93%9DNote5/"}]},{"title":"CentOS的初步使用","slug":"CentOS的初步使用","date":"2019-10-02T03:33:59.000Z","updated":"2021-01-15T03:32:42.394Z","comments":true,"path":"2019/10/02/CentOS的初步使用/","link":"","permalink":"https://tobing.top/2019/10/02/CentOS%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/","excerpt":"Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.","text":"Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统. CentOS学习 1. 背景历史​ Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统. 2. 应用 服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等， 高性能运算、计算密集型应用Linux有强大的运算能力。 桌面应用系统 移动手持系统 3. 版本 内核版本：Linus领导下的内核小组开发维护的系统内核的版本号 发行版本： 4.目录结构 / ：根目录 目录名称 全名 描述 bin binaries 二进制可执行文件 boot 系统引导时使用的各种文件 dev devices 设备文件 etc ectetera 系统配置文件 home 用户文件根目录 lib library 跟文件系统中的程序运行需要的共享库以及内核模块 sbin super user binaries root才能访问的二进制可执行文件 usr Unix shared resources 存放共享的系统资源 var variable 用于存放运行时需要改变数据的文件 1234567891011121314151617181920lrwxrwxrwx. 1 root root 7 Aug 18 2017 bin -&gt; usr/bin # bin目录dr-xr-xr-x. 4 root root 4096 Sep 12 2017 boot # boot目录drwxr-xr-x 19 root root 2960 Sep 27 22:01 dev # dev目录drwxr-xr-x. 82 root root 4096 Sep 28 06:01 etc # etc目录drwxr-xr-x. 3 root root 4096 Sep 27 16:12 home # home目录lrwxrwxrwx. 1 root root 7 Aug 18 2017 lib -&gt; usr/lib # lib目录lrwxrwxrwx. 1 root root 9 Aug 18 2017 lib64 -&gt; usr/lib64 # lib64drwx------. 2 root root 16384 Aug 18 2017 lost+found drwxr-xr-x. 2 root root 4096 Nov 5 2016 media drwxr-xr-x. 2 root root 4096 Nov 5 2016 mntdrwxr-xr-x. 2 root root 4096 Nov 5 2016 optdr-xr-xr-x 74 root root 0 Sep 27 22:01 procdr-xr-x---. 6 root root 4096 Sep 5 2017 rootdrwxr-xr-x 21 root root 580 Sep 27 22:01 runlrwxrwxrwx. 1 root root 8 Aug 18 2017 sbin -&gt; usr/sbin # root的bin目录drwxr-xr-x. 2 root root 4096 Nov 5 2016 srv dr-xr-xr-x 13 root root 0 Sep 28 06:01 sysdrwxrwxrwt. 11 root root 4096 Sep 29 03:40 tmp # 临时文件drwxr-xr-x. 13 root root 4096 Aug 18 2017 usr # 存放共享的系统资源drwxr-xr-x. 19 root root 4096 Sep 28 06:01 var # 用于存放运行时需要改变数据的文件 4. 常用命令 切换命令：cd 12cd .. # 切换到上一层目录cd ~ # 切换到系统根目录 列出文件列表:ls 123ls # 列出文件ls -a # 显示所有文件和目录（包含隐藏）ls -l # 缩写成ll 创建目录（mkdir）和移除目录（rmdir） 123mkdir [dirname] # 创建文件夹rmdir [dirname] # 移除文件夹rmdir -p dir1/dir2 # 移除两级文件夹 浏览文件 12345678910cat # 用于显示文件的内容more # 用于显示的内容超过一个画面长度的情况下使用。空格键显示下一个界面。回车显示下一行内容。less # 和more类似，不同的是less可以通过PgUp、PgDn控制tail # 显示文件后几行的内容tail -10 /etc/passwd # 查看后10行数据tail -f catalina.log # 动态查看日志ctrl + c # 结束查看 文件操作 123456789101112131415161718192021222324252627282930rm # 删除文件rm a.txt # 删除a.txt 文件rm -f a.txt # 不询问直接删除rm -f a # 不询问，递归删除文件【慎用】rm -rf a # 不询问，递归删除文件夹rm -rf * # 删除所有文件rm -rf /* # 自杀cp a.txt b.txt # 将a.txt复制为b.txt文件cp a.txt ../ # 将文件复制到上一级目录mv a.txt ../ # 将a.txt文件移动到上一层目录中mv a.txt b.txt # 将a.txt重命名为b.txttar # 打包或解压tar -cvf xxx.tar ./* # 打包tar -zcvf xxx.tar.gz ./* # 打包并且压缩tar -xvf xxx.tar # 解压tar -zxvf xxx.tar.gz -C /user/aaa # 解压到指定目录find # 查找符合条件的文件find / -name &quot;ins*&quot; # 查找文件名称是以ins开头的文件find / -name &quot;ins*&quot; -lsfind / -user tobing -ls # 查找用户itcast的目录find / -user tobing -type d -ls # 查找用户tobing的目录find / -prem -777 -type d -ls # 查找权限为777的文件grep # 查找文件【内】符合条件的字符串grep java anacoda-ks.cfg # 在文件中找javagrep java anacoda-ks.cfg -color # 高亮显示 其他常用命令 123pwd # 查看当前所在目录touch # 创建一个空文件clear # 清屏 ==&gt; crtl + L 5.vi和vim 三种模式 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。此时输入的字符会被当做命令执行 输入模式：和普通的windows平台的记事本一样编辑，按Esc可以退出该模式 底行模式（底线命令行模式）： q ：退出程序 w ：保存文件 按ESC键可随时退出底线命令模式。 变换 切换到命令行：Esc 切换到插入模式：i、o、a键 字母 功能 i(小写) 当前位置前插入 I(大写) 当前行首插入 a 当前位置插入 A 当前行尾插入 o 当前行之后插入一行 O 当前行之前插入一行 vi的日常使用 在命令行输入：vi [要编辑文件名] 进入命令模式 输入i 进入插入模式，在此状态下可以像普通编辑器一样编辑 修改完毕之后，按Esc键, 退出输入模式，进入底行模式。 输入:wq保存退出 6. 重定向 &gt;&gt; 和 &gt; 12345678910111213141516[root@root ~]# echo Hello Linux &gt; a.txt # 将echo输出的内容通到a.txt文件中[root@root ~]# cat a.txt # 查看a.txt的内容Hello Linux[root@root ~]# echo Hello Centos &gt; a.txt # &gt; ： 输入的内容会覆盖之前存在的内容[root@root ~]# cat a.txt # 查看内容Hello Centos[root@root ~]# ifconfig &gt;&gt; a.txt # &gt;&gt; ： 追加模式[root@root ~]# cat a.txt # 查看内容Hello Centos eth1 Link encap:Ethernet HWaddr 00:0C:29:D3:06:82 ....lo Link encap:Local Loopback .... 7. 进程管理：ps 和 kill ps：查看进程 kill：杀死进程 1234567[root@root /]# ps -ef # 查看所有的进程UID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:53 ? 00:00:01 /sbin/initroot 2 0 0 05:53 ? 00:00:00 [kthreadd]root 3 2 0 05:53 ? 00:00:00 [migration/0]....[root@root /]# kill -9 2868 # -9 :强制杀死指定PID进程 8. 管道 | 将一个命令的输出用作另一个命令的输入 12345678910[root@root /]# ls -alh | more # 将ls输出的内容用more的模式来展示total 106Kdr-xr-xr-x. 24 root root 4.0K Oct 3 05:53 .dr-xr-xr-x. 24 root root 4.0K Oct 3 05:53 ..-rw-r--r--. 1 root root 0 Oct 3 05:53 .autofsck ...... [root@root /]# ps -ef | grep bash # 将ps输出的内容放到grep中搜索root 3665 3663 0 05:58 pts/0 00:00:00 /bin/bashroot 3729 3724 0 06:01 pts/1 00:00:00 -bashroot 3842 3729 0 06:16 pts/1 00:00:00 grep bash 9. Linux权限12345678drwxr-xr-x. 2 root root 4.0K Oct 30 2018 profile.d-rw-r--r--. 1 root root 6.4K Jan 12 2010 protocolslrwxrwxrwx. 1 root root 7 Oct 30 2018 rc -&gt; rc.d/rc# xuuugggooo.# 将a.txt的权限修改为用户可读可写可执行，组可读可执行，其他可执行[root@root etc]# chmod u=rwx,g=rx,o=rx a.txt # 将b.txt的权限修饰为 u=rxw，g=rx,o=x[root@root etc]# chmod 755 b.txt x：文件类型 d：文件 -：文件夹 l：超链接 u：用户权限 g：组权限 o：其他用户权限 r：读权限 —- 4 w：写权限 —- 2 x：可执行权限 —- 1 10. 网络相关1. 主机名配置123456[root@root /]# hostname # 查看主机名tobing[root@root /]# hostname admin # 修改主机名为admin（临时修改）[root@root /]# hostnameadmin[root@root /]# vi /etc/sysconfig/network # 持久化修改主机名 2.IP地址配置 12345678910111213141516[root@root /]# ifconfig # 查看当前ip配置eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet `[ip地址]` netmask 255.255.192.0 broadcast ....lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 ....[root@root /]# ifconfig eth0 192.168.1.133 # 修改IP地址[root@root /]# vi/etc/sysconfig/network-scripts/ifcfg-eth0 # 持久化修改ip相关配置DEVICE=eth0 #网卡名称BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)HWADDR=00:0C:29:B5:B2:69 #MAC地址IPADDR=12.168.177.129 #IP地址NETMASK=255.255.255.0 #子网掩码NETWORK=192.168.177.0 #网络地址BROADCAST=192.168.0.255 #广播地址NBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 3. 域名映射 123[root@root /]# vi /etc/hosts192.168.1.123 tobingping tobing == &gt; ping 192.168.1.123 4. 网络服务管理 1234567891011121314service network status # 查看指定服务的状态service network stop # 停止指定服务service network start # 启动指定服务service network restart# 重启指定服务service --status–all # 查看系统中所有后台服务netstat –nltp # 查看系统中网络进程的端口监听情况# 防火墙设置# 防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。service iptables status # 查看防火墙状态service iptables stop # 关闭防火墙service iptables start # 启动防火墙chkconfig iptables off # 禁止防火墙自启 总结 对CentOS仍处于入门级别的使用 很多问题仍然需要百度 写此文章是为了记忆常用命令","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tobing.top/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://tobing.top/tags/CentOS/"}]},{"title":"Java常用数据结构","slug":"Java常用数据结构","date":"2019-10-02T03:30:09.000Z","updated":"2021-01-15T03:40:09.319Z","comments":true,"path":"2019/10/02/Java常用数据结构/","link":"","permalink":"https://tobing.top/2019/10/02/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"有人说：程序=算法+数据结构，接下来就让我们看一下Java中常用的数据结构吧。","text":"有人说：程序=算法+数据结构，接下来就让我们看一下Java中常用的数据结构吧。 Java数据结构1. 枚举（Enumeration） 接口，本身不属于数据结构,但它在其他数据结构的范畴里应用很广。枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。 注：此接口的功能与 Iterator 接口的功能是重复的。此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应该优先考虑使用Iterator 接口而不是 Enumeration 接口。 123456789101112131415161718192021222324252627282930boolean hasMoreElements() //测试此枚举是否包含更多的元素。 E nextElement() //如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。 package top.tobing.datastruct;import java.util.Enumeration;import java.util.Vector;/** * 枚举接口 * @author Tobing * */public class Demo02DSEnum &#123; public static void main(String[] args) &#123; Vector&lt;String&gt; dayNums = new Vector&lt;String&gt;(); dayNums.add(&quot;Sunday&quot;); dayNums.add(&quot;Monday&quot;); dayNums.add(&quot;Tuesday&quot;); dayNums.add(&quot;Wednesday&quot;); dayNums.add(&quot;Thurday&quot;); dayNums.add(&quot;Firday&quot;); dayNums.add(&quot;Saturday&quot;); // 将向量dayNums中的元素放到days中，以方便变量（类似于Iterator接口） Enumeration&lt;String&gt; days; days = dayNums.elements(); while(days.hasMoreElements()) &#123; System.out.println(days.nextElement()); &#125; &#125;&#125; 2. 位集合（BitSet） 少用 位集合类实现了一组可以单独设置和清除的位或标志。 该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。 12345678910111213141516171819202122232425262728293031323334package top.tobing.datastruct;import java.util.BitSet;/** * BitSet测速（源码摘自菜鸟教程） * @author Tobing */public class Demo03DSBitSet &#123; public static void main(String[] args) &#123; BitSet bits1 = new BitSet(16); BitSet bits2 = new BitSet(16); // 存储元素 for(int i=0; i&lt;16; i++) &#123; if((i%2) == 0) bits1.set(i); // 存放偶数 if((i%5) != 0) bits2.set(i); // 存放非5倍数 &#125; System.out.println(&quot;bit1的内容是：&quot;); System.out.println(bits1); System.out.println(&quot;bit2的内容是：&quot;); System.out.println(bits2); // AND bits bits2.and(bits1); System.out.println(&quot;\\nbits2 AND bits1: &quot;); System.out.println(bits2); // OR bits bits2.or(bits1); System.out.println(&quot;\\nbits2 OR bits1: &quot;); System.out.println(bits2); // XOR bits bits2.xor(bits1); System.out.println(&quot;\\nbits2 XOR bits1: &quot;); System.out.println(bits2); &#125;&#125; 3. 向量（Vector） 向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。 java.lang.Object // 继承关系 - java.util.AbstractCollection&lt;E&gt; - - java.util.AbstractList&lt;E&gt; - - - java.util.Vector&lt;E&gt; 1234567891011121314151617181920212223242526272829303132&#96;&#96;&#96;java&#x2F;&#x2F; 字段列表protected int capacityIncrement &#x2F;&#x2F;向量的大小大于其容量时，容量自动增加的量。 protected int elementCount &#x2F;&#x2F;Vector 对象中的有效组件数。 protected Object[] elementData &#x2F;&#x2F;存储向量组件的数组缓冲区。&#x2F;&#x2F; 使用演示package top.tobing.datastruct;import java.util.Enumeration;import java.util.Vector;&#x2F;** * Vector * @author Tobing *&#x2F;public class Demo04DSVector &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 初始容量为3，增长长度为2 Vector v &#x3D; new Vector(3,2); v.addElement(&quot;Hello&quot;); v.addElement(&quot; , &quot;); System.out.println(&quot;Size:&quot;+v.size()); v.addElement(&quot;World！&quot;); v.addElement(&quot;!&quot;); System.out.println(&quot;Size:&quot;+v.size()); &#x2F;&#x2F; 大小 System.out.println(&quot;Cap:&quot;+v.capacity()); &#x2F;&#x2F; 容量 &#x2F;&#x2F; 遍历 Enumeration enum1 &#x3D; v.elements(); while(enum1.hasMoreElements()) &#123; System.out.print(enum1.nextElement()); &#125; &#125;&#125; 4. 栈（Stack） 栈（Stack）实现了一个后进先出（LIFO）的数据结构。 12345678910111213141516171819202122232425262728293031// 使用演示package top.tobing.datastruct;import java.util.Stack;/** * Stack是Vector的一个子类 * @author Tobing * */public class Demo04DSVector &#123; public static void main(String[] args) &#123; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); // 压栈：把元素压入堆栈顶部 st.push(100); st.push(200); st.push(300); st.push(400); System.out.println(&quot;Stack:&quot;+st); // 出栈：移除栈顶元素，并且返回 int n = st.pop(); System.out.println(&quot;出栈的元素为：&quot;+n); System.out.println(&quot;Stack:&quot;+st); // 查看栈顶元素，且不出栈 int top = st.peek(); System.out.println(&quot;栈顶的元素为：&quot;+top); // 查找某个元素 int flag1 = st.search(200); int flag2 = st.search(555); System.out.println(flag1); System.out.println(flag2); &#125;&#125; 5. 字典（Dictionary） Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。 Dictionary类已经过时了。在实际开发中，你可以实现Map接口来获取键/值的存储功能。 6. 哈希表（HashTable） Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。 // 演示 package top.tobing.datastruct; import java.util.Enumeration; import java.util.Hashtable; /** * 哈希表：无序的 * @author Tobing * */ public class Demo06DSHashtable &#123; public static void main(String[] args) &#123; Hashtable score = new Hashtable(); // 存放值，包含自动装箱 score.put(&quot;Tobing&quot;, 99); score.put(&quot;Zenyet&quot;,100); score.put(&quot;Rongon&quot;,100); score.put(&quot;Acto&quot;,100); // 遍历（返回key的枚举） Enumeration enum1 = score.keys(); while(enum1.hasMoreElements()) &#123; String key = (String)enum1.nextElement(); System.out.println(key+&quot;:&quot;+score.get(key)); &#125; &#125; &#125; 12345678- 运行结果 &#96;&#96;&#96;bash Acto:100 Tobing:99 Zenyet:100 Rongon:100 7. 属性（Properties） Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。 Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 package top.tobing.datastruct; import java.util.Iterator; import java.util.Properties; import java.util.Set; /** * Properties * @author Tobing * */ public class Demo07DSProperties &#123; public static void main(String[] args) &#123; Properties pro = new Properties(); pro.put(&quot;Tobing&quot;,&quot;Dell&quot;); pro.put(&quot;Acto&quot;,&quot;Dell&quot;); pro.put(&quot;Zenyet&quot;,&quot;HuaWei&quot;); pro.put(&quot;Rongon&quot;,&quot;Lenove&quot;); Set proSet = pro.keySet(); Iterator it = proSet.iterator(); while(it.hasNext()) &#123; String name = (String)it.next(); System.out.println(name+&quot;:&quot;+pro.get(name)); &#125; &#125; &#125;","categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello! Hexo","slug":"Hello","date":"2019-10-02T01:59:15.000Z","updated":"2021-01-15T03:40:55.128Z","comments":true,"path":"2019/10/02/Hello/","link":"","permalink":"https://tobing.top/2019/10/02/Hello/","excerpt":"你好Hexo 多读书，多看报 :)","text":"你好Hexo 多读书，多看报 :)","categories":[{"name":"技术应用","slug":"技术应用","permalink":"https://tobing.top/categories/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://tobing.top/tags/Hexo/"}]}],"categories":[{"name":"理论学习","slug":"理论学习","permalink":"https://tobing.top/categories/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"},{"name":"工具使用","slug":"工具使用","permalink":"https://tobing.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"技术应用","slug":"技术应用","permalink":"https://tobing.top/categories/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://tobing.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://tobing.top/tags/Java/"},{"name":"动态代理","slug":"动态代理","permalink":"https://tobing.top/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"https://tobing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"反射","slug":"反射","permalink":"https://tobing.top/tags/%E5%8F%8D%E5%B0%84/"},{"name":"线程池","slug":"线程池","permalink":"https://tobing.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"JVM","slug":"JVM","permalink":"https://tobing.top/tags/JVM/"},{"name":"排序算法","slug":"排序算法","permalink":"https://tobing.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tobing.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://tobing.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"GitHub","slug":"GitHub","permalink":"https://tobing.top/tags/GitHub/"},{"name":"MySQL","slug":"MySQL","permalink":"https://tobing.top/tags/MySQL/"},{"name":"小程序","slug":"小程序","permalink":"https://tobing.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"认证机制","slug":"认证机制","permalink":"https://tobing.top/tags/%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"},{"name":"jwt","slug":"jwt","permalink":"https://tobing.top/tags/jwt/"},{"name":"文件上传","slug":"文件上传","permalink":"https://tobing.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://tobing.top/tags/SpringBoot/"},{"name":"数据结构","slug":"数据结构","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://tobing.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://tobing.top/tags/%E9%98%9F%E5%88%97/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://tobing.top/tags/MongoDB/"},{"name":"docker","slug":"docker","permalink":"https://tobing.top/tags/docker/"},{"name":"容器技术","slug":"容器技术","permalink":"https://tobing.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"},{"name":"数组 - Java","slug":"数组-Java","permalink":"https://tobing.top/tags/%E6%95%B0%E7%BB%84-Java/"},{"name":"树莓派","slug":"树莓派","permalink":"https://tobing.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"DHT11","slug":"DHT11","permalink":"https://tobing.top/tags/DHT11/"},{"name":"物联网","slug":"物联网","permalink":"https://tobing.top/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"实验","slug":"实验","permalink":"https://tobing.top/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"分享","slug":"分享","permalink":"https://tobing.top/tags/%E5%88%86%E4%BA%AB/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://tobing.top/tags/ElasticSearch/"},{"name":"全文检索","slug":"全文检索","permalink":"https://tobing.top/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"},{"name":"Spring","slug":"Spring","permalink":"https://tobing.top/tags/Spring/"},{"name":"Spring-Security","slug":"Spring-Security","permalink":"https://tobing.top/tags/Spring-Security/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://tobing.top/tags/Mybatis/"},{"name":"PageHelper","slug":"PageHelper","permalink":"https://tobing.top/tags/PageHelper/"},{"name":"总结","slug":"总结","permalink":"https://tobing.top/tags/%E6%80%BB%E7%BB%93/"},{"name":"Oracle","slug":"Oracle","permalink":"https://tobing.top/tags/Oracle/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://tobing.top/tags/SpringMVC/"},{"name":"JDBC","slug":"JDBC","permalink":"https://tobing.top/tags/JDBC/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://tobing.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"校园宽带","slug":"校园宽带","permalink":"https://tobing.top/tags/%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6/"},{"name":"路由器","slug":"路由器","permalink":"https://tobing.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"Windows","slug":"Windows","permalink":"https://tobing.top/tags/Windows/"},{"name":"单片机","slug":"单片机","permalink":"https://tobing.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"注解","slug":"注解","permalink":"https://tobing.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Intellij idea","slug":"Intellij-idea","permalink":"https://tobing.top/tags/Intellij-idea/"},{"name":"Hexo","slug":"Hexo","permalink":"https://tobing.top/tags/Hexo/"},{"name":"GithubPage","slug":"GithubPage","permalink":"https://tobing.top/tags/GithubPage/"},{"name":"域名绑定","slug":"域名绑定","permalink":"https://tobing.top/tags/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"name":"git","slug":"git","permalink":"https://tobing.top/tags/git/"},{"name":"集合","slug":"集合","permalink":"https://tobing.top/tags/%E9%9B%86%E5%90%88/"},{"name":"root","slug":"root","permalink":"https://tobing.top/tags/root/"},{"name":"魅蓝Note5","slug":"魅蓝Note5","permalink":"https://tobing.top/tags/%E9%AD%85%E8%93%9DNote5/"},{"name":"Linux","slug":"Linux","permalink":"https://tobing.top/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://tobing.top/tags/CentOS/"}]}